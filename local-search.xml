<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2020/06/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/06/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h1><p>各个算法的时间和空间复杂度如下图所示：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200611124222.png" srcset="/img/loading.gif" alt="image-20200611124218763"></p><p>选择排序：最稳定的排序算法，无论什么情况时间复杂度否是O(n^2)</p><p>插入排序：采用in-place内部排序，空间复杂度为O(1)</p><p>归并排序：稳定的排序算法，分治思想的典型应用，先使子序列有序，再将两个子序列合并成有序序列</p><p>快速排序：不稳定</p><p>堆排序：利用数据结构堆设计的排序算法</p><p>计数排序：稳定排序算法，不是基于比较的排序算法，将数组转换成键值对的形式存储在额外的数组空间</p><p>桶排序：稳定，桶的划分很重要</p><p>基数排序：稳定，按照数字位上的数排序。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基数排序</title>
    <link href="/2020/06/11/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/11/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>基数排序是桶排序的升级版把数组中每一个数字，都分成不同位，先比较数字不同位的大小，先按照个位大小排序，再按照十位大小排序….一直到最高位，最高位的排序结果就是最终的排序结果，具体见下图，图片来自@sky。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200611122731.png" srcset="/img/loading.gif" alt="image-20200611122725122"></p><p>Java代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buicketSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> maxExp=getExp(nums);    <span class="hljs-keyword">int</span> len=nums.length;    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) lists.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<span class="hljs-comment">//因为是十进制，所以有0~9，十个桶</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=maxExp;i++)    &#123;        <span class="hljs-comment">//1234,假如想得到百位的2，应该是1234%1000=234,234/100=2，所以应该先取模，再相除，最终就知道了值</span>        <span class="hljs-keyword">double</span> exp1=Math.pow(<span class="hljs-number">10</span>, i);        <span class="hljs-keyword">double</span> exp2=Math.pow(<span class="hljs-number">10</span>,i-<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)<span class="hljs-comment">//先按照位添加到指定数组中</span>        &#123;            <span class="hljs-keyword">int</span> index=(<span class="hljs-keyword">int</span>)(nums[j]%exp1/exp2);<span class="hljs-comment">//算出这数字nums[j]的某一位的值，来决定添加到哪一个桶上</span>            lists.get(index).add(nums[j]);<span class="hljs-comment">//添加到指定桶</span>        &#125;        <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<span class="hljs-comment">//下标，按照位排好序的结果要写回原数组</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">10</span>;j++)<span class="hljs-comment">//遍历list中的每一个数组，将其写回到原数组中去</span>        &#123;            <span class="hljs-keyword">while</span> (lists.get(j).size()&gt;<span class="hljs-number">0</span>)            &#123;                ArrayList&lt;Integer&gt; temp=lists.get(j);                nums[k++]=temp.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//把按照某一位排序的结果写回到数组</span>                temp.remove(<span class="hljs-number">0</span>);            &#125;        &#125;    &#125;&#125;</code></pre><p>用处：主要用于处理数字较多的情况，比如手机号排序。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桶排序</title>
    <link href="/2020/06/11/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/11/%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>桶排序是一种计数排序的升级版，如果把每一个数都看成是一个桶的话，那么桶排序就是计数排序，简单来说就是生成若干个桶，每一个桶存放指定范围内的数据，如数组范围是0<del>100，有十个桶，每一个桶的范围分别是0</del>10,10~20，….等，通过把数据分到桶中，再对桶中数据进行排序，然后再依次从桶中取出数据，即为最终排好序的数据。桶排序需要尽量保证元素分散均匀，否则当所有数据集中在同一个桶中时，桶排序失效</p><p>注：桶之间也是有序的，即后一个桶的最小值是大于前一个桶的最大值的。</p><p>Java代码如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buicketSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> min=nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> max=nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> len=nums.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">if</span>(min&gt;nums[i]) min=nums[i];        <span class="hljs-keyword">if</span> (max&lt;nums[i]) max=nums[i];    &#125;    <span class="hljs-keyword">int</span> buicketNum=(max-min)/len+<span class="hljs-number">1</span>;<span class="hljs-comment">//确定桶的个数</span>    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; buicket=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;buicketNum;i++)    &#123;        buicket.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)        buicket.get((i-min)/len).add(nums[i]);<span class="hljs-comment">//按照元素的值来放到指定的桶内</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;buicketNum;i++)        Collections.sort(buicket.get(i));<span class="hljs-comment">//每一个桶内的排序方式任意</span>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;buicketNum;i++)<span class="hljs-comment">//遍历桶，后一个桶内的最小值是大于前一个桶内的最大值的。</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;buicket.get(i).size();i++)            nums[index++]= buicket.get(i).get(j);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计数排序</title>
    <link href="/2020/06/11/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/11/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序是通过数组中元素出现的次数来计数的，先找到数组中的最大值max，然后建立一个长度为max+1的数组count，对原数组nums中的数字出现的次数遍历，最后再遍历count数组，如果count[i]值不为空，说明nums中有这个值，输出回原数组nums，遍历完count数组，即得到了nums数组排序后的结果</p><p>代码如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录数组最大值</span>    <span class="hljs-keyword">int</span> len=nums.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">if</span>(res&lt;nums[i]) res=nums[i];<span class="hljs-comment">//找到数组最大值</span>    &#125;    <span class="hljs-keyword">int</span>[] count=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res+<span class="hljs-number">1</span>];<span class="hljs-comment">//建立长度为res+1的计数数组</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) count[nums[i]]++;<span class="hljs-comment">//计算nums[i]出现的次数</span>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;res;i++)<span class="hljs-comment">//遍历count数组</span>    &#123;        <span class="hljs-keyword">while</span> (count[i]&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//如果数组大于0，说明nums数组中有i这个值</span>        &#123;            nums[k++]=i;<span class="hljs-comment">//将这个值写会到数组中</span>            count[i]--;<span class="hljs-comment">//i这个值出现次数-1</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(i&gt;=nums.length) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> temp=nums[i];    nums[i]=nums[j];    nums[j]=temp;&#125;</code></pre><p>优化：</p><p>容易发现count数组小于下标nums中最小值的空间都被浪费了，是不可能存在值的，所以可以建立一个长度为Max-min+1数组</p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> max=nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> min=nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> len=nums.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">if</span>(max&lt;nums[i]) max=nums[i];        <span class="hljs-keyword">if</span>(min&gt;nums[i]) min=nums[i];    &#125;    <span class="hljs-keyword">int</span>[] count=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max-min+<span class="hljs-number">1</span>];<span class="hljs-comment">//优化空间</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) count[nums[i]-min]++;<span class="hljs-comment">//优化代码</span>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;max-min+<span class="hljs-number">1</span>;i++)    &#123;        <span class="hljs-keyword">while</span> (count[i]&gt;<span class="hljs-number">0</span>)        &#123;            nums[k++]=i+min;<span class="hljs-comment">//优化代码</span>            count[i]--;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(i&gt;=nums.length) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> temp=nums[i];    nums[i]=nums[j];    nums[j]=temp;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序</title>
    <link href="/2020/06/11/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/11/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆是一颗完全二叉树，即除了最后一层，其余每一层的左右结点都被填满，且最后一层叶子节点从左到右依次填充</p><p>大根堆：根节点的值大于左右结点的值(不要求左右节点的相对大小，即左节点一定要大于右节点或者右节点一定要大于左节点)</p><p>小根堆：根节点的值小于左右结点的值</p><p>下面讲解大根堆的堆排序</p><p>堆排序是通过维护一个大根堆，来使得堆顶元素总是为最大值，交换堆顶元素和最后一个结点元素，这样最大值就跑到了数组最后，然后继续维护剩余元素为一个大根堆，再交换堆顶元素和倒数第二个元素，以此类推，这样不断交换最大值，最终实现了排序。</p><p>注意：数组下标在堆中的对应关系：因为堆是一颗完全二叉树，所以下标为i的根节点，左节点的下标为<code>i*2+1</code>，右节点下标为<code>i*2+2</code></p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heap, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> i)</span><span class="hljs-comment">//维护下标为i的结点，使得该节点值大于左右子节点的值</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> max_index=i;<span class="hljs-comment">//下标为i的结点</span>    <span class="hljs-keyword">int</span> left=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//i结点的左节点</span>    <span class="hljs-keyword">int</span> right=i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;<span class="hljs-comment">//i节点的右节点</span>    <span class="hljs-keyword">if</span>(left&lt;size &amp;&amp; heap[left]&gt;heap[max_index]) max_index=left;<span class="hljs-comment">//记录最大值的下标</span>    <span class="hljs-keyword">if</span>(right &lt;size &amp;&amp; heap[right]&gt;heap[max_index]) max_index=right;    <span class="hljs-keyword">if</span>(max_index!=i)<span class="hljs-comment">//如果下标i的值小于左右节点中的最大值</span>    &#123;        swap(heap,max_index,i);<span class="hljs-comment">//交换堆顶元素和左右节点中的最大值</span>        heapify(heap,size,max_index);<span class="hljs-comment">//下标为i的结点被交换下来，继续维护这个结点，使得这个结点为大根堆</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heap, <span class="hljs-keyword">int</span> size)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        heapify(heap,size,i);<span class="hljs-comment">//维护每一个非叶子节点</span>    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        swap(heap,<span class="hljs-number">0</span>,i);<span class="hljs-comment">//上面已经建好一个大根堆，所以堆顶元素为最大值，把最大值放到数组最后面</span>        heapify(heap,i,<span class="hljs-number">0</span>);<span class="hljs-comment">//继续维护，数组此时长度减一</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(i&gt;=nums.length) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> temp=nums[i];    nums[i]=nums[j];    nums[j]=temp;&#125;</code></pre><p>小根堆代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heap, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> i)</span><span class="hljs-comment">//维护下标为i的结点，使得该节点值小于左右子节点的值</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> min_index=i;    <span class="hljs-keyword">int</span> left=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> right=i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span>(left&lt;size &amp;&amp; heap[left]&lt;heap[min_index]) min_index=left;<span class="hljs-comment">//只需要heap[left]&gt;heap[min_index]改成heap[left]&lt;heap[min_index]即可</span>    <span class="hljs-keyword">if</span>(right &lt;size &amp;&amp; heap[right]&lt;heap[min_index]) min_index=right;<span class="hljs-comment">//同上</span>    <span class="hljs-keyword">if</span>(max_index!=i)    &#123;        swap(heap,min_index,i);        heapify(heap,size,min_index);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heap, <span class="hljs-keyword">int</span> size)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        heapify(heap,size,i);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        swap(heap,<span class="hljs-number">0</span>,i);        heapify(heap,i,<span class="hljs-number">0</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(i&gt;=nums.length) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> temp=nums[i];    nums[i]=nums[j];    nums[j]=temp;&#125;</code></pre><p>参考资料：</p><p>图解排序算法：<a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p><p>排序算法总结：<a href="https://www.acwing.com/blog/content/2064/" target="_blank" rel="noopener">https://www.acwing.com/blog/content/2064/</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2020/06/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序先把数组分成两半，每一半再递归进行平分，当只有一个元素时，递归结束。然后两两比较值，合并数组，进行排序。</p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">//找到数组中点</span>    merge_sort(q,l,mid);<span class="hljs-comment">//递归左半部分</span>    merge_sort(q,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//递归右半部分</span>    <span class="hljs-keyword">int</span> i=l,j=mid+<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(i &lt;=mid &amp;&amp; j&lt;=r)<span class="hljs-comment">//递归结束后，开始左右两部分的值，进行排序</span>    &#123;        <span class="hljs-keyword">if</span>(q[i]&lt;q[j]) temp[k++]=q[i++];<span class="hljs-comment">//temp数组用来继续排序结果</span>        <span class="hljs-keyword">else</span> temp[k++]=q[j++];    &#125;    <span class="hljs-keyword">while</span>(i&lt;=mid) temp[k++]=q[i++];<span class="hljs-comment">//如果左半部分还有值</span>    <span class="hljs-keyword">while</span>(j&lt;=r) temp[k++]=q[j++];<span class="hljs-comment">//如果右半部分还有值</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> w=l,k=<span class="hljs-number">0</span>;w&lt;=r;w++,k++) q[w]=temp[k];<span class="hljs-comment">//将temp记录的排好序后的元素写回到原数组</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2020/06/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快排是从数组中选一个锚点privot，把数组按照锚点分成小于锚点的值和大于锚点的值两部分，然后再递归求解这两部分</p><p>下面这种解法来自@Diamondz </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//if(i&gt;=nums.length) return;</span>    <span class="hljs-keyword">int</span> temp=nums[i];    nums[i]=nums[j];    nums[j]=temp;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(left&gt;=right) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果区间长度为1，则返回</span>    <span class="hljs-keyword">int</span> privot=nums[left];<span class="hljs-comment">//选定锚点</span>    <span class="hljs-keyword">int</span> j=left;<span class="hljs-comment">//j表示锚点值privot在数组中排第几</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left+<span class="hljs-number">1</span>;i&lt;=right;i++)    &#123;        <span class="hljs-keyword">if</span>(nums[i]&lt;privot)<span class="hljs-comment">//如果有值小于privot</span>        &#123;            j++;<span class="hljs-comment">//那么就让privot的排名上升一位</span>            swap(nums,j,i);<span class="hljs-comment">//交换的目的：把小于privot的值都放到左边</span>        &#125;    &#125;    <span class="hljs-comment">//遍历完区间[left,right]后可以得到，privot在数组中排序为j,所以交换锚点的位置，从left到j</span>    swap(nums,left,j);<span class="hljs-comment">//遍历完毕后，把锚点和j位置交换一下，j位置表示锚点privot在这个数组中的排序</span>    quickSort(nums,left,j-<span class="hljs-number">1</span>);    quickSort(nums,j+<span class="hljs-number">1</span>,right);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序</title>
    <link href="/2020/06/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>把第一个元素看成是一个有序序列，然后后面的元素看成是无序序列，从这个无序序列中依次取出元素，<strong>选择</strong>应该插到前面有序序列的哪个位置</p><p><strong>注意</strong>：插入排序，不是一次就直接找到了位置，插入，而是要一个一个比较值，交换值，最后才可以找到正确位置。</p><p><strong>思路</strong>：对于无序序列的值A，在有序序列中找到一个比他的大的值就和他交换，最后停留的位置就是值A此时在有序序列中的位置。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">choseSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=nums.length;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> index=-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)<span class="hljs-comment">//无序数组的下标</span>        &#123;            res=nums[i];            index=i;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--)<span class="hljs-comment">//从后往前扫描有序数组</span>            &#123;                <span class="hljs-keyword">if</span>(nums[i]&lt;nums[j])<span class="hljs-comment">//如果无序数组的值，小于有序数组的值，说明就找到了插入位置</span>                &#123;                    swap(nums,i,j);                &#125;                <span class="hljs-keyword">else</span><span class="hljs-comment">//如果无序数组的值，大于有序数组，说明此时已经到了正确位置</span>                    <span class="hljs-keyword">break</span>;            &#125;        &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">     </span>&#123;         <span class="hljs-keyword">int</span> temp=nums[i];         nums[i]=nums[j];         nums[j]=temp;     &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/2020/06/10/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/10/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序就是选择最大值，放到最后/最前面。</p><p>在未排序的序列中找打最大值，然后将其放到最后</p><p>再从剩余的未排序序列中找到次大值，放到倒数第二个位置</p><p>依次类推，直到结束</p><p>Java代码如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=nums.length;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> index=-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len-<span class="hljs-number">1</span>;i++)<span class="hljs-comment">//剩余未排序数组的长度</span>        &#123;            res=nums[<span class="hljs-number">0</span>];            index=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len-i;j++)<span class="hljs-comment">//在剩余未排序序列中，选出剩余未排序序列的最大值</span>            &#123;                <span class="hljs-keyword">if</span>(nums[j]&gt;res)                &#123;                    res=nums[j];                    index=j;                &#125;            &#125;            swap(nums,index,len-<span class="hljs-number">1</span>-i);        &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">     </span>&#123;         <span class="hljs-keyword">int</span> temp=nums[i];         nums[i]=nums[j];         nums[j]=temp;     &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/2020/06/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序：给定数组nums，比较元素nums[i]和nums[i+1],如果nums[i+1] &lt; nums[i]就交换两者，从第一个元素开始，两两比较，这样一轮下来，最后一个元素一定是最大值，第二轮再从第一个元素开始，倒数第二个元素截止，第二轮结束后，倒数第二个元素一定是这一轮中的最大值，这样不断的把最大值选出来，放到最后的排序算法就是冒泡排序</p><p>java代码如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=nums.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;len--)<span class="hljs-comment">//剩余未排序数组的长度</span>        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len-<span class="hljs-number">1</span>-i;j++)<span class="hljs-comment">//可以进行比较的数组下标范围</span>            &#123;                <span class="hljs-keyword">if</span>(nums[j+<span class="hljs-number">1</span>]&lt;nums[j])                    swap(nums,j,j+<span class="hljs-number">1</span>);            &#125;        &#125;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">     </span>&#123;         <span class="hljs-keyword">int</span> temp=nums[i];         nums[i]=nums[j];         nums[j]=temp;     &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode114-二叉树展开为链表</title>
    <link href="/2020/06/10/LeetCode114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/06/10/LeetCode114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode114-二叉树展开为链表"><a href="#LeetCode114-二叉树展开为链表" class="headerlink" title="LeetCode114-二叉树展开为链表"></a>LeetCode114-二叉树展开为链表</h1><p>思路：二叉树转成链表，这个链表要求把左节点放到根节点后面，右节点的前面，转换过程先把右子树转成链表，再转左子树。</p><p>对于每一个节点的转换，需要记录上一次操作返回的根节点，因为当前结点的下一个结点就是上次的根节点。</p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    TreeNode prev=<span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        flatten(root.right);        flatten(root.left);        root.right=prev;        root.left=<span class="hljs-keyword">null</span>;        prev=root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode617-合并二叉树</title>
    <link href="/2020/06/10/LeetCode617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/06/10/LeetCode617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode617-合并二叉树"><a href="#LeetCode617-合并二叉树" class="headerlink" title="LeetCode617 合并二叉树"></a>LeetCode617 合并二叉树</h1><p>思路：给定两颗二叉树A和B，在A的基础上合并成一颗新树，遍历A的每一个节点。如果A和B的节点都为空，就返回空，如果A，B只有一个不为空，返回不会空的那个结点，如果两者都不为空，返回两个节点之和</p><p>代码</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode t1, TreeNode t2)</span> </span>&#123;                <span class="hljs-keyword">if</span>(t1==<span class="hljs-keyword">null</span> &amp;&amp; t2==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t1==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> t2;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t2==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> t1;        t1.val+=t2.val;        t1.left=mergeTrees(t1.left,t2.left);        t1.right=mergeTrees(t1.right,t2.right);        <span class="hljs-keyword">return</span> t1;    &#125;   &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode104-求二叉树的最大高度</title>
    <link href="/2020/06/10/LeetCode104-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/"/>
    <url>/2020/06/10/LeetCode104-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode104-求二叉树的最大高度"><a href="#LeetCode104-求二叉树的最大高度" class="headerlink" title="LeetCode104 求二叉树的最大高度"></a>LeetCode104 求二叉树的最大高度</h1><p>思路：二叉树的最大高度=max（左子树的最大高度，右子树的最大高度）+1，所以递归求解</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> dfs(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>)        &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> left=dfs(node.left);        <span class="hljs-keyword">int</span> right=dfs(node.right);        <span class="hljs-keyword">return</span> Math.max(left,right)+<span class="hljs-number">1</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode226-翻转二叉树</title>
    <link href="/2020/06/10/LeetCode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/06/10/LeetCode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode226-翻转二叉树"><a href="#LeetCode226-翻转二叉树" class="headerlink" title="LeetCode226 翻转二叉树"></a>LeetCode226 翻转二叉树</h1><p>思路：把节点放到队列，先把右子树放到节点，再把左子树放到节点，然后再生成二叉树</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        Queue&lt;TreeNode&gt; queue=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.offer(root);<span class="hljs-comment">//把根节点压入队列</span>        <span class="hljs-keyword">while</span>(!queue.isEmpty())        &#123;            TreeNode node=queue.poll();<span class="hljs-comment">//弹出队列的队首元素</span>            <span class="hljs-keyword">if</span>(node!=<span class="hljs-keyword">null</span>)<span class="hljs-comment">//依次遍历每一个节点</span>            &#123;                TreeNode left=node.left;<span class="hljs-comment">//记录节点的左节点</span>                TreeNode right=node.right;<span class="hljs-comment">//记录节点的右节点</span>                queue.offer(right);<span class="hljs-comment">//先压入右节点</span>                queue.offer(left);<span class="hljs-comment">//再压入左节点</span>                node.left=right;<span class="hljs-comment">//把节点的左右指向交换</span>                node.right=left;            &#125;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode654-最大二叉树</title>
    <link href="/2020/06/10/LeetCode654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/06/10/LeetCode654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode654-最大二叉树"><a href="#LeetCode654-最大二叉树" class="headerlink" title="LeetCode654 最大二叉树"></a>LeetCode654 最大二叉树</h1><p>题目：</p><pre><code class="hljs java">给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：二叉树的根是数组中的最大元素。左子树是通过数组中最大值左边部分构造出的最大二叉树。右子树是通过数组中最大值右边部分构造出的最大二叉树。通过给定的数组构建最大二叉树，并且输出这个树的根节点。</code></pre><p>思路：分治递归，先找到数组中元素的最大值，然后分成左右两部分，左边是左子树，右边是右子树，对于每一个子树，再进行分治递归</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">return</span> dfs(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>);            &#125;    <span class="hljs-function">TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(end&lt;start) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> index=start;        <span class="hljs-keyword">int</span> maxValue=nums[index];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start+<span class="hljs-number">1</span>;i&lt;=end;i++)        &#123;            <span class="hljs-keyword">if</span>(nums[i]&gt;maxValue)            &#123;                index=i;                maxValue=nums[index];            &#125;        &#125;        TreeNode node=<span class="hljs-keyword">new</span> TreeNode(nums[index]);        node.left=dfs(nums,start,index-<span class="hljs-number">1</span>);        node.right=dfs(nums,index+<span class="hljs-number">1</span>,end);        <span class="hljs-keyword">return</span> node;    &#125;        &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode101-判断二叉树是否对称</title>
    <link href="/2020/06/10/LeetCode101-%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0/"/>
    <url>/2020/06/10/LeetCode101-%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode101-判断二叉树是否对称"><a href="#LeetCode101-判断二叉树是否对称" class="headerlink" title="LeetCode101 判断二叉树是否对称"></a>LeetCode101 判断二叉树是否对称</h1><p>思路：二叉树对称指的是，要求每一个节点Node的左右子树要对称，而且左右子树的左右子树也要对称，即</p><pre><code class="hljs java">Node.left=Node.right;left.left=right.left;left.right=right.left;具体看下图</code></pre><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200610120726.png" srcset="/img/loading.gif" alt="image-20200610120720720"></p><p>递归求解每一个节点，如果有一个节点不满足上述条件，即返回true，这个二叉树不是对称二叉树</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> dfs(root.left,root.right);    &#125;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode left, TreeNode right)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(left==<span class="hljs-keyword">null</span> &amp;&amp; right==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(left ==<span class="hljs-keyword">null</span> || right ==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(left.val!=right.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> dfs(left.left,right.right) &amp;&amp; dfs(left.right,right.left);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode102-二叉树层序遍历</title>
    <link href="/2020/06/10/LeetCode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/06/10/LeetCode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-二叉树层序遍历"><a href="#LeetCode-二叉树层序遍历" class="headerlink" title="LeetCode 二叉树层序遍历"></a>LeetCode 二叉树层序遍历</h1><p>思路：用队列实现，把每一个节点都放到队列中去，遍历队列中每一个节点，把每一个节点的左右子树都加入到队列，然后再把这个结点出队，依次遍历直到队列为空</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; res=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;        Queue&lt;TreeNode&gt; queue=<span class="hljs-keyword">new</span> LinkedList();        queue.offer(root);        <span class="hljs-keyword">while</span>(!queue.isEmpty())        &#123;            <span class="hljs-keyword">int</span> size=queue.size();            List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)            &#123;                TreeNode node=queue.poll();                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-keyword">null</span>) queue.offer(node.left);                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-keyword">null</span>) queue.offer(node.right);                list.add(node.val);            &#125;            res.add(<span class="hljs-number">0</span>,list);        &#125;                <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode144-二叉树前序遍历</title>
    <link href="/2020/06/10/LeetCode144-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/06/10/LeetCode144-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode144-二叉树前序遍历"><a href="#LeetCode144-二叉树前序遍历" class="headerlink" title="LeetCode144 二叉树前序遍历"></a>LeetCode144 二叉树前序遍历</h1><p>套用模板即可</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; list;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        dfs(root);        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        list.add(node.val);        dfs(node.left);        dfs(node.right);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode94-二叉树中序遍历</title>
    <link href="/2020/06/10/LeetCode94-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/06/10/LeetCode94-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode94-二叉树中序遍历"><a href="#LeetCode94-二叉树中序遍历" class="headerlink" title="LeetCode94 二叉树中序遍历"></a>LeetCode94 二叉树中序遍历</h1><p>套用模板，递归求解</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; list;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        dfs(root);        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        dfs(node.left);        list.add(node.val);        dfs(node.right);    &#125;        &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode145-二叉树后序遍历</title>
    <link href="/2020/06/10/LeetCode145-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/06/10/LeetCode145-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode145-二叉树后续遍历"><a href="#LeetCode145-二叉树后续遍历" class="headerlink" title="LeetCode145 二叉树后续遍历"></a>LeetCode145 二叉树后续遍历</h1><p>后续遍历的顺序是：左节点–&gt;右节点–&gt;根节点，根节点最后一个遍历，套用一下模板即可</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; list;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        dfs(root);        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        dfs(node.left);        dfs(node.right);        list.add(node.val);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树遍历模板</title>
    <link href="/2020/06/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/"/>
    <url>/2020/06/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树遍历模板"><a href="#二叉树遍历模板" class="headerlink" title="二叉树遍历模板"></a>二叉树遍历模板</h1><p>模板来源于@labuladong</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-comment">// 前序遍历</span>    traverse(root.left)    <span class="hljs-comment">// 中序遍历</span>    traverse(root.right)    <span class="hljs-comment">// 后序遍历</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode106-从中序和后序遍历序列中构建二叉树</title>
    <link href="/2020/06/10/LeetCode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/06/10/LeetCode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode106-从中序和后序遍历序列中构建二叉树"><a href="#LeetCode106-从中序和后序遍历序列中构建二叉树" class="headerlink" title="LeetCode106 从中序和后序遍历序列中构建二叉树"></a>LeetCode106 从中序和后序遍历序列中构建二叉树</h1><p>先从后序遍历中得到根节点，得到根节点在中序遍历中的位置index，中序遍历序列中index左边的就是左子树，右边的就是右子树，然后递归求解左右子树即可<br><strong>难点</strong>：如何计算下一次后序遍历左子树根节点的位置（后序遍历根节点的下标-中序遍历根节点右边的子节点数量=下一次迭代的后序遍历根节点位置）<br>中序+后序构建二叉树：难点是计算左子树的位置。因为后序根节点的位置-1就是右子树的位置<br>中序+先序构建二叉树：难点是计算右子树的位置，因为先序根节点的位置+1就是左子树的位置。<br>当然这两种情况都要判断边界</p><p>java代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;        HashMap&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">int</span> length=postorder.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)        &#123;            map.put(inorder[i],i);        &#125;        <span class="hljs-keyword">return</span> help(inorder,postorder,<span class="hljs-number">0</span>,length-<span class="hljs-number">1</span>,length-<span class="hljs-number">1</span>,map);    &#125;    <span class="hljs-function">TreeNode <span class="hljs-title">help</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder, <span class="hljs-keyword">int</span> inStart, <span class="hljs-keyword">int</span> inEnd, <span class="hljs-keyword">int</span> postEnd, HashMap&lt;Integer,Integer&gt; map)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(postEnd&lt;<span class="hljs-number">0</span> || inStart&gt;inEnd) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> index=map.get(postorder[postEnd]);        TreeNode node=<span class="hljs-keyword">new</span> TreeNode(postorder[postEnd]);        node.left=help(inorder,postorder,inStart,index-<span class="hljs-number">1</span>,postEnd-(inEnd-index)-<span class="hljs-number">1</span>,map);        node.right=help(inorder,postorder,index+<span class="hljs-number">1</span>,inEnd,postEnd-<span class="hljs-number">1</span>,map);        <span class="hljs-keyword">return</span> node;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode105-从前序和中序遍历序列中构建二叉树</title>
    <link href="/2020/06/10/LeetCode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/06/10/LeetCode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode105-从前序和中序遍历中构建二叉树"><a href="#LeetCode105-从前序和中序遍历中构建二叉树" class="headerlink" title="LeetCode105 从前序和中序遍历中构建二叉树"></a>LeetCode105 从前序和中序遍历中构建二叉树</h1><p>前序遍历的顺序是：根结点–&gt;左节点–&gt;右节点</p><p>中序遍历的顺序是：左节点–&gt;根节点–&gt;右节点</p><p>后序遍历的顺序是：左节点–&gt;右节点–&gt;根节点</p><p>构建二叉树的核心是先确定根节点，题目给了前序遍历和中序遍历，想到前序遍历的第一个节点是根节点，所以可以从前序遍历中确认根节点root，然后去中序遍历中找到根节点的位置index，那么在中序遍历index左边的就是左子树，右边的就是右子树，然后再递归求解左右子树，便可成功构建二叉树</p><p>Java代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;        HashMap&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">int</span> length=postorder.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)        &#123;            map.put(inorder[i],i);        &#125;        <span class="hljs-keyword">return</span> help(inorder,postorder,<span class="hljs-number">0</span>,length-<span class="hljs-number">1</span>,length-<span class="hljs-number">1</span>,map);    &#125;    <span class="hljs-function">TreeNode <span class="hljs-title">help</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder, <span class="hljs-keyword">int</span> inStart, <span class="hljs-keyword">int</span> inEnd, <span class="hljs-keyword">int</span> postEnd, HashMap&lt;Integer,Integer&gt; map)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(postEnd&lt;<span class="hljs-number">0</span> || inStart&gt;inEnd) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> index=map.get(postorder[postEnd]);        TreeNode node=<span class="hljs-keyword">new</span> TreeNode(postorder[postEnd]);        node.left=help(inorder,postorder,inStart,index-<span class="hljs-number">1</span>,postEnd-(inEnd-index)-<span class="hljs-number">1</span>,map);        node.right=help(inorder,postorder,index+<span class="hljs-number">1</span>,inEnd,postEnd-<span class="hljs-number">1</span>,map);        <span class="hljs-keyword">return</span> node;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习-1</title>
    <link href="/2020/06/10/Spring%E5%AD%A6%E4%B9%A0-1/"/>
    <url>/2020/06/10/Spring%E5%AD%A6%E4%B9%A0-1/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring学习心得-01"><a href="#Spring学习心得-01" class="headerlink" title="Spring学习心得-01"></a>Spring学习心得-01</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>Spring的核心是IOC和AOP，IOC（Inversion of Control）中文是控制反转。</p><p>了解IOC前要先知道<strong>依赖倒置原则</strong>（Dependency Inversion Principle），即</p><blockquote><p>高层模块不应该依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象</p></blockquote><p>举例来形容一下什么是依赖倒置原则：假设我们要盖楼，先设计好房间，在设计好楼层，再设计好大楼结构。这里的依赖关系是：大楼依赖楼层、楼层依赖房间。假如业主对房间不满意，我们需要修改房间，那就需要修改楼层，修改完楼层，大楼结构也就需要修改。</p><p>那假如反一下呢？</p><p>我先设计好大楼结构，再去设计楼层，然后去设计房间。如果业主对房间不满意，那我只需要修改房间就可以。这样一来，依赖关系就倒置过来了：房间依赖楼层，楼层依赖大楼。这就是依赖倒置原则，把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。</p><p>IOC就是采用了依赖注入（<strong>Dependency Injection</strong>）来实现了依赖倒置原则。</p><p><strong>依赖注入</strong></p><blockquote><p>组件之间依赖关系由<strong>容器在运行期决定,</strong>即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台</p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200610103441.png" srcset="/img/loading.gif" alt="image-20200603115013451"></p><blockquote><p><strong>谁依赖于谁：</strong>当然是应用程序依赖于IoC容器，依赖是指容器负责创建Bean并管理Bean的生命周期；（当类与类之间有使用关系时就属于依赖关系）</p><p><strong>为什么需要依赖：</strong>应用程序需要IoC容器来提供对象需要的外部资源；</p><p><strong>谁注入谁：</strong>容器负责注入Bean的依赖资源，依赖资源可以是Bean、外部文件、常量数据等，在Java中都反映为对象，并且由容器负责组装Bean之间的依赖关系；</p><p><strong>此处的依赖是指**</strong>Bean<strong>**之间的依赖关系</strong>，<strong>可以认为是传统类与类之间的“关联”、“聚合”、“组合”关系</strong>。</p><p>为什么要应用依赖注入？</p><p> <strong>动态替换Bean</strong>依赖对象，程序更灵活：替换Bean依赖对象，无需修改源文件：应用依赖注入后，由于可以采用配置文件方式实现，从而能随时动态的替换Bean的依赖对象，无需修改java源文件；</p><p><strong>更好实践面向接口编程，代码更清晰：</strong>在Bean中只需指定依赖对象的接口，接口定义依赖对象完成的功能，通过容器注入依赖实现；</p><p><strong>更好实践优先使用对象组合，而不是类继承：</strong>因为IoC容器采用注入依赖，也就是<strong>组合对象</strong>，从而更好的实践对象组合。</p><p> 对象组合：Bean的功能由几个依赖Bean功能组合而成，组合具有动态性，可以方便的替换掉依赖Bean，从而改变Bean功能，而且增加了代码的复用性，降低了耦合性</p><p>来自参考资料1</p></blockquote><p>所以IOC就是不需要程序员自己去创建和维护对象，把创建对象的权利交给Spring，由Spring来管理维护对象。</p><p>控制反转这个词再细说一下：</p><p>控制：传统的Java开发都是程序员自己去new对象，程序员控制对象的创建，而IOC是由IOC容器去创建对象，由IOC控制对象的创建，IOC控制了外部资源的获取。</p><p>反转：一般的开发是程序员自己去获取依赖对象，而IOC是由容器来查找并注入依赖对象，对象只是被动的接受依赖对象</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603143635.png" srcset="/img/loading.gif" alt=""></p><p>IOC出现后：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603143654.png" srcset="/img/loading.gif" alt="image-20200603143649919"></p><blockquote><p><strong>谁控制谁，控制什么：</strong>传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</p><p><strong>为何是反转，哪些方面反转了：</strong>有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。（来自参考资料1）</p></blockquote><p>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603113111.jpg" srcset="/img/loading.gif" alt="img"></p><h4 id="依赖资源注入方式"><a href="#依赖资源注入方式" class="headerlink" title="依赖资源注入方式"></a>依赖资源注入方式</h4><p>依赖：bean对象的创建依赖于容器</p><p>注入：bean对象中的所有属性，由容器来注入</p><p>xml文件的基本约束代码</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">&gt;</span>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;xsi:schemaLocation="http://www.springframework.org/schema/beans  https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>   <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>  <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-comment">&lt;!-- more bean definitions go here --&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></blockquote><h5 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h5><p>容器实例化Bean时注入那些依赖，通过在在Bean定义中指定构造器参数进行注入依赖，构造器参数就是依赖。</p><p>注入方式：构造器方式、静态工厂、实例工厂</p><p>构造器注入(代码来自参考资料1)：</p><blockquote><p>1 根据参数索引注入</p><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello"</span> /&gt;</span>&gt;索引下标从0开始</code></pre><p>2 根据参数类型注入</p><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"java.lang.String"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello"</span> /&gt;</span>&gt;参数类型必须是全限定类名</code></pre><p>3 根据参数名称注入</p><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"15"</span> /&gt;</span>&gt;name表示需要匹配的参数名字</code></pre><p>使用方式：生成IOC容器，调用容器的getBean(下标/参数类型/参数名称,字节码)</p></blockquote><p>静态工厂注入</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byIndex"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定类名"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byType"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定类名"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"java.lang.String"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"2"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byName"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定类名"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"index"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>实例工厂注入</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"instanceFactory"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定类名"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byIndex"</span>  <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"instanceFactory"</span>  <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byType"</span>  <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"instanceFactory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"java.lang.String"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"2"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byName"</span>  <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"instanceFactory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"index"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注：静态工厂方式和实例工厂方式根据参数名字注入的方式只支持通过在class文件中添加“变量调试信息”方式才能运行，ConstructorProperties注解方式不能工作，它只对构造器方式起作用，<strong>不建议使用根据参数名进行构造器注入</strong>。</p><h5 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h5><p>setter注入，是通过在通过构造器、静态工厂或实例工厂实例好Bean后，通过调用Bean类的setter方法进行注入依赖，原类中要有getter()和setter()方法</p><p>setter注入方式</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"XX"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"要注入的值"</span>&gt;</span> 使用property标签，setXX(),name那里填写XX。如setName,那里就写Name&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"XX"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanid"</span>&gt;</span>：注入引用类型</code></pre><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.javass.spring.chapter3.HelloImpl4"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"index"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注入常量</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello"</span>/&gt;</span></code></pre></blockquote><p>JavaBean本质就是一个POJO类，该类有以下限制：</p><blockquote><p><strong>有公共的无参构造器</strong></p><p><strong>属性为private访问级别</strong></p><p><strong>有getter和setter方法</strong></p></blockquote><h5 id="注入集合、数组和Map"><a href="#注入集合、数组和Map" class="headerlink" title="注入集合、数组和Map"></a>注入集合、数组和Map</h5><p>注入集合（List，Set）</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--注入List，使用list标签--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"listBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定名"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据名称来决定注入类中哪个list--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">list</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">"java.lang.String"</span>&gt;</span>  <span class="hljs-comment">&lt;!--value-type是list集合内的元素类型，默认是String，格式是全限定名--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--注入set，使用set标签--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"setBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定名"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据名称来决定注入类中哪个set--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">"java.lang.String"</span>&gt;</span>  <span class="hljs-comment">&lt;!--value-type是set集合内的元素类型，默认是String，格式是全限定名--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注入数组</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--使用array标签--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"arrayBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定名"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据名称来决定注入类中哪个array--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">array</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">"java.lang.String"</span>&gt;</span>  <span class="hljs-comment">&lt;!--value-type是set集合内的元素类型，默认是String，格式是全限定名--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注入Map</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--使用map标签--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"arrayBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定名"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据名称来决定注入类中哪个Map--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">key-type</span>=<span class="hljs-string">"全限定名"</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">"全限定名"</span>&gt;</span><span class="hljs-comment">&lt;!--默认是String类型--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">""</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">""</span>/&gt;</span><span class="hljs-comment">&lt;!--key和value是你想注入的键值对--&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注入Properties</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--使用props标签，注入java.util.Properties类型数据，键和值必须都是Srring类型数据--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"arrayBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定名"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据名称来决定注入中哪个Properties--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">props</span> <span class="hljs-attr">key-type</span>=<span class="hljs-string">"全限定名"</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">"全限定名"</span>&gt;</span><span class="hljs-comment">&lt;!--String类型--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">""</span>&gt;</span>"value值"<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注入空值</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">""</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre></blockquote><p>注入其他Bean</p><blockquote><p>构造器注入</p><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--使用constructor-arg标签的ref属性来引用其他Bean--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">""</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanid"</span>/&gt;</span>&gt;<span class="hljs-comment">&lt;!--使用constructor-arg标签的子&lt;ref&gt;标签来引用其他Bean--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">""</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"beanid"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span></code></pre><p><strong>setter</strong>注入</p><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--第一种方式--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanid"</span>/&gt;</span>&gt;<span class="hljs-comment">&lt;!--第二种方式--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"beanid"</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre></blockquote><h5 id="P命名空间注入"><a href="#P命名空间注入" class="headerlink" title="P命名空间注入"></a><strong>P命名空间注入</strong></h5><blockquote><p>P就是propertity的缩写</p><p>P命名空间对应所有的属性注入</p><p>添加配置文件约束代码：xmlns:p=”<a href="http://www.springframework.org/schema/p&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/p&quot;</a></p><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"p-namespace"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.ExampleBean"</span></span><span class="hljs-tag">  <span class="hljs-attr">p:email</span>=<span class="hljs-string">"someone@somewhere.com"</span>/&gt;</span></code></pre></blockquote><h5 id="C命名空间注入"><a href="#C命名空间注入" class="headerlink" title="C命名空间注入"></a><strong>C命名空间注入</strong></h5><blockquote><p>c：就是constrctor-arg的缩写</p><p>c命名空间对应构造器注入</p><p>添加约束代码：xmlns:c=”<a href="http://www.springframework.org/schema/c&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/c&quot;</a></p><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--原来是这样实现构造器注入--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingOne"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"thingTwo"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanTwo"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"thingThree"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanThree"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"email"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"something@somewhere.com"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-comment">&lt;!--c命名空间出来以后是这样实现的--&gt;</span>&gt;<span class="hljs-comment">&lt;!-- c-namespace declaration with argument names --&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingOne"</span> <span class="hljs-attr">c:thingTwo-ref</span>=<span class="hljs-string">"beanTwo"</span></span><span class="hljs-tag">  <span class="hljs-attr">c:thingThree-ref</span>=<span class="hljs-string">"beanThree"</span> <span class="hljs-attr">c:email</span>=<span class="hljs-string">"something@somewhere.com"</span>/&gt;</span></code></pre></blockquote><p>内部Bean</p><blockquote><p>内部Bean就是在<property>或<constructor-arg>内通过<bean>标签定义的Bean，该Bean不管是否指定id或name，该Bean都会有唯一的匿名标识符，而且不能指定别名，该内部Bean对其他外部Bean不可见</p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603113111.jpg" srcset="/img/loading.gif" alt="img"></p><h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><blockquote><p>Spring提供“singleton”和“prototype”两种基本作用域，另外提供“request”、“session”、“global session”三种web作用域；</p></blockquote><p><strong>singleton</strong>（默认）</p><blockquote><p>指“singleton”作用域的Bean只会在每个Spring IoC容器中存在一个实例，而且其完整生命周期完全由Spring容器管理。对于所有获取该Bean的操作Spring容器将只返回同一个Bean。</p><p>Spring是注册表单例设计模式的实现，消除了编程式单例，而且对代码是非入侵式。</p><p>Spring不仅会缓存单例对象，Bean定义也是会缓存的，对于惰性初始化的对象是在首次使用时根据Bean定义创建并存放于单例缓存池。</p><p>注册表单例设计模式：先将需要单例的实例通过唯一键注册到注册表，然后通过键来获取单例</p></blockquote><p><strong>prototype</strong></p><blockquote><p>原型，指每次向Spring容器请求获取Bean都返回一个全新的Bean，相对于“singleton”来说就是不缓存Bean，每次都是一个根据Bean定义创建的全新Bean。</p><p>Spring不会缓存原型对象，而是根据Bean定义每次请求返回一个全新的Bean：</p><p>Spring中的原型和GoF中介绍的原型含义是不一样的：</p><p>GoF通过用原型实例指定创建对象的种类，而Spring容器用Bean定义指定创建对象的种类；</p><p>GoF通过拷贝这些原型创建新的对象，而Spring容器根据Bean定义创建新对象。</p><p>其相同地方都是根据某些东西创建新东西，而且GoF原型必须显示实现克隆操作，属于侵入式，而Spring容器只需配置即可，属于非侵入式。</p></blockquote><p><strong>Web应用中的作用域</strong></p><blockquote><p>在Web应用中，我们可能需要将数据存储到request、session、global session。因此Spring提供了三种Web作用域：request、session、globalSession。</p><p><strong>request</strong>作用域：表示每个请求需要容器创建一个全新Bean</p><p><strong>session</strong>作用域：表示每个会话需要容器创建一个全新Bean</p><p><strong>globalSession</strong>：类似于session作用域，只是其用于portlet环境的web应用</p></blockquote><h4 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h4><p>之前在xml中Bean的配置都是手动装配，</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cat"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>   <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">""</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"cat"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>自动装配</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">"byName"</span>&gt;</span><span class="hljs-comment">&lt;!--byName会自动查找，和自己对象set方法后面对应的bean，弊端是名字相同会报错--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">"byType"</span>&gt;</span><span class="hljs-comment">&lt;!--byName会自动查找，和自己对象属性类型相同的bean，弊端类型相同会报错--&gt;</span></code></pre><p>byName需要保证所有bean的id唯一，并且需要保证和注入的set属性的方法值相同</p><p>byType是需要保证所有bean的类型唯一，并且需要保证和注入的set属性的类型相同</p></blockquote><h4 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h4><p>使用注解需要加入一些支持</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">&gt;</span>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;xmlns:context="http://www.springframework.org/schema/context"&gt;xsi:schemaLocation="http://www.springframework.org/schema/beans  https://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  https://www.springframework.org/schema/context/spring-context.xsd"&gt;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></blockquote><p>使用了注解@Autowired：原来xml文件可以写成</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"XX"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">""</span>&gt;</span></code></pre><p>在java对应的类中加入注解@Autowired</p><p>@Autowired：可以直接在属性、set方法上使用。</p><p>使用@Autowired，可以不写set方法，@Autowired是通过byType来实现的，所以需要你这个属性在IOC容器中存在</p><p>@Autowired注解，默认是true，意思是不允许为null，如果修改为@Autowired(required=false)，意思是可以为null</p><p>如果有多个Bean对象时，Autowired通过byType都无法找到应该装配哪一个，需要搭配@Qualifier注解一起使用</p></blockquote><p>@Resource注解</p><blockquote><p>@Autowired是通过byType实现的</p><p>@Resource是通过byName/byType实现的，默认是byName，如果找不到就通过byType实现。</p><p>@Resource比@Autowired更强大</p></blockquote><p>@component注解：组件组件，搭配@V alue使用</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"XX.XX"</span>&gt;</span><span class="hljs-comment">&lt;!--意思是会扫描XX.XX包下的所有组件--&gt;</span></code></pre><p>衍生注解：@Repository，@Service，@Controller，都是组件的意思</p><p>加上这些注解就表示这个类要被spring托管了，是Spring的一个组件了</p><p>这四个注解功能都是一样的，意思都是将某个类注册到Spring容器中，然后装配</p></blockquote><p><strong>xml用来管理bean，注解负责完成属性的注入</strong></p><h4 id="使用Java配置注解开发"><a href="#使用Java配置注解开发" class="headerlink" title="使用Java配置注解开发"></a>使用Java配置注解开发</h4><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200609183446.png" srcset="/img/loading.gif" alt="image-20200609183441950"></p><blockquote><p>@Configuration：表示这个类是一个配置类</p><p>注意如果使用了配置类，那么只能通过AnnotationConfig上下文获取IOC容器</p><pre><code class="hljs java">&gt;ApplicationContext context=<span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(xx<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&gt;User getUser=(User)context.getBean(<span class="hljs-string">"getUser"</span>);&gt;sout(getUser.getName);</code></pre></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603113111.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP：Aspect Oriented Programming，面向切面编程，核心原理是使用动态代理模式在方法执行前后或者出现异常时添加相关逻辑</p><p>AOP一般被用来解决一些系统交叉业务的织入，比如日志啦、事务。</p><p>比如我想在方法1、2、3中添加一个打印日志功能，那我就需要去修改方法1、2、3中的代码，添加日志功能。但这违法了设计原则中开闭原则（扩展开发，修改关闭）。</p><p>那怎么办？简单点，写一个子类，在子类中重写这三个方法，那假如方法要是多呢？都一个个重写？</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603120706.png" srcset="/img/loading.gif" alt="image-20200603120703141"></p><p>那能不能让这些方法在执行前（或者执行后）统一调用一个代码呢？如下图</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603121316.png" srcset="/img/loading.gif" alt=""></p><p>我们原来是在方法内部添加打印日志功能，AOP是在执行方法前添加日志功能（交叉业务），原因是AOP的底层是使用了动态代理技术，动态代理调用了原方法，AOP只不过是在在原方法的基础上新创建了一个方法，然后在新方法的内部添加功能，添加的功能代码也称之为增强代码。如下图</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603121649.png" srcset="/img/loading.gif" alt="image-20200603121645266"></p><p>AOP通过动态代理实现的，动态代理是在<strong>运行期间</strong>，生成一个代理对象</p><blockquote><p>静态代理是用户自己写代理对象，比如继承一个类，重写这个类中的方法</p><p>动态代理是在程序运行期，生成一个代理对象</p></blockquote><p>Spring AOP的动态代理，有分成两种：基于接口的动态代理和基于类的动态代理</p><p>基于接口的动态代理：如果要代理的对象，继承了某个接口，那么Spring AOP就会使用JDK Proxy创建代理对象</p><p>基于类的动态代理：如果要代理的对象没有继承接口，那么Spring AOP就会使用Cglib，生成一个被代理对象的子类，作为代理</p><h4 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h4><p>Advice（通知/增强）：就是你想要新增加的功能，比如打印日志。<strong>“干什么”</strong></p><p>Aspect（切面）：切面是通知和切点的结合。<strong>”在哪干和干什么集合“</strong></p><p>Joint point（连接点）：Spring允许使用Advice的地方，比如方法的前后，抛出异常，都可以是连接点。<strong>”在哪干“</strong></p><p>Pointcut（切点）：不是类中所有的方法都需要新增加一些功能，把需要新增加功能的方法集合起来就是切点，可以理解为连接点的集合。<strong>“在哪干的集合”</strong></p><p>introduction（引入）：允许我们向现有的类添加新方法属性，就是把切面用到了目标类中。“<strong>干什么</strong>”</p><p>Target（目标对象）：引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。“<strong>对谁干</strong>”</p><p>Weaving（织入）：把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时进行织入</p><h4 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h4><blockquote><ul><li><strong>前置通知（Before Advice</strong>）:在切入点选择的连接点处的方法之前执行的通知，该通知不影响正常程序执行流程（除非该通知抛出异常，该异常将中断当前方法链的执行而返回）。</li><li><strong>后置通知（After Advice</strong>）:在切入点选择的连接点处的方法之后执行的通知，包括如下类型的后置通知：</li><li><strong>后置返回通知（After returning Advice</strong>）:在切入点选择的连接点处的方法正常执行完毕时执行的通知，必须是连接点处的方法没抛出任何异常正常返回时才调用后置通知。</li><li><strong>后置异常通知（After throwing Advice）</strong>: 在切入点选择的连接点处的方法抛出异常返回时执行的通知，必须是连接点处的方法抛出任何异常返回时才调用异常通知。</li><li><strong>后置最终通知（After finally Advice</strong>）: 在切入点选择的连接点处的方法返回时执行的通知，不管抛没抛出异常都执行，类似于Java中的finally块。</li><li><strong>环绕通知（Around Advices**</strong>）：环绕着在切入点选择的连接点处的方法所执行的通知，环绕通知可以在方法调用之前和之后自定义任何行为，并且可以决定是否执行连接点处的方法、替换返回值、抛出异常等等。</li></ul></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603185338.JPG" srcset="/img/loading.gif" alt="img"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>Spring IOC</p><p><a href="https://www.iteye.com/category/206533?page=2" target="_blank" rel="noopener">https://www.iteye.com/category/206533?page=2</a> （这个系列都是精华）</p><p>Spring AOP术语理解：<a href="https://blog.csdn.net/changudeng1992/article/details/80625134" target="_blank" rel="noopener">https://blog.csdn.net/changudeng1992/article/details/80625134</a></p>]]></content>
    
    
    <categories>
      
      <category>SSM</category>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
