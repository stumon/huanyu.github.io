<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>秒杀项目-1</title>
    <link href="/2020/06/27/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE-1/"/>
    <url>/2020/06/27/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE-1/</url>
    
    <content type="html"><![CDATA[<h1 id="秒杀项目（一）"><a href="#秒杀项目（一）" class="headerlink" title="秒杀项目（一）"></a>秒杀项目（一）</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>设计一个秒杀系统。功能：解决秒杀超卖、恶意请求、链接暴露、MD5加密用户密码、Redis缓存热点数据、资源静态化、按钮控制、限流。并对秒杀接口进行压测</p><p>流程图：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200627215023.png" srcset="/img/loading.gif" alt="秒杀流程图"></p><h2 id="2-实现登录功能"><a href="#2-实现登录功能" class="headerlink" title="2 实现登录功能"></a>2 实现登录功能</h2><h3 id="2-1-数据库设计"><a href="#2-1-数据库设计" class="headerlink" title="2.1 数据库设计"></a>2.1 数据库设计</h3><p>秒杀用户表：主要有用户id、手机号、密码、salt、头像、注册时间、最后一次登录时间、登录次数</p><p>主键是ID，对密码做了两次MD5</p><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`miaosha_user`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`miaosha_user`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'用户ID，手机号码'</span>,  <span class="hljs-string">`nickname`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`password`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'MD5(MD5(pass明文+固定salt) + salt)'</span>,  <span class="hljs-string">`salt`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`head`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'头像，云存储的ID'</span>,  <span class="hljs-string">`register_date`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'注册时间'</span>,  <span class="hljs-string">`last_login_date`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'上蔟登录时间'</span>,  <span class="hljs-string">`login_count`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'0'</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'登录次数'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">18912341246</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</code></pre><blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200625113944.png" srcset="/img/loading.gif" alt="image-20200625113939729"></p></blockquote><h3 id="2-2-明文密码两次MD5处理"><a href="#2-2-明文密码两次MD5处理" class="headerlink" title="2.2 明文密码两次MD5处理"></a>2.2 明文密码两次MD5处理</h3><p>http在网络上是以明文的形式传输的，所以用户登录时输入的密码是以明文的形式传输的，如果这个数据包在网络上被其他人劫持了，那么用户账户密码就有泄漏的风险，所以需要对用户密码做一些处理，这就是第一次MD5。</p><p>服务端在接受到传入的密码后，也不是直接把这个MD5写入到数据库的，需要生成一个随机的salt，和第一次MD5处理后的结果，做一次拼装，再做一次MD5。把第二次MD5处理后的结果和salt同时写入到数据库中。</p><p>第一次MD5：防止用户密码以明文的形式在网络上进行安全传输</p><blockquote><p>PASS=MD5(明文+固定salt)</p></blockquote><p>第二次MD5：保证数据库被盗后，用户密码不被泄漏</p><blockquote><p>PASS=MD5(用户输入+随机salt)</p></blockquote><p>引入MD5的依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-codec<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-codec<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>对明文字符串做一次MD5：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">md5</span><span class="hljs-params">(String src)</span> </span>&#123;    <span class="hljs-keyword">return</span> DigestUtils.md5Hex(src);<span class="hljs-comment">//调用已有的工具类</span>&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String salt = <span class="hljs-string">"1a2b3c4d"</span>;<span class="hljs-comment">//固定salt</span><span class="hljs-comment">//把用户输入的密码转换成MD5</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">inputPassToFormPass</span><span class="hljs-params">(String inputPass)</span> </span>&#123;    String str=<span class="hljs-string">""</span>+salt.charAt(<span class="hljs-number">0</span>)+salt.charAt(<span class="hljs-number">2</span>)+formPass+salt.charAt(<span class="hljs-number">5</span>)+salt.charAt(<span class="hljs-number">4</span>);    <span class="hljs-keyword">return</span> mdf(str);&#125;<span class="hljs-comment">//服务端接受到表单条件的密码后，再做一次MD5，就得到了数据库中的密码</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">formPassToDBPass</span><span class="hljs-params">(String formPass, String salt)</span> </span>&#123;    String str = <span class="hljs-string">""</span>+salt.charAt(<span class="hljs-number">0</span>)+salt.charAt(<span class="hljs-number">2</span>) + formPass +salt.charAt(<span class="hljs-number">5</span>) + salt.charAt(<span class="hljs-number">4</span>);    <span class="hljs-keyword">return</span> md5(str);&#125;<span class="hljs-comment">//合并上面两个方法，就得到了用户密码经过两次MD5后的密码，把这个密码和salt一起输入到数据库中</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">inputPassToDbPass</span><span class="hljs-params">(String inputPass, String saltDB)</span> </span>&#123;    String formPass = inputPassToFormPass(inputPass);    String dbPass = formPassToDBPass(formPass, saltDB);    <span class="hljs-keyword">return</span> dbPass;&#125;</code></pre><h3 id="2-3-JSR303参数校验-全局异常处理器"><a href="#2-3-JSR303参数校验-全局异常处理器" class="headerlink" title="2.3 JSR303参数校验+全局异常处理器"></a>2.3 JSR303参数校验+全局异常处理器</h3><h3 id="实现登录功能"><a href="#实现登录功能" class="headerlink" title="实现登录功能"></a>实现登录功能</h3><p>前端：form表单</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loginForm"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"loginForm"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>  <span class="hljs-attr">style</span>=<span class="hljs-string">"width:50%; margin:0 auto"</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align:center; margin-bottom: 20px"</span>&gt;</span>用户登录<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-group"</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-label col-md-4"</span>&gt;</span>请输入手机号码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-5"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mobile"</span> <span class="hljs-attr">name</span> = <span class="hljs-string">"mobile"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"手机号码"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span>  <span class="hljs-attr">minlength</span>=<span class="hljs-string">"11"</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">"11"</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-1"</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-group"</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-label col-md-4"</span>&gt;</span>请输入密码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-5"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span>  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"密码"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">minlength</span>=<span class="hljs-string">"6"</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">"16"</span> /&gt;</span>                   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>                 <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-5"</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary btn-block"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"reset"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"reset()"</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-5"</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary btn-block"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"login()"</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><p>点击登录按钮后，需要去验证一下这个form表单里面的东西，如果验证通过，就会去调用 doLogin();方法</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">login</span>(<span class="hljs-params"></span>)</span>&#123;    $(<span class="hljs-string">"#loginForm"</span>).validate(&#123;        submitHandler:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">form</span>)</span>&#123;             doLogin();        &#125;    &#125;);&#125;</code></pre><p>点击登录按钮后，就是ajax的一个post提交，</p><p>这里获取到form表单中提交的密码和salt，然后进行第一次MD5</p><p><code>mobile:$(&quot;#mobile&quot;).val()</code>：这个是手机号<br><code>password: password</code>：这个是用户输入的密码进行第一次MD5加密后的加密密码</p><p>成功就进行success的一个回调，失败就进行error回调</p><p><code>g_showLoading()</code>：一个登录框，显示在加载</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doLogin</span>(<span class="hljs-params"></span>)</span>&#123;    g_showLoading();     <span class="hljs-keyword">var</span> inputPass = $(<span class="hljs-string">"#password"</span>).val();    <span class="hljs-keyword">var</span> salt = g_passsword_salt;    <span class="hljs-keyword">var</span> str = <span class="hljs-string">""</span>+salt.charAt(<span class="hljs-number">0</span>)+salt.charAt(<span class="hljs-number">2</span>) + inputPass +salt.charAt(<span class="hljs-number">5</span>) + salt.charAt(<span class="hljs-number">4</span>);    <span class="hljs-keyword">var</span> password = md5(str);     $.ajax(&#123;        url: <span class="hljs-string">"/login/do_login"</span>,        type: <span class="hljs-string">"POST"</span>,        data:&#123;            mobile:$(<span class="hljs-string">"#mobile"</span>).val(),            password: password        &#125;,        success:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;            layer.closeAll();            <span class="hljs-comment">// console.log(data);</span>            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>)&#123;                layer.msg(<span class="hljs-string">"成功"</span>);                <span class="hljs-built_in">window</span>.location.href=<span class="hljs-string">"/goods/to_list"</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                layer.msg(data.msg);            &#125;        &#125;,        error:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            layer.closeAll();            <span class="hljs-comment">// console.log(data);</span>        &#125;    &#125;);&#125;</code></pre><p>我们可以用<code>console.log(data);</code>打印一下数据，看看登录成功没有，控制台可以看到，成功打印出来用户名和密码，登录成功。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200625122106.png" srcset="/img/loading.gif" alt="image-20200625122103414"></p><p>继续完善登录，当我们收到参数之后，第一步就是要做参数校验，这里使用<code>JSR303</code>参数校验</p><p>首先引入依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>使用方法：在需要校验的参数上加一个注解@Valid，然后在需要校验的类上加注解</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/do_login"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Boolean&gt; <span class="hljs-title">doLogin</span><span class="hljs-params">(HttpServletResponse response, @Valid LoginVo loginVo)</span> </span>&#123;    log.info(loginVo.toString());    <span class="hljs-comment">//登录</span>    userService.login(response, loginVo);    <span class="hljs-keyword">return</span> Result.success(<span class="hljs-keyword">true</span>);&#125;</code></pre><p>在需要校验的类上加注解，来标注这个属性的格式，@NotNull是不为空，@IsMobile和@Length(min=32)是我们自己定义的注解</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginVo</span> </span>&#123;     <span class="hljs-meta">@NotNull</span>    <span class="hljs-meta">@IsMobile</span>    <span class="hljs-keyword">private</span> String mobile;     <span class="hljs-meta">@NotNull</span>    <span class="hljs-meta">@Length</span>(min=<span class="hljs-number">32</span>)    <span class="hljs-keyword">private</span> String password; &#125;</code></pre><p>自定义注解</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;)<span class="hljs-meta">@Retention</span>(RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-meta">@Constraint</span>(validatedBy = &#123;IsMobileValidator<span class="hljs-class">.<span class="hljs-keyword">class</span> &#125;)//看到<span class="hljs-title">validatedBy</span>后，系统会调用校验器，来进行校验</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span>  <span class="hljs-title">IsMobile</span> </span>&#123;     <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">required</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;<span class="hljs-comment">//默认必须有</span>     <span class="hljs-function">String <span class="hljs-title">message</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> "手机号码格式错误"</span>;<span class="hljs-comment">//message作用：如果校验不通过，会提示给用户的提示信息</span>     Class&lt;?&gt;[] groups() <span class="hljs-keyword">default</span> &#123; &#125;;     Class&lt;? extends Payload&gt;[] payload() <span class="hljs-keyword">default</span> &#123; &#125;;&#125;</code></pre><p>定义校验器，校验器必须继承ConstraintValidator，它有两个参数，第一个数注解的类型，第二个是修饰字段的类型，就是校验参数的类型</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IsMobileValidator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ConstraintValidator</span>&lt;<span class="hljs-title">IsMobile</span>, <span class="hljs-title">String</span>&gt; </span>&#123;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> required = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//required是注解是否为空，required=true，是不可以为空，false是可以为空</span>    <span class="hljs-comment">//初始化方法，拿到注解</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(IsMobile constraintAnnotation)</span> </span>&#123;        required = constraintAnnotation.required();    &#125;    <span class="hljs-comment">//判断参数是否合法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String value, ConstraintValidatorContext context)</span> </span>&#123;        <span class="hljs-keyword">if</span>(required) &#123;<span class="hljs-comment">//如果参数不可以为空，就判断是否合法</span>            <span class="hljs-keyword">return</span> ValidatorUtil.isMobile(value);        &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果参数可以为空</span>            <span class="hljs-keyword">if</span>(StringUtils.isEmpty(value)) &#123;<span class="hljs-comment">//如果参数为空，就合法</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果参数不为空，就判断参数是否合法</span>                <span class="hljs-keyword">return</span> ValidatorUtil.isMobile(value);            &#125;        &#125;    &#125;&#125;</code></pre><p>验证参数是否合法</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValidatorUtil</span> </span>&#123;    <span class="hljs-comment">//手机正则表达式，要求以1开头，长度为11位的数字</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Pattern mobile_pattern = Pattern.compile(<span class="hljs-string">"1\\d&#123;10&#125;"</span>);     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMobile</span><span class="hljs-params">(String src)</span> </span>&#123;        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(src)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        Matcher m = mobile_pattern.matcher(src);        <span class="hljs-keyword">return</span> m.matches();    &#125;&#125;</code></pre><p>全局异常拦截器：拦截异常、输出信息</p><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionHandler</span> </span>&#123;    <span class="hljs-meta">@ExceptionHandler</span>(value=Exception<span class="hljs-class">.<span class="hljs-keyword">class</span>)//想拦截所有异常，所以用<span class="hljs-title">Exception</span>.<span class="hljs-title">class</span></span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">Result</span>&lt;<span class="hljs-title">String</span>&gt; <span class="hljs-title">exceptionHandler</span>(<span class="hljs-title">HttpServletRequest</span> <span class="hljs-title">request</span>, <span class="hljs-title">Exception</span> <span class="hljs-title">e</span>)</span>&#123;        e.printStackTrace();        <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> GlobalException) &#123;            GlobalException ex = (GlobalException)e;            <span class="hljs-keyword">return</span> Result.error(ex.getCm());        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> BindException) &#123;<span class="hljs-comment">//如果这个异常是绑定异常</span>            BindException ex = (BindException)e;            List&lt;ObjectError&gt; errors = ex.getAllErrors();<span class="hljs-comment">//得到异常列表，有很多异常，这里只取第一个</span>            ObjectError error = errors.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//只取第一个异常</span>            String msg = error.getDefaultMessage();<span class="hljs-comment">//拿到异常后，从异常中得到一次信息</span>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.BIND_ERROR.fillArgs(msg));        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> Result.error(CodeMsg.SERVER_ERROR);<span class="hljs-comment">//如果不是绑定异常，就输出一个通用异常</span>        &#125;    &#125;&#125;</code></pre><p>小结一下：登录时，如果出现异常就往外抛出，异常拦截器拦截异常，然后返回给用户提示信息</p><h3 id="2-4-分布式session"><a href="#2-4-分布式session" class="headerlink" title="2.4 分布式session"></a>2.4 分布式session</h3><p>用redis管理session</p><p>登录成功后，给用户生成一个token，用来标识用户，将这个token写到cookie中，传到客户端，客户端在随后的访问中，都在cookie中上传这个token，服务端拿到cookie中，从cookie中去到token，根据这个token取用户对应的session信息。</p><p>使用UUID来生成一个token</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UUIDUtil</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">uuid</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> UUID.randomUUID().toString().replace(<span class="hljs-string">"-"</span>, <span class="hljs-string">""</span>);    &#125;&#125;</code></pre><p>再把token写到cookie之前，我们要先标识一下这个token对应哪个用户，所以我们需要把用户信息写到redis中。这里是把session信息存到第三方缓存中</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String COOKI_NAME_TOKEN = <span class="hljs-string">"token"</span>; <span class="hljs-meta">@Autowired</span>RedisService redisService; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(HttpServletResponse response, LoginVo loginVo)</span> </span>&#123;    <span class="hljs-keyword">if</span>(loginVo == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GlobalException(CodeMsg.SERVER_ERROR);    &#125;    String mobile = loginVo.getMobile();    String formPass = loginVo.getPassword();    <span class="hljs-comment">//判断手机号是否存在</span>    MiaoshaUser user = getById(Long.parseLong(mobile));    <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GlobalException(CodeMsg.MOBILE_NOT_EXIST);    &#125;    <span class="hljs-comment">//验证密码</span>    String dbPass = user.getPassword();    String saltDB = user.getSalt();    String calcPass = MD5Util.formPassToDBPass(formPass, saltDB);    <span class="hljs-keyword">if</span>(!calcPass.equals(dbPass)) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GlobalException(CodeMsg.PASSWORD_ERROR);    &#125;    <span class="hljs-comment">//生成cookie</span>    String token     = UUIDUtil.uuid();    addCookie(response, token, user);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCookie</span><span class="hljs-params">(HttpServletResponse response, String token, MiaoshaUser user)</span> </span>&#123;    redisService.set(MiaoshaUserKey.token, token, user);    Cookie cookie = <span class="hljs-keyword">new</span> Cookie(COOKI_NAME_TOKEN, token);<span class="hljs-comment">//cookie传两个值，一个name，一个value</span>    cookie.setMaxAge(MiaoshaUserKey.token.expireSeconds());<span class="hljs-comment">//设置cookie的有效期为session的有效期</span>    cookie.setPath(<span class="hljs-string">"/"</span>);    response.addCookie(cookie);<span class="hljs-comment">//把cookie写入到响应中</span>&#125; <span class="hljs-comment">//MiaoshaUserKey</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiaoshaUserKey</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BasePrefix</span></span>&#123;     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TOKEN_EXPIRE = <span class="hljs-number">3600</span>*<span class="hljs-number">24</span> * <span class="hljs-number">2</span>;<span class="hljs-comment">//设置有效期为两天</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MiaoshaUserKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expireSeconds, String prefix)</span> </span>&#123;        <span class="hljs-keyword">super</span>(expireSeconds, prefix);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MiaoshaUserKey token = <span class="hljs-keyword">new</span> MiaoshaUserKey(TOKEN_EXPIRE, <span class="hljs-string">"tk"</span>);&#125;</code></pre><p>这里登陆功能基本实现了，现在让登陆成功后，跳转到商品页面<code>/goods/to_list</code></p><pre><code class="hljs js">success:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;            layer.closeAll();            <span class="hljs-comment">// console.log(data);</span>            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>)&#123;                layer.msg(<span class="hljs-string">"成功"</span>);                <span class="hljs-built_in">window</span>.location.href=<span class="hljs-string">"/goods/to_list"</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                layer.msg(data.msg);            &#125;        &#125;</code></pre><p>商品页面<code>goods_list</code>代码如下：</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>商品列表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=UTF-8"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"'hello:'+$&#123;user.nickname&#125;"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>对应的Controller代码如下：负责跳转到商品页面</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/goods"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsController</span> </span>&#123;     <span class="hljs-meta">@Autowired</span>    MiaoshaUserService userService;     <span class="hljs-meta">@Autowired</span>    RedisService redisService;     <span class="hljs-comment">//跳转到商品列表页</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/to_list"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">list</span><span class="hljs-params">(Model model,MiaoshaUser user)</span> </span>&#123;        model.addAttribute(<span class="hljs-string">"user"</span>, user);        <span class="hljs-keyword">return</span> <span class="hljs-string">"goods_list"</span>;    &#125;&#125;</code></pre><p>这里的逻辑是：用户登录成功后，自动跳转到<code>/goods/to_list</code>，而后端收到这个请求后，去执行上面代码，然后<code>return &quot;goods_list&quot;;</code>，返回给前端<code>goods_list_html</code>页面。这个页面中的数据已经在方法<code>list</code>中添加进去。后续客户端发起请求时就会携带这个token，服务端就可以将这个token取出来</p><p>优化：让cookie的有效期为用户最近登录的时间+cookie的持续时间，而不是用户第一次登录的时间+cookie的持续时间</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> MiaoshaUser <span class="hljs-title">getByToken</span><span class="hljs-params">(HttpServletResponse response, String token)</span> </span>&#123;    <span class="hljs-keyword">if</span>(StringUtils.isEmpty(token)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    MiaoshaUser user = redisService.get(MiaoshaUserKey.token, token, MiaoshaUser<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">//延长有效期</span>    <span class="hljs-keyword">if</span>(user != <span class="hljs-keyword">null</span>) &#123;        addCookie(response, token, user);    &#125;    <span class="hljs-keyword">return</span> user;&#125;</code></pre><p>实现User对象注入到方法中。</p><p>思路：实现一个ArgumentResolve</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span></span>&#123;     <span class="hljs-meta">@Autowired</span>    UserArgumentResolver userArgumentResolver;     <span class="hljs-meta">@Autowired</span>    AccessInterceptor accessInterceptor;    <span class="hljs-comment">//SpringMVC的Controller可以带很多参数，比如Request、Response、Model等。这些参数值的来源就是是Spring框架调用addArgumentResolvers方法，往Controller方法里面的参数赋值</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addArgumentResolvers</span><span class="hljs-params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;        argumentResolvers.add(userArgumentResolver);<span class="hljs-comment">//添加一个argumentResolvers</span>    &#125;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;        registry.addInterceptor(accessInterceptor);    &#125; &#125;</code></pre><p>实现argumentResolvers</p><pre><code class="hljs java"> <span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserArgumentResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerMethodArgumentResolver</span> </span>&#123;     <span class="hljs-meta">@Autowired</span>    MiaoshaUserService userService;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;        Class&lt;?&gt; clazz = parameter.getParameterType();<span class="hljs-comment">//获得参数类型</span>        <span class="hljs-keyword">return</span> clazz==MiaoshaUser<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span><span class="hljs-function"><span class="hljs-params">                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;         <span class="hljs-comment">/**</span><span class="hljs-comment">         *  threadlocal 存储线程副本 保证线程不冲突</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">return</span> UserContext.getUser();<span class="hljs-comment">//后面实现了一个拦截器，在拦截器中实现参数解析，这里只需要获取即可</span>    &#125; &#125;</code></pre><h2 id="3-实现秒杀功能"><a href="#3-实现秒杀功能" class="headerlink" title="3 实现秒杀功能"></a>3 实现秒杀功能</h2><p>逻辑：用户浏览商品列表，选择商品，进入商品详情页，点击秒杀按钮，秒杀成功，进入订单详情页</p><h3 id="3-1-数据库设计"><a href="#3-1-数据库设计" class="headerlink" title="3.1 数据库设计"></a>3.1 数据库设计</h3><p>这里有四个表：商品表、订单表、秒杀商品表、秒杀订单表。如果只有商品表和订单表，后续不好维护，所以分成4个表。</p><p>商品表</p><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`goods`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`goods`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'商品ID'</span>,  <span class="hljs-string">`goods_name`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'商品名称'</span>,  <span class="hljs-string">`goods_title`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'商品标题'</span>,  <span class="hljs-string">`goods_img`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'商品的图片'</span>,  <span class="hljs-string">`goods_detail`</span> LONGTEXT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'商品的详情介绍'</span>,  <span class="hljs-string">`goods_price`</span> <span class="hljs-built_in">DECIMAL</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'0.00'</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'商品单价'</span>,  <span class="hljs-string">`goods_stock`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'0'</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'商品库存，-1表示没有限制'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> AUTO_INCREMENT=<span class="hljs-number">5</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</code></pre><p>订单表</p><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`order_info`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`order_info`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <span class="hljs-string">`user_id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'用户ID'</span>,  <span class="hljs-string">`goods_id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'商品ID'</span>,  <span class="hljs-string">`delivery_addr_id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'收获地址ID'</span>,  <span class="hljs-string">`goods_name`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'冗余过来的商品名称'</span>,  <span class="hljs-string">`goods_count`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'0'</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'商品数量'</span>,  <span class="hljs-string">`goods_price`</span> <span class="hljs-built_in">DECIMAL</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'0.00'</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'商品单价'</span>,  <span class="hljs-string">`order_channel`</span> <span class="hljs-built_in">TINYINT</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'0'</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'1pc，2android，3ios'</span>,  <span class="hljs-string">`status`</span> <span class="hljs-built_in">TINYINT</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'0'</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'订单状态，0新建未支付，1已支付，2已发货，3已收货，4已退款，5已完成'</span>,  <span class="hljs-string">`create_date`</span> DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'订单的创建时间'</span>,  <span class="hljs-string">`pay_date`</span> DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'支付时间'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> AUTO_INCREMENT=<span class="hljs-number">1565</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</code></pre><p>秒杀商品表</p><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`miaosha_goods`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`miaosha_goods`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'秒杀的商品表'</span>,  <span class="hljs-string">`goods_id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'商品Id'</span>,  <span class="hljs-string">`miaosha_price`</span> <span class="hljs-built_in">DECIMAL</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'0.00'</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'秒杀价'</span>,  <span class="hljs-string">`stock_count`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'库存数量'</span>,  <span class="hljs-string">`start_date`</span> DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'秒杀开始时间'</span>,  <span class="hljs-string">`end_date`</span> DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'秒杀结束时间'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> AUTO_INCREMENT=<span class="hljs-number">5</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</code></pre><p>秒杀订单表</p><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`miaosha_order`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`miaosha_order`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <span class="hljs-string">`user_id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'用户ID'</span>,  <span class="hljs-string">`order_id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'订单ID'</span>,  <span class="hljs-string">`goods_id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'商品ID'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),  <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-string">`u_uid_gid`</span> (<span class="hljs-string">`user_id`</span>,<span class="hljs-string">`goods_id`</span>) <span class="hljs-keyword">USING</span> BTREE) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> AUTO_INCREMENT=<span class="hljs-number">1551</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</code></pre><p>表对应的对象代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">//所有的getter和setter方法都省略</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Goods</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String goodsName;    <span class="hljs-keyword">private</span> String goodsTitle;    <span class="hljs-keyword">private</span> String goodsImg;    <span class="hljs-keyword">private</span> String goodsDetail;    <span class="hljs-keyword">private</span> Double goodsPrice;    <span class="hljs-keyword">private</span> Integer goodsStock;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiaoshaGoods</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> Long goodsId;    <span class="hljs-keyword">private</span> Integer stockCount;    <span class="hljs-keyword">private</span> Date startDate;    <span class="hljs-keyword">private</span> Date endDate;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiaoshaOrder</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> Long userId;    <span class="hljs-keyword">private</span> Long  orderId;    <span class="hljs-keyword">private</span> Long goodsId;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiaoshaUser</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String nickname;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">private</span> String salt;    <span class="hljs-keyword">private</span> String head;    <span class="hljs-keyword">private</span> Date registerDate;    <span class="hljs-keyword">private</span> Date lastLoginDate;    <span class="hljs-keyword">private</span> Integer loginCount;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderInfo</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> Long userId;    <span class="hljs-keyword">private</span> Long goodsId;    <span class="hljs-keyword">private</span> Long  deliveryAddrId;    <span class="hljs-keyword">private</span> String goodsName;    <span class="hljs-keyword">private</span> Integer goodsCount;    <span class="hljs-keyword">private</span> Double goodsPrice;    <span class="hljs-keyword">private</span> Integer orderChannel;    <span class="hljs-keyword">private</span> Integer status;    <span class="hljs-keyword">private</span> Date createDate;    <span class="hljs-keyword">private</span> Date payDate;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;&#125;</code></pre><h3 id="3-2-商品列表页"><a href="#3-2-商品列表页" class="headerlink" title="3.2 商品列表页"></a>3.2 商品列表页</h3><p><code>controller</code>层：调用具体的业务</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/goods"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsController</span> </span>&#123;     <span class="hljs-meta">@Autowired</span>    MiaoshaUserService userService;     <span class="hljs-meta">@Autowired</span>    RedisService redisService;     <span class="hljs-meta">@Autowired</span>    GoodsService goodsService;<span class="hljs-comment">//把service注入到controller</span>     <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/to_list"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">list</span><span class="hljs-params">(Model model,MiaoshaUser user)</span> </span>&#123;        model.addAttribute(<span class="hljs-string">"user"</span>, user);        <span class="hljs-comment">//查询商品列表</span>        List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();<span class="hljs-comment">//查询列表</span>        model.addAttribute(<span class="hljs-string">"goodsList"</span>, goodsList);<span class="hljs-comment">//传到页面上</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">"goods_list"</span>;<span class="hljs-comment">//进入到商品列表页面</span>    &#125;     <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/to_detail/&#123;goodsId&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">detail</span><span class="hljs-params">(Model model,MiaoshaUser user,</span></span><span class="hljs-function"><span class="hljs-params">            @PathVariable(<span class="hljs-string">"goodsId"</span>)</span><span class="hljs-keyword">long</span> goodsId) </span>&#123;        model.addAttribute(<span class="hljs-string">"user"</span>, user);         GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);        model.addAttribute(<span class="hljs-string">"goods"</span>, goods);         <span class="hljs-keyword">long</span> startAt = goods.getStartDate().getTime();        <span class="hljs-keyword">long</span> endAt = goods.getEndDate().getTime();        <span class="hljs-keyword">long</span> now = System.currentTimeMillis();         <span class="hljs-keyword">int</span> miaoshaStatus = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> remainSeconds = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(now &lt; startAt ) &#123;<span class="hljs-comment">//秒杀还没开始，倒计时</span>            miaoshaStatus = <span class="hljs-number">0</span>;            remainSeconds = (<span class="hljs-keyword">int</span>)((startAt - now )/<span class="hljs-number">1000</span>);        &#125;<span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(now &gt; endAt)&#123;<span class="hljs-comment">//秒杀已经结束</span>            miaoshaStatus = <span class="hljs-number">2</span>;            remainSeconds = -<span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//秒杀进行中</span>            miaoshaStatus = <span class="hljs-number">1</span>;            remainSeconds = <span class="hljs-number">0</span>;        &#125;        model.addAttribute(<span class="hljs-string">"miaoshaStatus"</span>, miaoshaStatus);        model.addAttribute(<span class="hljs-string">"remainSeconds"</span>, remainSeconds);        <span class="hljs-keyword">return</span> <span class="hljs-string">"goods_detail"</span>;    &#125; &#125;</code></pre><p><code>service</code>层：具体的业务</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsService</span> </span>&#123;     <span class="hljs-meta">@Autowired</span>    GoodsDao goodsDao;<span class="hljs-comment">//引入dao</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;GoodsVo&gt; <span class="hljs-title">listGoodsVo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> goodsDao.listGoodsVo();    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> GoodsVo <span class="hljs-title">getGoodsVoByGoodsId</span><span class="hljs-params">(<span class="hljs-keyword">long</span> goodsId)</span> </span>&#123;        <span class="hljs-keyword">return</span> goodsDao.getGoodsVoByGoodsId(goodsId);    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduceStock</span><span class="hljs-params">(GoodsVo goods)</span> </span>&#123;        MiaoshaGoods g = <span class="hljs-keyword">new</span> MiaoshaGoods();        g.setGoodsId(goods.getId());        goodsDao.reduceStock(g);    &#125;&#125;</code></pre><p><code>dao</code>层：从数据库中查询数据，数据设计到两个表，所以要使用联合查询</p><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GoodsDao</span> </span>&#123;    <span class="hljs-comment">//查询商品表中的所有信息、秒杀表中的商品数量、开始时间、结束时间、秒杀价格</span>    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select g.*,mg.stock_count, mg.start_date, mg.end_date,mg.miaosha_price from miaosha_goods mg left join goods g on mg.goods_id = g.id"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;GoodsVo&gt; <span class="hljs-title">listGoodsVo</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//</span>    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select g.*,mg.stock_count, mg.start_date, mg.end_date,mg.miaosha_price from miaosha_goods mg left join goods g on mg.goods_id = g.id where g.id = #&#123;goodsId&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> GoodsVo <span class="hljs-title">getGoodsVoByGoodsId</span><span class="hljs-params">(@Param(<span class="hljs-string">"goodsId"</span>)</span><span class="hljs-keyword">long</span> goodsId)</span>;     <span class="hljs-meta">@Update</span>(<span class="hljs-string">"update miaosha_goods set stock_count = stock_count - 1 where goods_id = #&#123;goodsId&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reduceStock</span><span class="hljs-params">(MiaoshaGoods g)</span></span>; &#125;</code></pre><p><code>VO</code>层：页面展示的数据由商品表和秒杀商品表的数据共同展示，所以专门再建立一个视图层对象类，将这两个类中想要查询的数据，都放到对应的VO中</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsVo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Goods</span></span>&#123;    <span class="hljs-keyword">private</span> Double miaoshaPrice;    <span class="hljs-keyword">private</span> Integer stockCount;    <span class="hljs-keyword">private</span> Date startDate;    <span class="hljs-keyword">private</span> Date endDate;&#125;</code></pre><p>对应的前端页面：<code>goods_list.html</code></p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>商品列表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=UTF-8"</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- jquery --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/js/jquery.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- bootstrap --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;/bootstrap/css/bootstrap.min.css&#125;"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/bootstrap/js/bootstrap.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- jquery-validator --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/jquery-validation/jquery.validate.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/jquery-validation/localization/messages_zh.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- layer --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/layer/layer.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- md5.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/js/md5.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- common.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/js/common.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"panel panel-default"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"panel-heading"</span>&gt;</span>秒杀商品列表<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"table"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"goodslist"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品名称<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品图片<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品原价<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>秒杀价<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>库存数量<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>详情<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>  <span class="hljs-attr">th:each</span>=<span class="hljs-string">"goods,goodsStat : $&#123;goodsList&#125;"</span>&gt;</span>  <span class="hljs-comment">&lt;!--遍历model传入的goodsList--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;goods.goodsName&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;$&#123;goods.goodsImg&#125;&#125;"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"100"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;goods.goodsPrice&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;goods.miaoshaPrice&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;goods.stockCount&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"'/goods/to_detail/'+$&#123;goods.id&#125;"</span>&gt;</span>详情<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200625161747.png" srcset="/img/loading.gif" alt="image-20200625161744031"></p><h3 id="3-3-商品详情页"><a href="#3-3-商品详情页" class="headerlink" title="3.3 商品详情页"></a>3.3 商品详情页</h3><p>跳转到具体的详情页</p><p>前端代码：<code>&lt;td&gt;&lt;a th:href=&quot;&#39;/goods/to_detail/&#39;+${goods.id}&quot;&gt;详情&lt;/a&gt;&lt;/td&gt;</code></p><p>后端代码：</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/to_detail/&#123;goodsId&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">detail</span><span class="hljs-params">(Model model,MiaoshaUser user,</span></span><span class="hljs-function"><span class="hljs-params">                     @PathVariable(<span class="hljs-string">"goodsId"</span>)</span><span class="hljs-keyword">long</span> goodsId) </span>&#123;    model.addAttribute(<span class="hljs-string">"user"</span>, user);     GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);<span class="hljs-comment">//查询goods</span>    model.addAttribute(<span class="hljs-string">"goods"</span>, goods);     <span class="hljs-keyword">long</span> startAt = goods.getStartDate().getTime();<span class="hljs-comment">//秒杀的开始时间</span>    <span class="hljs-keyword">long</span> endAt = goods.getEndDate().getTime();<span class="hljs-comment">//秒杀的结束时间</span>    <span class="hljs-keyword">long</span> now = System.currentTimeMillis();<span class="hljs-comment">//当前时间</span>     <span class="hljs-keyword">int</span> miaoshaStatus = <span class="hljs-number">0</span>;<span class="hljs-comment">//秒杀状态</span>    <span class="hljs-keyword">int</span> remainSeconds = <span class="hljs-number">0</span>;<span class="hljs-comment">//还有多少秒开始</span>    <span class="hljs-keyword">if</span>(now &lt; startAt ) &#123;<span class="hljs-comment">//如果当前时间小于秒杀开始时间，秒杀还没开始，倒计时。</span>        miaoshaStatus = <span class="hljs-number">0</span>;        remainSeconds = (<span class="hljs-keyword">int</span>)((startAt - now )/<span class="hljs-number">1000</span>);    &#125;<span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(now &gt; endAt)&#123;<span class="hljs-comment">//如果当前时间大于于秒杀结束时间，秒杀已经结束</span>        miaoshaStatus = <span class="hljs-number">2</span>;        remainSeconds = -<span class="hljs-number">1</span>;<span class="hljs-comment">//说明已经结束</span>    &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//秒杀进行中</span>        miaoshaStatus = <span class="hljs-number">1</span>;<span class="hljs-comment">//秒杀进行中的对应状态为1</span>        remainSeconds = <span class="hljs-number">0</span>;    &#125;    model.addAttribute(<span class="hljs-string">"miaoshaStatus"</span>, miaoshaStatus);    model.addAttribute(<span class="hljs-string">"remainSeconds"</span>, remainSeconds);    <span class="hljs-keyword">return</span> <span class="hljs-string">"goods_detail"</span>;&#125;</code></pre><p>前端页面：</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>商品详情<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=UTF-8"</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- jquery --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/js/jquery.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- bootstrap --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;/bootstrap/css/bootstrap.min.css&#125;"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/bootstrap/js/bootstrap.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- jquery-validator --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/jquery-validation/jquery.validate.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/jquery-validation/localization/messages_zh.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- layer --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/layer/layer.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- md5.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/js/md5.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- common.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/js/common.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"panel panel-default"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"panel-heading"</span>&gt;</span>秒杀商品详情<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"panel-body"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;user eq null&#125;"</span>&gt;</span> 您还没有登录，请登陆后再操作<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>没有收货地址的提示。。。<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"table"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"goodslist"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品名称<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"3"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;goods.goodsName&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品图片<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"3"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;$&#123;goods.goodsImg&#125;&#125;"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"200"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"200"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>秒杀开始时间<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;#dates.format(goods.startDate, 'yyyy-MM-dd HH:mm:ss')&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"miaoshaTip"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"remainSeconds"</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">"$&#123;remainSeconds&#125;"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;miaoshaStatus eq 0&#125;"</span>&gt;</span>秒杀倒计时：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"countDown"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;remainSeconds&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>秒<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;miaoshaStatus eq 1&#125;"</span>&gt;</span>秒杀进行中<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;miaoshaStatus eq 2&#125;"</span>&gt;</span>秒杀已结束<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"miaoshaForm"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/miaosha/do_miaosha"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary btn-block"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"buyButton"</span>&gt;</span>立即秒杀<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"goodsId"</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">"$&#123;goods.id&#125;"</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品原价<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"3"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;goods.goodsPrice&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>秒杀价<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"3"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;goods.miaoshaPrice&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>库存数量<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"3"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;goods.stockCount&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span>    countDown();&#125;); <span class="actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countDown</span><span class="hljs-params">()</span></span>&#123;</span><span class="javascript">    <span class="hljs-keyword">var</span> remainSeconds = $(<span class="hljs-string">"#remainSeconds"</span>).val();</span><span class="actionscript">    <span class="hljs-keyword">var</span> timeout;</span><span class="actionscript">    <span class="hljs-keyword">if</span>(remainSeconds &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//秒杀还没开始，倒计时</span></span><span class="javascript">        $(<span class="hljs-string">"#buyButton"</span>).attr(<span class="hljs-string">"disabled"</span>, <span class="hljs-literal">true</span>);</span><span class="actionscript">        timeout = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;</span><span class="javascript">            $(<span class="hljs-string">"#countDown"</span>).text(remainSeconds - <span class="hljs-number">1</span>);</span><span class="javascript">            $(<span class="hljs-string">"#remainSeconds"</span>).val(remainSeconds - <span class="hljs-number">1</span>);</span>            countDown();        &#125;,1000);<span class="actionscript">    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(remainSeconds == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//秒杀进行中</span></span><span class="javascript">        $(<span class="hljs-string">"#buyButton"</span>).attr(<span class="hljs-string">"disabled"</span>, <span class="hljs-literal">false</span>);</span>        if(timeout)&#123;            clearTimeout(timeout);        &#125;<span class="javascript">        $(<span class="hljs-string">"#miaoshaTip"</span>).html(<span class="hljs-string">"秒杀进行中"</span>);</span><span class="actionscript">    &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//秒杀已经结束</span></span><span class="javascript">        $(<span class="hljs-string">"#buyButton"</span>).attr(<span class="hljs-string">"disabled"</span>, <span class="hljs-literal">true</span>);</span><span class="javascript">        $(<span class="hljs-string">"#miaoshaTip"</span>).html(<span class="hljs-string">"秒杀已经结束"</span>);</span>    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>为了降低服务器的负载，前端做了一些<strong>优化</strong>：</p><p>秒杀<strong>还没有开始</strong>或者秒杀<strong>已经结束</strong>，那么秒杀按钮就是灰色的。只有在秒杀开始到结束那段时间，按钮才可以点击</p><pre><code class="hljs js">$(<span class="hljs-string">"#buyButton"</span>).attr(<span class="hljs-string">"disabled"</span>, <span class="hljs-literal">true</span>);</code></pre><h3 id="3-4-实现秒杀"><a href="#3-4-实现秒杀" class="headerlink" title="3.4 实现秒杀"></a>3.4 实现秒杀</h3><p>秒杀功能的实现其实很简单，就是一个form表单的提交，提交的时候传递一个参数，商品ID</p><p>前端页面</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"miaoshaForm"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/miaosha/do_miaosha"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary btn-block"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"buyButton"</span>&gt;</span>立即秒杀<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"goodsId"</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">"$&#123;goods.id&#125;"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><p>秒杀Controller：控制层从请求中拿到商品ID后，就可以查询商品</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/miaosha"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiaoshaController</span> </span>&#123;     <span class="hljs-meta">@Autowired</span>    MiaoshaUserService userService;     <span class="hljs-meta">@Autowired</span>    RedisService redisService;     <span class="hljs-meta">@Autowired</span>    GoodsService goodsService;     <span class="hljs-meta">@Autowired</span>    OrderService orderService;     <span class="hljs-meta">@Autowired</span>    MiaoshaService miaoshaService;     <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/do_miaosha"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">list</span><span class="hljs-params">(Model model,MiaoshaUser user,</span></span><span class="hljs-function"><span class="hljs-params">            @RequestParam(<span class="hljs-string">"goodsId"</span>)</span><span class="hljs-keyword">long</span> goodsId) </span>&#123;        model.addAttribute(<span class="hljs-string">"user"</span>, user);        <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//如果用户为空，那么说明此时还没有登录，就需要登录</span>            <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;        &#125;        <span class="hljs-comment">//判断库存</span>        GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);        <span class="hljs-keyword">int</span> stock = goods.getStockCount();        <span class="hljs-keyword">if</span>(stock &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果库存小于0</span>            model.addAttribute(<span class="hljs-string">"errmsg"</span>, CodeMsg.MIAO_SHA_OVER.getMsg());<span class="hljs-comment">//返回一个错误信息：提示库存不足</span>            <span class="hljs-keyword">return</span> <span class="hljs-string">"miaosha_fail"</span>;        &#125;        <span class="hljs-comment">//如果库存大于0，那么还需要判断这个用户是否已经秒杀过一次了，因为秒杀要求一个人只能秒杀一次一种类型商品。</span>        <span class="hljs-comment">//此时需要去订单表中查询，判断订单中是否有该用户的订单</span>        <span class="hljs-comment">//判断是否已经秒杀到了</span>        MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);<span class="hljs-comment">//-----------代码1</span>        <span class="hljs-keyword">if</span>(order != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//如果订单不为空，说明用户已经秒杀过了，所以返回一个提示信息，不可以重复秒杀</span>            model.addAttribute(<span class="hljs-string">"errmsg"</span>, CodeMsg.REPEATE_MIAOSHA.getMsg());            <span class="hljs-keyword">return</span> <span class="hljs-string">"miaosha_fail"</span>;        &#125;        <span class="hljs-comment">//减库存 下订单 写入秒杀订单，这三个操作必须要么全成功，要么全失败。所以做成一个事务</span>        OrderInfo orderInfo = miaoshaService.miaosha(user, goods);<span class="hljs-comment">//---------------代码2</span>        model.addAttribute(<span class="hljs-string">"orderInfo"</span>, orderInfo);<span class="hljs-comment">//把订单的信息写入到页面上</span>        model.addAttribute(<span class="hljs-string">"goods"</span>, goods);<span class="hljs-comment">//把订单的商品信息写入到页面上</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">"order_detail"</span>;    &#125;&#125;</code></pre><p>相关代码1：</p><pre><code class="hljs java"><span class="hljs-comment">//service层</span><span class="hljs-function"><span class="hljs-keyword">public</span> MiaoshaOrder <span class="hljs-title">getMiaoshaOrderByUserIdGoodsId</span><span class="hljs-params">(<span class="hljs-keyword">long</span> userId, <span class="hljs-keyword">long</span> goodsId)</span> </span>&#123;    <span class="hljs-keyword">return</span> orderDao.getMiaoshaOrderByUserIdGoodsId(userId, goodsId);&#125; <span class="hljs-comment">//dao层</span><span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from miaosha_order where user_id=#&#123;userId&#125; and goods_id=#&#123;goodsId&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> MiaoshaOrder <span class="hljs-title">getMiaoshaOrderByUserIdGoodsId</span><span class="hljs-params">(@Param(<span class="hljs-string">"userId"</span>)</span><span class="hljs-keyword">long</span> userId, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"goodsId"</span>)</span><span class="hljs-keyword">long</span> goodsId)</span>;</code></pre><p>相关代码2：</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>GoodsService goodsService;<span class="hljs-comment">//引入其它的service</span> <span class="hljs-meta">@Autowired</span>OrderService orderService;<span class="hljs-comment">//引入其它的service</span> <span class="hljs-comment">//@Transactional标注这是一个事务，要么全成功，要么全失败</span><span class="hljs-meta">@Transactional</span><span class="hljs-function"><span class="hljs-keyword">public</span> OrderInfo <span class="hljs-title">miaosha</span><span class="hljs-params">(MiaoshaUser user, GoodsVo goods)</span> </span>&#123;    <span class="hljs-comment">//减库存 下订单 写入秒杀订单</span>    goodsService.reduceStock(goods);    <span class="hljs-comment">//写入订单信息，然后返回订单信息</span>    <span class="hljs-keyword">return</span> orderService.createOrder(user, goods);&#125; <span class="hljs-comment">//service层：调用dao层</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduceStock</span><span class="hljs-params">(GoodsVo goods)</span> </span>&#123;    MiaoshaGoods g = <span class="hljs-keyword">new</span> MiaoshaGoods();    g.setGoodsId(goods.getId());    goodsDao.reduceStock(g);&#125; <span class="hljs-comment">//dao层：去执行库存减1的操作</span><span class="hljs-meta">@Update</span>(<span class="hljs-string">"update miaosha_goods set stock_count = stock_count - 1 where goods_id = #&#123;goodsId&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reduceStock</span><span class="hljs-params">(MiaoshaGoods g)</span></span>; <span class="hljs-comment">//orderService.createOrder(user, goods);</span><span class="hljs-meta">@Transactional</span><span class="hljs-function"><span class="hljs-keyword">public</span> OrderInfo <span class="hljs-title">createOrder</span><span class="hljs-params">(MiaoshaUser user, GoodsVo goods)</span> </span>&#123;    OrderInfo orderInfo = <span class="hljs-keyword">new</span> OrderInfo();<span class="hljs-comment">//生成订单</span>    orderInfo.setCreateDate(<span class="hljs-keyword">new</span> Date());<span class="hljs-comment">//把信息注入到订单中</span>    orderInfo.setDeliveryAddrId(<span class="hljs-number">0L</span>);<span class="hljs-comment">//收货地址</span>    orderInfo.setGoodsCount(<span class="hljs-number">1</span>);<span class="hljs-comment">//商品数量，秒杀只可以秒杀一个商品</span>    orderInfo.setGoodsId(goods.getId());<span class="hljs-comment">//商品ID</span>    orderInfo.setGoodsName(goods.getGoodsName());<span class="hljs-comment">//商品名称</span>    orderInfo.setGoodsPrice(goods.getMiaoshaPrice());<span class="hljs-comment">//秒杀价格</span>    orderInfo.setOrderChannel(<span class="hljs-number">1</span>);<span class="hljs-comment">//渠道</span>    orderInfo.setStatus(<span class="hljs-number">0</span>);<span class="hljs-comment">//状态，0表示新建未支付、1表示已支付、2表示已发货、3表示已收货</span>    orderInfo.setUserId(user.getId());<span class="hljs-comment">//用户ID</span>    <span class="hljs-keyword">long</span> orderId = orderDao.insert(orderInfo);<span class="hljs-comment">//把订单信息注入到dao层，dao层再把订单信息注入到数据库</span>    MiaoshaOrder miaoshaOrder = <span class="hljs-keyword">new</span> MiaoshaOrder();<span class="hljs-comment">//秒杀订单</span>    miaoshaOrder.setGoodsId(goods.getId());<span class="hljs-comment">//把商品ID注入到秒杀订单中</span>    miaoshaOrder.setOrderId(orderId);<span class="hljs-comment">//注入订单ID</span>    miaoshaOrder.setUserId(user.getId());<span class="hljs-comment">//注入用户ID</span>    orderDao.insertMiaoshaOrder(miaoshaOrder);<span class="hljs-comment">//再把秒杀订单注入到Dao层</span>    <span class="hljs-keyword">return</span> orderInfo;<span class="hljs-comment">//返回订单</span>&#125;</code></pre><p><code>dao</code>层代码</p><pre><code class="hljs java"> <span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderDao</span> </span>&#123;     <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from miaosha_order where user_id=#&#123;userId&#125; and goods_id=#&#123;goodsId&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> MiaoshaOrder <span class="hljs-title">getMiaoshaOrderByUserIdGoodsId</span><span class="hljs-params">(@Param(<span class="hljs-string">"userId"</span>)</span><span class="hljs-keyword">long</span> userId, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"goodsId"</span>)</span><span class="hljs-keyword">long</span> goodsId)</span>;     <span class="hljs-meta">@Insert</span>(<span class="hljs-string">"insert into order_info(user_id, goods_id, goods_name, goods_count, goods_price, order_channel, status, create_date)values("</span> + <span class="hljs-string">"#&#123;userId&#125;, #&#123;goodsId&#125;, #&#123;goodsName&#125;, #&#123;goodsCount&#125;, #&#123;goodsPrice&#125;, #&#123;orderChannel&#125;,#&#123;status&#125;,#&#123;createDate&#125; )"</span>)    <span class="hljs-meta">@SelectKey</span>(keyColumn=<span class="hljs-string">"id"</span>, keyProperty=<span class="hljs-string">"id"</span>, resultType=<span class="hljs-keyword">long</span><span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">before</span></span>=<span class="hljs-keyword">false</span>, statement=<span class="hljs-string">"select last_insert_id()"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">insert</span><span class="hljs-params">(OrderInfo orderInfo)</span></span>;     <span class="hljs-meta">@Insert</span>(<span class="hljs-string">"insert into miaosha_order (user_id, goods_id, order_id)values(#&#123;userId&#125;, #&#123;goodsId&#125;, #&#123;orderId&#125;)"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insertMiaoshaOrder</span><span class="hljs-params">(MiaoshaOrder miaoshaOrder)</span></span>;  &#125;</code></pre><p>然后写页面，应该有两种情况：一种是秒杀成功、一种是秒杀失败。所以对应两种页面</p><p>秒杀失败：</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>秒杀失败<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=UTF-8"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>秒杀失败：<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;errmsg&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>秒杀成功，进入订单页</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>订单详情<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=UTF-8"</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- jquery --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/js/jquery.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- bootstrap --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;/bootstrap/css/bootstrap.min.css&#125;"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/bootstrap/js/bootstrap.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- jquery-validator --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/jquery-validation/jquery.validate.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/jquery-validation/localization/messages_zh.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- layer --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/layer/layer.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- md5.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/js/md5.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- common.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/js/common.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"panel panel-default"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"panel-heading"</span>&gt;</span>秒杀订单详情<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"table"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"goodslist"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品名称<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;goods.goodsName&#125;"</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品图片<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;$&#123;goods.goodsImg&#125;&#125;"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"200"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"200"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>订单价格<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;orderInfo.goodsPrice&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>下单时间<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;#dates.format(orderInfo.createDate, 'yyyy-MM-dd HH:mm:ss')&#125;"</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>订单状态<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;orderInfo.status eq 0&#125;"</span>&gt;</span>未支付<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;orderInfo.status eq 1&#125;"</span>&gt;</span>待发货<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;orderInfo.status eq 2&#125;"</span>&gt;</span>已发货<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;orderInfo.status eq 3&#125;"</span>&gt;</span>已收货<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;orderInfo.status eq 4&#125;"</span>&gt;</span>已退款<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;orderInfo.status eq 5&#125;"</span>&gt;</span>已完成<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary btn-block"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"payButton"</span>&gt;</span>立即支付<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>收货人<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span>XXX  18812341234<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>收货地址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span>北京市昌平区回龙观龙博一区<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="3-5-订单详情页"><a href="#3-5-订单详情页" class="headerlink" title="3.5 订单详情页"></a>3.5 订单详情页</h3><p>秒杀成功后，进入了订单详情页</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>订单详情<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=UTF-8"</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- jquery --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/js/jquery.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- bootstrap --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;/bootstrap/css/bootstrap.min.css&#125;"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/bootstrap/js/bootstrap.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- jquery-validator --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/jquery-validation/jquery.validate.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/jquery-validation/localization/messages_zh.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- layer --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/layer/layer.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- md5.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/js/md5.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- common.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/js/common.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"panel panel-default"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"panel-heading"</span>&gt;</span>秒杀订单详情<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"table"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"goodslist"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品名称<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;goods.goodsName&#125;"</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品图片<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;$&#123;goods.goodsImg&#125;&#125;"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"200"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"200"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>订单价格<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;orderInfo.goodsPrice&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>下单时间<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;#dates.format(orderInfo.createDate, 'yyyy-MM-dd HH:mm:ss')&#125;"</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>订单状态<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;orderInfo.status eq 0&#125;"</span>&gt;</span>未支付<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;orderInfo.status eq 1&#125;"</span>&gt;</span>待发货<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;orderInfo.status eq 2&#125;"</span>&gt;</span>已发货<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;orderInfo.status eq 3&#125;"</span>&gt;</span>已收货<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;orderInfo.status eq 4&#125;"</span>&gt;</span>已退款<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;orderInfo.status eq 5&#125;"</span>&gt;</span>已完成<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary btn-block"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"payButton"</span>&gt;</span>立即支付<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>收货人<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span>XXX  18812341234<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>收货地址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span>北京市昌平区回龙观龙博一区<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h2 id="4-JMeter压测"><a href="#4-JMeter压测" class="headerlink" title="4 JMeter压测"></a>4 JMeter压测</h2><h3 id="4-1-JMeter入门"><a href="#4-1-JMeter入门" class="headerlink" title="4.1 JMeter入门"></a>4.1 JMeter入门</h3><h4 id="4-1-1-压测一下http-localhost-8080-goods-to-list接口"><a href="#4-1-1-压测一下http-localhost-8080-goods-to-list接口" class="headerlink" title="4.1.1 压测一下http://localhost:8080/goods/to_list接口"></a>4.1.1 压测一下<code>http://localhost:8080/goods/to_list</code>接口</h4><p>这个接口需要查询数据库，所以性能的瓶颈就在数据库</p><p>线程数在1000左右，吞吐量最大，线程数再多时，吞吐量不会在增加，异常率会剧增</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200625183943.png" srcset="/img/loading.gif" alt="image-20200625183939791"></p><p>把数据库放到服务器上，吞吐量一下子就下去了，奇怪的是服务器负载几乎为0，没有波动。奇怪了，明明请求数不少，但是为什么服务器的<strong>CPU负载这么低</strong>呢</p><p>解决方案：服务器带宽太低</p><blockquote><p><a href="https://blog.csdn.net/mian_CSDN/article/details/78995304?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/mian_CSDN/article/details/78995304?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200625195135.png" srcset="/img/loading.gif" alt=""></p><p>可以看出硬件不同情况下的压测，两者吞吐量差距有<strong>几十倍</strong></p><h4 id="4-1-2-压测-http-localhost-8080-user-info"><a href="#4-1-2-压测-http-localhost-8080-user-info" class="headerlink" title="4.1.2 压测 http://localhost:8080/user/info"></a>4.1.2 压测 <code>http://localhost:8080/user/info</code></h4><p>不需要查询数据库，吞吐量一下子就上来了。范围大致在400~800。</p><p>这两个接口的区别就是，第一个接口不仅仅读了缓存，还读了一次数据库，而第二个接口只读了一次缓存。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200625200432.png" srcset="/img/loading.gif" alt=""></p><h3 id="4-2-自定义变量模拟多用户"><a href="#4-2-自定义变量模拟多用户" class="headerlink" title="4.2 自定义变量模拟多用户"></a>4.2 自定义变量模拟多用户</h3><p>压测redis：<code>redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000</code></p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200625201818.png" srcset="/img/loading.gif" alt="image-20200625201814849"></p><h3 id="4-3-JMeter命令行使用"><a href="#4-3-JMeter命令行使用" class="headerlink" title="4.3 JMeter命令行使用"></a>4.3 JMeter命令行使用</h3><p>步骤：</p><p>1：在windows上录好jmx</p><p>2：命令行：sh jmeter.sh -n -t XXX.jmx -l result.jtl</p><p>3：从linux中导入result.jtl到windows界面</p><p>测试的是：goods/to_list接口</p><p>5000个线程请求10次</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626095524.png" srcset="/img/loading.gif" alt="image-20200626095520409"></p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626094401.png" srcset="/img/loading.gif" alt="image-20200626094358142"></p><p>下面测试秒杀接口<code>http://localhost:8080/miaosha/do_miaosha</code></p><p>CPU负载</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626101659.png" srcset="/img/loading.gif" alt="image-20200626101655804"></p><p>可以看到，CPU没有超负荷，但是网络带宽已经达到上限，所以我们这里主要的限制就是网络带宽</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626102342.png" srcset="/img/loading.gif" alt="image-20200626102338656"></p><h2 id="5-页面优化"><a href="#5-页面优化" class="headerlink" title="5 页面优化"></a>5 页面优化</h2><h2 id="5-1-页面缓存-对象缓存"><a href="#5-1-页面缓存-对象缓存" class="headerlink" title="5.1 页面缓存+对象缓存"></a>5.1 页面缓存+对象缓存</h2><p>并发的瓶颈在数据库，所以加缓存，尽量减少对数据库的访问</p><h4 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h4><p>访问页面时，首先去缓存中取，如果没有手动渲染模板，渲染后把结果输出客户端，同时把结果缓存到redis中</p><p>渲染<code>goods_list</code>模板</p><p>先从缓存中取，如果不为空，直接返回这个页面。如果空，就手动渲染</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/to_list"</span>, produces=<span class="hljs-string">"text/html"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">list</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Model model,MiaoshaUser user)</span> </span>&#123;    model.addAttribute(<span class="hljs-string">"user"</span>, user);    <span class="hljs-comment">//取缓存，有效期为1分钟。</span>    String html = redisService.get(GoodsKey.getGoodsList, <span class="hljs-string">""</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(html)) &#123;        <span class="hljs-keyword">return</span> html;    &#125;    List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();    model.addAttribute(<span class="hljs-string">"goodsList"</span>, goodsList);    <span class="hljs-comment">//         return "goods_list";</span>    SpringWebContext ctx = <span class="hljs-keyword">new</span> SpringWebContext(request,response,                                                request.getServletContext(),request.getLocale(), model.asMap(), applicationContext );    <span class="hljs-comment">//手动渲染</span>    html = thymeleafViewResolver.getTemplateEngine().process(<span class="hljs-string">"goods_list"</span>, ctx);<span class="hljs-comment">//ctx是包含业务数据的的一个上下文</span>    <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(html)) &#123;        redisService.set(GoodsKey.getGoodsList, <span class="hljs-string">""</span>, html);    &#125;    <span class="hljs-keyword">return</span> html;&#125;</code></pre><h4 id="对象缓存"><a href="#对象缓存" class="headerlink" title="对象缓存"></a>对象缓存</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> MiaoshaUser <span class="hljs-title">getById</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id)</span> </span>&#123;    <span class="hljs-comment">//取缓存</span>    MiaoshaUser user = redisService.get(MiaoshaUserKey.getById, <span class="hljs-string">""</span>+id, MiaoshaUser<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-keyword">if</span>(user != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> user;    &#125;    <span class="hljs-comment">//取数据库</span>    user = miaoshaUserDao.getById(id);    <span class="hljs-keyword">if</span>(user != <span class="hljs-keyword">null</span>) &#123;        redisService.set(MiaoshaUserKey.getById, <span class="hljs-string">""</span>+id, user);    &#125;    <span class="hljs-keyword">return</span> user;&#125;</code></pre><h2 id="6-解决超卖"><a href="#6-解决超卖" class="headerlink" title="6 解决超卖"></a>6 <strong>解决超卖</strong></h2><p>情景1：卖出商品数目大于库存</p><p>解决方案：在数据库操作时加一个判断</p><p><code>stock_count &gt; 0</code>———&gt;只有当库存容量大于0时，才更新库存，其实就是数据库对这一行数据加了一个锁，所以不会一次只会有一个线程进来操作</p><pre><code class="hljs sql">@<span class="hljs-keyword">Update</span>(<span class="hljs-string">"update miaosha_goods set stock_count = stock_count - 1 where goods_id = #&#123;goodsId&#125; and stock_count &gt; 0"</span>)<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> reduceStock(MiaoshaGoods g);</code></pre><p>情景2：一个用户秒杀到了两个商品</p><p>秒杀流程：用户秒杀时，先判断库存、再判断是否曾经秒杀到过、没有的话，就减库存、下订单、并且写入秒杀订单</p><p>解决方案：利用数据库的唯一索引（根据用户id和商品ID），我们限制一个用户只可以秒杀一个商品，我们在写入订单时，以用户ID为唯一索引，两个订单进来后，只有一个可以成功写入到数据库。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code class="hljs xml">#thymeleafspring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.htmlspring.thymeleaf.cache=falsespring.thymeleaf.content-type=text/htmlspring.thymeleaf.enabled=truespring.thymeleaf.encoding=UTF-8spring.thymeleaf.mode=HTML5#是否开启缓存pageCache.enbale=true   #打印mybatis sqllog4j.logger.com.ibatis=DEBUGlog4j.logger.com.ibatis.common.jdbc.SimpleDataSource=DEBUGlog4j.logger.com.ibatis.common.jdbc.ScriptRunner=DEBUGlog4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUGlog4j.logger.Java.sql.Connection=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG #mybatismybatis.type-aliases-package=com.geekq.miaosha.domain#开启驼峰转换 configuration config-location 不能同時存在 如果要走流程 请 放开注释mybatis.configuration.map-underscore-to-camel-case=true#mybatis.mapperLocations = classpath:com/geekq/miaosha/dao/*.xml mybatis.mapperLocations=classpath:mybatis/mapper/*.xml#配置xml方式 因为与 mybatis.configuration.map-underscore-to-camel-case 仅用于测试#mybatis.config-location=classpath:mybatis/mybatis-config.xml #add mybatismybatis.#datasourcespring.datasource.url=jdbc:mysql://localhost:3306/miaosha?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driver#druidspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.filters=statspring.datasource.maxActive=100spring.datasource.initialSize=100spring.datasource.maxWait=600spring.datasource.minIdle=50spring.datasource.timeBetweenEvictionRunsMillis=60000spring.datasource.minEvictableIdleTimeMillis=300000spring.datasource.validationQuery=select 'x'spring.datasource.testWhileIdle=truespring.datasource.testOnBorrow=falsespring.datasource.testOnReturn=falsespring.datasource.poolPreparedStatements=truespring.datasource.maxOpenPreparedStatements=20#static,spring对静态资源的处理spring.resources.add-mappings=truespring.resources.cache-period= 3600spring.resources.chain.cache=truespring.resources.chain.enabled=truespring.resources.chain.gzipped=truespring.resources.chain.html-application-cache=truespring.resources.static-locations=classpath:/static/#redis#redis.host=127.0.0.1redis.host=39.100.103.243redis.port=6379redis.timeout=100redis.password=123456redis.poolMaxTotal=1000redis.poolMaxIdle=500redis.poolMaxWait=500#server.port=8003 #rabbitmspring.rabbitmq.host=127.0.0.1spring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.virtual-host=/spring.rabbitmq.listener.simple.concurrency= 100spring.rabbitmq.listener.simple.max-concurrency= 100spring.rabbitmq.listener.simple.prefetch= 1spring.rabbitmq.listener.simple.auto-startup=truespring.rabbitmq.listener.simple.default-requeue-rejected= truespring.rabbitmq.template.retry.enabled=truespring.rabbitmq.template.retry.initial-interval=1000spring.rabbitmq.template.retry.max-attempts=3spring.rabbitmq.template.retry.max-interval=10000spring.rabbitmq.template.retry.multiplier=1.0spring.rabbitmq.publisher-confirms=truespring.rabbitmq.listener.direct.acknowledge-mode=manualspring.rabbitmq.listener.simple.acknowledge-mode=manual ## maven隔离#spring.profiles.active=dev</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>秒杀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秒杀项目-2</title>
    <link href="/2020/06/27/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE-2/"/>
    <url>/2020/06/27/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE-2/</url>
    
    <content type="html"><![CDATA[<h1 id="秒杀项目（二）"><a href="#秒杀项目（二）" class="headerlink" title="秒杀项目（二）"></a>秒杀项目（二）</h1><h2 id="7-接口优化"><a href="#7-接口优化" class="headerlink" title="7 接口优化"></a>7 接口优化</h2><h3 id="7-1-Redis预减库存"><a href="#7-1-Redis预减库存" class="headerlink" title="7.1 Redis预减库存"></a>7.1 Redis预减库存</h3><p>目的：减少数据库访问。MySQL并发上限在几千左右。</p><p>步骤：</p><blockquote><p>系统初始化时，把商品库存加载到缓存中</p><p>收到请求后，redis预减库存，库存不足，直接返回</p><p>库存中如果大于0，把请求放入消息队列，返回状态一个派对中</p><p>请求出队，生成订单，减少库存</p><p>客户端轮询，是否秒杀成功</p></blockquote><h3 id="7-2-消息队列"><a href="#7-2-消息队列" class="headerlink" title="7.2 消息队列"></a>7.2 消息队列</h3><p>rabbitmq：四种交换机模式</p><h4 id="direct直连模式"><a href="#direct直连模式" class="headerlink" title="direct直连模式"></a>direct直连模式</h4><p>消息发送者向消息队列发送消息，消息接受者从队列中接受</p><blockquote><p>//send</p><pre><code class="hljs java">&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(Object message)</span> </span>&#123;&gt;String msg = RedisService.beanToString(message);&gt;log.info(<span class="hljs-string">"send message:"</span>+msg);&gt;amqpTemplate.convertAndSend(MQConfig.QUEUE, msg);&gt;&#125;</code></pre><p>//接受</p><pre><code class="hljs java">&gt;<span class="hljs-meta">@RabbitListener</span>(queues=MQConfig.QUEUE)&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(String message)</span> </span>&#123;&gt;log.info(<span class="hljs-string">"receive message:"</span>+message);&gt;&#125;</code></pre><p>//队列</p><pre><code class="hljs java">&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE = <span class="hljs-string">"queue"</span>;&gt;<span class="hljs-meta">@Bean</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;&gt;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(QUEUE, <span class="hljs-keyword">true</span>);&gt;&#125;</code></pre></blockquote><h4 id="topic模式"><a href="#topic模式" class="headerlink" title="topic模式"></a>topic模式</h4><blockquote><pre><code class="hljs java">&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TOPIC_QUEUE1 = <span class="hljs-string">"topic.queue1"</span>;&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TOPIC_QUEUE2 = <span class="hljs-string">"topic.queue2"</span>;&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TOPIC_EXCHANGE = <span class="hljs-string">"topicExchage"</span>;</code></pre><p>队列：</p><pre><code class="hljs java">&gt;<span class="hljs-meta">@Bean</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">topicQueue1</span><span class="hljs-params">()</span> </span>&#123;&gt;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(TOPIC_QUEUE1, <span class="hljs-keyword">true</span>);&gt;&#125;&gt;<span class="hljs-meta">@Bean</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">topicQueue2</span><span class="hljs-params">()</span> </span>&#123;&gt;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(TOPIC_QUEUE2, <span class="hljs-keyword">true</span>);&gt;&#125;</code></pre><p>交换机：</p><pre><code class="hljs java">&gt;<span class="hljs-meta">@Bean</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> TopicExchange <span class="hljs-title">topicExchage</span><span class="hljs-params">()</span></span>&#123;&gt;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TopicExchange(TOPIC_EXCHANGE);&gt;&#125;</code></pre><p>发送者，先把消息放入到Exchange中，再由Exchange放到Queue中，怎么放？</p><p>需要绑定bind到Queue上。</p><pre><code class="hljs java">&gt;<span class="hljs-meta">@Bean</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">topicBinding1</span><span class="hljs-params">()</span> </span>&#123;&gt;<span class="hljs-keyword">return</span> BindingBuilder.bind(topicQueue1()).to(topicExchage()).with(<span class="hljs-string">"topic.key1"</span>);<span class="hljs-comment">//with("Routine_KEY")</span>&gt;<span class="hljs-comment">//也就是说如果key是topic.key1时，就会绑定到topicQueue1()上</span>&gt;&#125;&gt;<span class="hljs-meta">@Bean</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">topicBinding2</span><span class="hljs-params">()</span> </span>&#123;&gt;<span class="hljs-keyword">return</span> BindingBuilder.bind(topicQueue2()).to(topicExchage()).with(<span class="hljs-string">"topic.#"</span>);&gt;<span class="hljs-comment">//如果key是topic.key1时，绑定到topicQueue2()上</span>&gt;&#125;</code></pre><p>topic模式是支持通配符的，*代表一个单词，#代表0或者多个单词</p><p>发送端：</p><pre><code class="hljs java">&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendTopic</span><span class="hljs-params">(Object message)</span> </span>&#123;&gt;String msg = RedisService.beanToString(message);&gt;log.info(<span class="hljs-string">"send topic message:"</span>+msg);&gt;amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE, <span class="hljs-string">"topic.key1"</span>, msg+<span class="hljs-string">"1"</span>);<span class="hljs-comment">//如果key是topic.key1，放到topicQueue1上</span>&gt;amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE, <span class="hljs-string">"topic.key2"</span>, msg+<span class="hljs-string">"2"</span>);<span class="hljs-comment">//如果key是topic.key2，两个队列都可以放</span>&gt;&#125;</code></pre><p>接收端：</p><p>接受从topic  queue1来的消息</p><pre><code class="hljs java">&gt;<span class="hljs-meta">@RabbitListener</span>(queues=MQConfig.TOPIC_QUEUE1)&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveTopic1</span><span class="hljs-params">(String message)</span> </span>&#123;&gt;log.info(<span class="hljs-string">" topic  queue1 message:"</span>+message);&gt;&#125;</code></pre><p>接受从topic  queue2来的消息</p><pre><code class="hljs java">&gt;<span class="hljs-meta">@RabbitListener</span>(queues=MQConfig.TOPIC_QUEUE2)&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveTopic2</span><span class="hljs-params">(String message)</span> </span>&#123;&gt;log.info(<span class="hljs-string">" topic  queue2 message:"</span>+message);&gt;&#125;</code></pre><p>小结topic模式：创建一个交换机Exchange，两个队列，把交换机和队列进行了绑定，然后发送端发送时携带key，交换机根据这个key决定发送到哪一个队列</p><p>结果</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626141526.png" srcset="/img/loading.gif" alt="image-20200626141522955"></p></blockquote><h4 id="Fanout模式：广播模式"><a href="#Fanout模式：广播模式" class="headerlink" title="Fanout模式：广播模式"></a>Fanout模式：广播模式</h4><blockquote><pre><code class="hljs java">&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FANOUT_EXCHANGE = <span class="hljs-string">"fanoutxchage"</span>;&gt;<span class="hljs-comment">/**</span><span class="hljs-comment">  * Fanout模式 交换机Exchange</span><span class="hljs-comment">  * */</span>&gt;<span class="hljs-meta">@Bean</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title">fanoutExchage</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FanoutExchange(FANOUT_EXCHANGE);&gt;&#125;&gt;<span class="hljs-meta">@Bean</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">FanoutBinding1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> BindingBuilder.bind(topicQueue1()).to(fanoutExchage());&gt;&#125;&gt;<span class="hljs-meta">@Bean</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">FanoutBinding2</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> BindingBuilder.bind(topicQueue2()).to(fanoutExchage());&gt;&#125;</code></pre><p>交换机：</p><pre><code class="hljs java">&gt;<span class="hljs-meta">@Bean</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title">fanoutExchage</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FanoutExchange(FANOUT_EXCHANGE);&gt;&#125;</code></pre><p>绑定交换机和队列，这个交换机是绑定到两个队列上的，也就是说发送端发送信息到交换机上，交换机会把消息发送给所有的队列</p><pre><code class="hljs java">&gt;<span class="hljs-meta">@Bean</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">FanoutBinding1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> BindingBuilder.bind(topicQueue1()).to(fanoutExchage());&gt;&#125;&gt;<span class="hljs-meta">@Bean</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">FanoutBinding2</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> BindingBuilder.bind(topicQueue2()).to(fanoutExchage());&gt;&#125;</code></pre><p>发送者</p><pre><code class="hljs java">&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendFanout</span><span class="hljs-params">(Object message)</span> </span>&#123; String msg = RedisService.beanToString(message); log.info(<span class="hljs-string">"send fanout message:"</span>+msg); amqpTemplate.convertAndSend(MQConfig.FANOUT_EXCHANGE, <span class="hljs-string">""</span>, msg);&gt;&#125;</code></pre><p>接受者：不需要更对队列，因为还是用的之前那个队列</p><pre><code class="hljs java">&gt;<span class="hljs-meta">@RabbitListener</span>(queues=MQConfig.TOPIC_QUEUE2)&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveTopic2</span><span class="hljs-params">(String message)</span> </span>&#123; log.info(<span class="hljs-string">" topic  queue2 receive message:"</span>+message);&gt;&#125;</code></pre><p>结果：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626143404.png" srcset="/img/loading.gif" alt="image-20200626143401282"></p></blockquote><h4 id="Headers模式"><a href="#Headers模式" class="headerlink" title="Headers模式"></a>Headers模式</h4><blockquote><p>Headers是一个键值对，可以定义成Hashtable。发送者在发送的时候定义一些键值对，接收者也可以再绑定时候传入一些键值对，两者匹配的话，则对应的队列就可以收到消息。</p><p>交换机、队列：</p><pre><code class="hljs java">&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HEADER_QUEUE = <span class="hljs-string">"header.queue"</span>;&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HEADERS_EXCHANGE = <span class="hljs-string">"headersExchage"</span>;</code></pre><p>绑定交换机和队列：</p><pre><code class="hljs java">&gt;<span class="hljs-comment">/**</span><span class="hljs-comment">&gt;* Header模式 交换机Exchange</span><span class="hljs-comment">&gt;* */</span>&gt;<span class="hljs-comment">//交换机</span>&gt;<span class="hljs-meta">@Bean</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> HeadersExchange <span class="hljs-title">headersExchage</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeadersExchange(HEADERS_EXCHANGE);&gt;&#125;&gt;<span class="hljs-comment">//队列</span>&gt;<span class="hljs-meta">@Bean</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">headerQueue1</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(HEADER_QUEUE, <span class="hljs-keyword">true</span>);&gt;&#125;&gt;<span class="hljs-comment">//绑定两者</span>&gt;<span class="hljs-meta">@Bean</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">headerBinding</span><span class="hljs-params">()</span> </span>&#123;Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();map.put(<span class="hljs-string">"header1"</span>, <span class="hljs-string">"value1"</span>);map.put(<span class="hljs-string">"header2"</span>, <span class="hljs-string">"value2"</span>);<span class="hljs-keyword">return</span> BindingBuilder.bind(headerQueue1()).to(headersExchage()).whereAll(map).match();<span class="hljs-comment">//whereAll当所有条件满足，才会放入队列</span>&gt;&#125;</code></pre><p>发送端：</p><pre><code class="hljs java">&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendHeader</span><span class="hljs-params">(Object message)</span> </span>&#123;String msg = RedisService.beanToString(message);log.info(<span class="hljs-string">"send fanout message:"</span>+msg);MessageProperties properties = <span class="hljs-keyword">new</span> MessageProperties();properties.setHeader(<span class="hljs-string">"header1"</span>, <span class="hljs-string">"value1"</span>);properties.setHeader(<span class="hljs-string">"header2"</span>, <span class="hljs-string">"value2"</span>);Message obj = <span class="hljs-keyword">new</span> Message(msg.getBytes(), properties);amqpTemplate.convertAndSend(MQConfig.HEADERS_EXCHANGE, <span class="hljs-string">""</span>, obj);&gt;&#125;</code></pre><p>入口：</p><pre><code class="hljs java">&gt;<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/mq/header"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title">header</span><span class="hljs-params">()</span> </span>&#123;sender.sendHeader(<span class="hljs-string">"hello,imooc"</span>);    <span class="hljs-keyword">return</span> Result.success(<span class="hljs-string">"Hello，world"</span>);&#125;</code></pre><p>结果：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626144448.png" srcset="/img/loading.gif" alt="image-20200626144444737"></p></blockquote><h3 id="7-3-秒杀接口优化"><a href="#7-3-秒杀接口优化" class="headerlink" title="7.3 秒杀接口优化"></a>7.3 秒杀接口优化</h3><h4 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h4><p>未优化前流程：判断用户是否登录、判断库存、判断是否已经秒杀过、然后减库存、下订单、写入订单信息</p><p>这个过程访问了四次数据库</p><p>代码：</p><blockquote><pre><code class="hljs java">&gt;<span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/do_miaosha"</span>, method=RequestMethod.POST)&gt;<span class="hljs-meta">@ResponseBody</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Integer&gt; <span class="hljs-title">miaosha</span><span class="hljs-params">(Model model,MiaoshaUser user,</span></span><span class="hljs-function"><span class="hljs-params">                    @RequestParam(<span class="hljs-string">"goodsId"</span>)</span><span class="hljs-keyword">long</span> goodsId) </span>&#123;&gt;model.addAttribute(<span class="hljs-string">"user"</span>, user);&gt;<span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//判断用户---------1</span>&gt;<span class="hljs-keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);&gt;&#125;&gt;<span class="hljs-comment">//判断是否已经秒杀到了---------2</span>&gt;MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);&gt;<span class="hljs-keyword">if</span>(order != <span class="hljs-keyword">null</span>) &#123;&gt;<span class="hljs-keyword">return</span> Result.error(CodeMsg.REPEATE_MIAOSHA);&gt;&#125;&gt;<span class="hljs-comment">//判断库存---------3</span>&gt;GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);<span class="hljs-comment">//10个商品，req1 req2</span>&gt;<span class="hljs-keyword">int</span> stock = goods.getStockCount();&gt;<span class="hljs-keyword">if</span>(stock &lt;= <span class="hljs-number">0</span>) &#123;&gt;<span class="hljs-keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);&gt;&#125;&gt;<span class="hljs-comment">//判断是否已经秒杀到了---------4</span>&gt;MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);&gt;<span class="hljs-keyword">if</span>(order != <span class="hljs-keyword">null</span>) &#123;&gt;<span class="hljs-keyword">return</span> Result.error(CodeMsg.REPEATE_MIAOSHA);&gt;&#125;&gt;<span class="hljs-comment">//减库存 下订单 写入秒杀订单---------5</span>&gt;OrderInfo orderInfo = miaoshaService.miaosha(user, goods);&gt;<span class="hljs-keyword">return</span> Result.success(orderInfo);&gt;&#125;</code></pre></blockquote><h4 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h4><p>思路：<strong>减少数据库访问</strong></p><blockquote><p>系统初始化，系统初始化时，把商品加载到Redis中</p><p>收到请求时，Redis预减少库存，库存不足，直接返回（这里还可以使用一个<strong>Map</strong>做一个内存标记）</p><p>库存如果够，把请求放入到消息队列中，返回一个排队中状态</p><p>请求出队，生成订单（这个订单写入到缓存中），减少库存</p><p>客户端轮询（去缓存取），是否秒杀成功</p></blockquote><p>代码：</p><p>系统初始化，系统初始化时，把商品加载到Redis中</p><blockquote><p>实现接口InitializingBean，重写方法afterPropertiesSet()</p><p>如果实现了InitializingBean接口，那么框架启动时，会回调afterPropertiesSet方法，我们可以在这个方法中实现系统启动时加载商品到缓存中</p><pre><code class="hljs java">&gt;<span class="hljs-comment">/**</span><span class="hljs-comment">&gt;* 系统初始化</span><span class="hljs-comment">&gt;* */</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();<span class="hljs-comment">//先从数据库中查询出所有数据</span><span class="hljs-keyword">if</span>(goodsList == <span class="hljs-keyword">null</span>) &#123;   <span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span>(GoodsVo goods : goodsList) &#123;   redisService.set(GoodsKey.getMiaoshaGoodsStock, <span class="hljs-string">""</span>+goods.getId(), goods.getStockCount());<span class="hljs-comment">//把查询出来的数据，放到缓存中</span>   localOverMap.put(goods.getId(), <span class="hljs-keyword">false</span>);&#125;&gt;&#125;</code></pre></blockquote><p>收到请求时，Redis预减少库存，库存不足，直接返回</p><pre><code class="hljs java"><span class="hljs-comment">//预减库存</span><span class="hljs-keyword">long</span> stock = redisService.decr(GoodsKey.getMiaoshaGoodsStock, <span class="hljs-string">""</span>+goodsId);<span class="hljs-comment">//10</span><span class="hljs-keyword">if</span>(stock &lt; <span class="hljs-number">0</span>) &#123;    localOverMap.put(goodsId, <span class="hljs-keyword">true</span>);   <span class="hljs-keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);&#125;</code></pre><p>如果库存不为0，就判断用户是否已经成功秒杀过一次</p><pre><code class="hljs java"><span class="hljs-comment">//判断是否已经秒杀到了</span>MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);<span class="hljs-keyword">if</span>(order != <span class="hljs-keyword">null</span>) &#123;   <span class="hljs-keyword">return</span> Result.error(CodeMsg.REPEATE_MIAOSHA);&#125;</code></pre><p>如果用户没用秒杀过，那么就把这个请求入队</p><pre><code class="hljs java"><span class="hljs-comment">//入队</span><span class="hljs-meta">@Autowired</span>MQSender sender;MiaoshaMessage mm = <span class="hljs-keyword">new</span> MiaoshaMessage();mm.setUser(user);mm.setGoodsId(goodsId);sender.sendMiaoshaMessage(mm);<span class="hljs-comment">//发送信息：信息中包含用户、商品ID</span><span class="hljs-keyword">return</span> Result.success(<span class="hljs-number">0</span>);<span class="hljs-comment">//排队中</span></code></pre><p>定义消息队列的发送者：使用Direct模式</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>AmqpTemplate amqpTemplate ; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMiaoshaMessage</span><span class="hljs-params">(MiaoshaMessage mm)</span> </span>&#123;   String msg = RedisService.beanToString(mm);   log.info(<span class="hljs-string">"send message:"</span>+msg);   amqpTemplate.convertAndSend(MQConfig.MIAOSHA_QUEUE, msg);&#125;</code></pre><p>使用的队列：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MIAOSHA_QUEUE = <span class="hljs-string">"miaosha.queue"</span>;</code></pre><p>接收端</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> HashMap&lt;Long, Boolean&gt; localOverMap =  <span class="hljs-keyword">new</span> HashMap&lt;Long, Boolean&gt;();<span class="hljs-comment">//内存标记</span> <span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/do_miaosha"</span>, method=RequestMethod.POST)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Integer&gt; <span class="hljs-title">miaosha</span><span class="hljs-params">(Model model,MiaoshaUser user,</span></span><span class="hljs-function"><span class="hljs-params">                               @RequestParam(<span class="hljs-string">"goodsId"</span>)</span><span class="hljs-keyword">long</span> goodsId) </span>&#123;    model.addAttribute(<span class="hljs-string">"user"</span>, user);    <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);    &#125;    <span class="hljs-comment">//内存标记，减少redis访问</span>    <span class="hljs-keyword">boolean</span> over = localOverMap.get(goodsId);<span class="hljs-comment">//判断商品是否卖完</span>    <span class="hljs-keyword">if</span>(over) &#123;        <span class="hljs-keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);<span class="hljs-comment">//如果卖完，就返回一个错误信息</span>    &#125;    <span class="hljs-comment">//预减库存</span>    <span class="hljs-keyword">long</span> stock = redisService.decr(GoodsKey.getMiaoshaGoodsStock, <span class="hljs-string">""</span>+goodsId);<span class="hljs-comment">//10</span>    <span class="hljs-keyword">if</span>(stock &lt; <span class="hljs-number">0</span>) &#123;        localOverMap.put(goodsId, <span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);    &#125;    <span class="hljs-comment">//判断是否已经秒杀到了</span>    MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);    <span class="hljs-keyword">if</span>(order != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> Result.error(CodeMsg.REPEATE_MIAOSHA);    &#125;    <span class="hljs-comment">//入队</span>    MiaoshaMessage mm = <span class="hljs-keyword">new</span> MiaoshaMessage();    mm.setUser(user);    mm.setGoodsId(goodsId);    sender.sendMiaoshaMessage(mm);    <span class="hljs-keyword">return</span> Result.success(<span class="hljs-number">0</span>);<span class="hljs-comment">//排队中</span>&#125;</code></pre><p>客户端轮询：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * orderId：成功</span><span class="hljs-comment">     * -1：秒杀失败</span><span class="hljs-comment">     * 0： 排队中</span><span class="hljs-comment">     * */</span><span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/result"</span>, method=RequestMethod.GET)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Long&gt; <span class="hljs-title">miaoshaResult</span><span class="hljs-params">(Model model,MiaoshaUser user,</span></span><span class="hljs-function"><span class="hljs-params">                                  @RequestParam(<span class="hljs-string">"goodsId"</span>)</span><span class="hljs-keyword">long</span> goodsId) </span>&#123;    model.addAttribute(<span class="hljs-string">"user"</span>, user);    <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);    &#125;    <span class="hljs-keyword">long</span> result  =miaoshaService.getMiaoshaResult(user.getId(), goodsId);    <span class="hljs-keyword">return</span> Result.success(result);<span class="hljs-comment">//如果请求还在排队，那么就继续轮询</span>&#125; <span class="hljs-meta">@AccessLimit</span>(seconds=<span class="hljs-number">5</span>, maxCount=<span class="hljs-number">5</span>, needLogin=<span class="hljs-keyword">true</span>)<span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/path"</span>, method=RequestMethod.GET)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title">getMiaoshaPath</span><span class="hljs-params">(HttpServletRequest request, MiaoshaUser user,</span></span><span class="hljs-function"><span class="hljs-params">                                     @RequestParam(<span class="hljs-string">"goodsId"</span>)</span><span class="hljs-keyword">long</span> goodsId,</span><span class="hljs-function">                                     @<span class="hljs-title">RequestParam</span><span class="hljs-params">(value=<span class="hljs-string">"verifyCode"</span>, defaultValue=<span class="hljs-string">"0"</span>)</span><span class="hljs-keyword">int</span> verifyCode</span><span class="hljs-function">                                    ) </span>&#123;    <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);    &#125;    <span class="hljs-keyword">boolean</span> check = miaoshaService.checkVerifyCode(user, goodsId, verifyCode);    <span class="hljs-keyword">if</span>(!check) &#123;        <span class="hljs-keyword">return</span> Result.error(CodeMsg.REQUEST_ILLEGAL);    &#125;    String path  =miaoshaService.createMiaoshaPath(user, goodsId);    <span class="hljs-keyword">return</span> Result.success(path);&#125;</code></pre><p>前端：用户进入商品详情页，点击立即秒杀后，后端返回一个状态码，</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>商品详情<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=UTF-8"</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- jquery --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/js/jquery.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- bootstrap --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;/bootstrap/css/bootstrap.min.css&#125;"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/bootstrap/js/bootstrap.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- jquery-validator --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/jquery-validation/jquery.validate.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/jquery-validation/localization/messages_zh.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- layer --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/layer/layer.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- md5.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/js/md5.min.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- common.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;/js/common.js&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"panel panel-default"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"panel-heading"</span>&gt;</span>秒杀商品详情<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"panel-body"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;user eq null&#125;"</span>&gt;</span> 您还没有登录，请登陆后再操作<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>没有收货地址的提示。。。<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"table"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"goodslist"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品名称<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"3"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;goods.goodsName&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品图片<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"3"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;$&#123;goods.goodsImg&#125;&#125;"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"200"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"200"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>秒杀开始时间<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;#dates.format(goods.startDate, 'yyyy-MM-dd HH:mm:ss')&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"miaoshaTip"</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"remainSeconds"</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">"$&#123;remainSeconds&#125;"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;miaoshaStatus eq 0&#125;"</span>&gt;</span>秒杀倒计时：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"countDown"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;remainSeconds&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>秒<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;miaoshaStatus eq 1&#125;"</span>&gt;</span>秒杀进行中<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;miaoshaStatus eq 2&#125;"</span>&gt;</span>秒杀已结束<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"miaoshaForm"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/miaosha/do_miaosha"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary btn-block"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"buyButton"</span>&gt;</span>立即秒杀<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"goodsId"</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">"$&#123;goods.id&#125;"</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品原价<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"3"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;goods.goodsPrice&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>秒杀价<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"3"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;goods.miaoshaPrice&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>库存数量<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"3"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;goods.stockCount&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span>    countDown();&#125;); <span class="actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countDown</span><span class="hljs-params">()</span></span>&#123;</span><span class="javascript">    <span class="hljs-keyword">var</span> remainSeconds = $(<span class="hljs-string">"#remainSeconds"</span>).val();</span><span class="actionscript">    <span class="hljs-keyword">var</span> timeout;</span><span class="actionscript">    <span class="hljs-keyword">if</span>(remainSeconds &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//秒杀还没开始，倒计时</span></span><span class="javascript">        $(<span class="hljs-string">"#buyButton"</span>).attr(<span class="hljs-string">"disabled"</span>, <span class="hljs-literal">true</span>);</span><span class="actionscript">        timeout = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;</span><span class="javascript">            $(<span class="hljs-string">"#countDown"</span>).text(remainSeconds - <span class="hljs-number">1</span>);</span><span class="javascript">            $(<span class="hljs-string">"#remainSeconds"</span>).val(remainSeconds - <span class="hljs-number">1</span>);</span>            countDown();        &#125;,1000);<span class="actionscript">    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(remainSeconds == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//秒杀进行中</span></span><span class="javascript">        $(<span class="hljs-string">"#buyButton"</span>).attr(<span class="hljs-string">"disabled"</span>, <span class="hljs-literal">false</span>);</span>        if(timeout)&#123;            clearTimeout(timeout);        &#125;<span class="javascript">        $(<span class="hljs-string">"#miaoshaTip"</span>).html(<span class="hljs-string">"秒杀进行中"</span>);</span><span class="actionscript">    &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//秒杀已经结束</span></span><span class="javascript">        $(<span class="hljs-string">"#buyButton"</span>).attr(<span class="hljs-string">"disabled"</span>, <span class="hljs-literal">true</span>);</span><span class="javascript">        $(<span class="hljs-string">"#miaoshaTip"</span>).html(<span class="hljs-string">"秒杀已经结束"</span>);</span>    &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="7-4-其他优化"><a href="#7-4-其他优化" class="headerlink" title="7.4 其他优化"></a>7.4 其他优化</h3><p>下面这些优化手段都是为了降低并发请求量</p><h4 id="7-4-1-隐藏秒杀地址"><a href="#7-4-1-隐藏秒杀地址" class="headerlink" title="7.4.1 隐藏秒杀地址"></a>7.4.1 隐藏秒杀地址</h4><p>思路：秒杀开始之前，先去请求接口，获取秒杀地址</p><blockquote><p>步骤：</p><p>接口改造，带上PathVariable参数</p><p>添加生成地址的接口</p><p>秒杀收到请求，先验证PathVaribale</p></blockquote><p>代码：</p><pre><code class="hljs js"><span class="hljs-comment">//前端，用户在点击立即秒杀时，做一个用户验证，判断这个用户是否合法</span><span class="hljs-comment">//省略其他代码。用户在点击立即秒杀后，执行程序：getMiaoshaPath()，获取秒杀路径，然后获取完秒杀路径后，去执行秒杀，执行完后，返回秒杀结果</span>    &lt;button <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"btn btn-primary"</span> type=<span class="hljs-string">"button"</span> id=<span class="hljs-string">"buyButton"</span>onclick=<span class="hljs-string">"getMiaoshaPath()"</span>&gt;立即秒杀&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp"> </span><span class="hljs-regexp"> </span><span class="hljs-regexp">function getMiaoshaPath()&#123;</span><span class="hljs-regexp">    var goodsId = $("#goodsId").val();</span><span class="hljs-regexp">    g_showLoading();</span><span class="hljs-regexp">    $.ajax(&#123;</span><span class="hljs-regexp">        url:"/mi</span>aosha/path<span class="hljs-string">",</span><span class="hljs-string">        type:"</span>GET<span class="hljs-string">",</span><span class="hljs-string">        data:&#123;</span><span class="hljs-string">            goodsId:goodsId,//传入商品ID</span>            verifyCode:$("#verifyCode").val()        &#125;,        success:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">var</span> path = data.data;<span class="hljs-comment">//从后端拿到路径</span>                doMiaosha(path);<span class="hljs-comment">//开始进行秒杀</span>            &#125;<span class="hljs-keyword">else</span>&#123;                layer.msg(data.msg);            &#125;        &#125;,        error:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            layer.msg(<span class="hljs-string">"客户端请求有误"</span>);        &#125;    &#125;);&#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doMiaosha</span>(<span class="hljs-params">path</span>)</span>&#123;    $.ajax(&#123;        url:<span class="hljs-string">"/miaosha/"</span>+path+<span class="hljs-string">"/do_miaosha"</span>,        type:<span class="hljs-string">"POST"</span>,        data:&#123;            goodsId:$(<span class="hljs-string">"#goodsId"</span>).val()        &#125;,        success:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>)&#123;                <span class="hljs-comment">//window.location.href="/order_detail.htm?orderId="+data.data.id;</span>                getMiaoshaResult($(<span class="hljs-string">"#goodsId"</span>).val());            &#125;<span class="hljs-keyword">else</span>&#123;                layer.msg(data.msg);            &#125;        &#125;,        error:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            layer.msg(<span class="hljs-string">"客户端请求有误"</span>);        &#125;    &#125;);      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMiaoshaResult</span>(<span class="hljs-params">goodsId</span>)</span>&#123;        g_showLoading();        $.ajax(&#123;            url:<span class="hljs-string">"/miaosha/result"</span>,            type:<span class="hljs-string">"GET"</span>,            data:&#123;                goodsId:$(<span class="hljs-string">"#goodsId"</span>).val(),            &#125;,            success:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;                <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>)&#123;                    <span class="hljs-keyword">var</span> result = data.data;                    <span class="hljs-keyword">if</span>(result &lt; <span class="hljs-number">0</span>)&#123;                        layer.msg(<span class="hljs-string">"对不起，秒杀失败"</span>);                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//继续轮询</span>                        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;                            getMiaoshaResult(goodsId);                        &#125;, <span class="hljs-number">200</span>);                    &#125;<span class="hljs-keyword">else</span>&#123;                        layer.confirm(<span class="hljs-string">"恭喜你，秒杀成功！查看订单？"</span>, &#123;<span class="hljs-attr">btn</span>:[<span class="hljs-string">"确定"</span>,<span class="hljs-string">"取消"</span>]&#125;,                                      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;                            <span class="hljs-built_in">window</span>.location.href=<span class="hljs-string">"/order_detail.htm?orderId="</span>+result;                        &#125;,                                      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;                            layer.closeAll();                        &#125;);                    &#125;                &#125;<span class="hljs-keyword">else</span>&#123;                    layer.msg(data.msg);                &#125;            &#125;,            error:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;                layer.msg(<span class="hljs-string">"客户端请求有误"</span>);            &#125;        &#125;);    &#125;</code></pre><p>后端代码：</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/&#123;path&#125;/do_miaosha"</span>, method=RequestMethod.POST)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Integer&gt; <span class="hljs-title">miaosha</span><span class="hljs-params">(Model model,MiaoshaUser user,</span></span><span class="hljs-function"><span class="hljs-params">                               @RequestParam(<span class="hljs-string">"goodsId"</span>)</span><span class="hljs-keyword">long</span> goodsId,</span><span class="hljs-function">                               @<span class="hljs-title">PathVariable</span><span class="hljs-params">(<span class="hljs-string">"path"</span>)</span> String path) </span>&#123;    model.addAttribute(<span class="hljs-string">"user"</span>, user);    <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);    &#125;    <span class="hljs-comment">//验证path，前端传进来的地址，验证一下是否合法</span>    <span class="hljs-keyword">boolean</span> check = miaoshaService.checkPath(user, goodsId, path);    <span class="hljs-keyword">if</span>(!check)&#123;        <span class="hljs-keyword">return</span> Result.error(CodeMsg.REQUEST_ILLEGAL);    &#125;    <span class="hljs-comment">//内存标记，减少redis访问</span>    <span class="hljs-keyword">boolean</span> over = localOverMap.get(goodsId);    <span class="hljs-keyword">if</span>(over) &#123;        <span class="hljs-keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);    &#125;    <span class="hljs-comment">//预减库存</span>    <span class="hljs-keyword">long</span> stock = redisService.decr(GoodsKey.getMiaoshaGoodsStock, <span class="hljs-string">""</span>+goodsId);<span class="hljs-comment">//10</span>    <span class="hljs-keyword">if</span>(stock &lt; <span class="hljs-number">0</span>) &#123;        localOverMap.put(goodsId, <span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);    &#125;    <span class="hljs-comment">//判断是否已经秒杀到了</span>    MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);    <span class="hljs-keyword">if</span>(order != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> Result.error(CodeMsg.REPEATE_MIAOSHA);    &#125;    <span class="hljs-comment">//入队</span>    MiaoshaMessage mm = <span class="hljs-keyword">new</span> MiaoshaMessage();    mm.setUser(user);    mm.setGoodsId(goodsId);    sender.sendMiaoshaMessage(mm);    <span class="hljs-keyword">return</span> Result.success(<span class="hljs-number">0</span>);<span class="hljs-comment">//排队中</span> &#125;</code></pre><p>生成秒杀路径</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">createMiaoshaPath</span><span class="hljs-params">(MiaoshaUser user, <span class="hljs-keyword">long</span> goodsId)</span> </span>&#123;    <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span> || goodsId &lt;=<span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    String str = MD5Util.md5(UUIDUtil.uuid()+<span class="hljs-string">"123456"</span>);    redisService.set(MiaoshaKey.getMiaoshaPath, <span class="hljs-string">""</span>+user.getId() + <span class="hljs-string">"_"</span>+ goodsId, str);    <span class="hljs-keyword">return</span> str;&#125;</code></pre><p>验证秒杀路径</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkPath</span><span class="hljs-params">(MiaoshaUser user, <span class="hljs-keyword">long</span> goodsId, String path)</span> </span>&#123;    <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span> || path == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    String pathOld = redisService.get(MiaoshaKey.getMiaoshaPath, <span class="hljs-string">""</span>+user.getId() + <span class="hljs-string">"_"</span>+ goodsId, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-keyword">return</span> path.equals(pathOld);&#125;</code></pre><p>但是又有一个问题，获取秒杀接口的地址，也有暴露的危险，解决方案：验证码</p><h4 id="7-4-2-图形验证码"><a href="#7-4-2-图形验证码" class="headerlink" title="7.4.2 图形验证码"></a>7.4.2 图形验证码</h4><p>在用户点击秒杀按钮时，有一个验证码，要求用户输入验证码，才可以秒杀</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200627160327.png" srcset="/img/loading.gif" alt="image-20200627160323496"></p><p>作用：防止机器人、以及降低用户的请求</p><blockquote><p>步骤：</p><p>1、添加生成验证码的接口</p><p>2、获取秒杀路径的时候，验证验证码</p><p>3、ScriptEngine使用（JDK6）</p></blockquote><p>代码：</p><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>一个输入框，一个验证码图片</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"verifyCodeImg"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"80"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"32"</span>  <span class="hljs-attr">style</span>=<span class="hljs-string">"display:none"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"refreshVerifyCode()"</span>/&gt;</span><span class="hljs-comment">&lt;!--//style="display:none"，一开始是不展示的--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"verifyCode"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"display:none"</span>/&gt;</span></code></pre><p>页面初始化，渲染完页面后，开始生成验证码。注意只有在秒杀进行中，才会生成验证码</p><pre><code class="hljs js"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(remainSeconds == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//秒杀进行中</span>    $(<span class="hljs-string">"#buyButton"</span>).attr(<span class="hljs-string">"disabled"</span>, <span class="hljs-literal">false</span>);    <span class="hljs-keyword">if</span>(timeout)&#123;        clearTimeout(timeout);    &#125;    $(<span class="hljs-string">"#miaoshaTip"</span>).html(<span class="hljs-string">"秒杀进行中"</span>);    $(<span class="hljs-string">"#verifyCodeImg"</span>).attr(<span class="hljs-string">"src"</span>, <span class="hljs-string">"/miaosha/verifyCode?goodsId="</span>+$(<span class="hljs-string">"#goodsId"</span>).val());<span class="hljs-comment">//验证码地址，这里也要输入商品地址</span>    $(<span class="hljs-string">"#verifyCodeImg"</span>).show();<span class="hljs-comment">//展示图片</span>    $(<span class="hljs-string">"#verifyCode"</span>).show();<span class="hljs-comment">//把输入框也给展示出来</span>&#125;</code></pre><p>秒杀结束后，把图片和输入框给隐藏掉</p><pre><code class="hljs js"><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//秒杀已经结束</span>        $(<span class="hljs-string">"#buyButton"</span>).attr(<span class="hljs-string">"disabled"</span>, <span class="hljs-literal">true</span>);        $(<span class="hljs-string">"#miaoshaTip"</span>).html(<span class="hljs-string">"秒杀已经结束"</span>);        $(<span class="hljs-string">"#verifyCodeImg"</span>).hide();        $(<span class="hljs-string">"#verifyCode"</span>).hide();    &#125;</code></pre><p>生成图片验证码的接口</p><pre><code class="hljs java"><span class="hljs-comment">//思路：先验证参数，传入商品参数，</span><span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/verifyCode"</span>, method=RequestMethod.GET)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title">getMiaoshaVerifyCod</span><span class="hljs-params">(HttpServletResponse response,MiaoshaUser user,</span></span><span class="hljs-function"><span class="hljs-params">            @RequestParam(<span class="hljs-string">"goodsId"</span>)</span><span class="hljs-keyword">long</span> goodsId) </span>&#123;        <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);        &#125;        <span class="hljs-keyword">try</span> &#123;            BufferedImage image  = miaoshaService.createVerifyCode(user, goodsId);<span class="hljs-comment">//使用BufferedImage</span>            OutputStream out = response.getOutputStream();            ImageIO.write(image, <span class="hljs-string">"JPEG"</span>, out);            out.flush();            out.close();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> Result.error(CodeMsg.MIAOSHA_FAIL);        &#125;    &#125;</code></pre><p>点击验证码图片，刷新验证码</p><p>刷新验证码就是重新调用验证码，但是浏览器对图片是有缓存的，所以插入一个参数<code>new Date().getTime()</code></p><pre><code class="hljs js">&lt;img id=<span class="hljs-string">"verifyCodeImg"</span> width=<span class="hljs-string">"80"</span> height=<span class="hljs-string">"32"</span>  style=<span class="hljs-string">"display:none"</span> onclick=<span class="hljs-string">"refreshVerifyCode()"</span>/&gt; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refreshVerifyCode</span>(<span class="hljs-params"></span>)</span>&#123;    $(<span class="hljs-string">"#verifyCodeImg"</span>).attr(<span class="hljs-string">"src"</span>, <span class="hljs-string">"/miaosha/verifyCode?goodsId="</span>+$(<span class="hljs-string">"#goodsId"</span>).val()+<span class="hljs-string">"&amp;timestamp="</span>+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime());&#125;</code></pre><h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><p><code>controller</code>层</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/verifyCode"</span>, method=RequestMethod.GET)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title">getMiaoshaVerifyCod</span><span class="hljs-params">(HttpServletResponse response,MiaoshaUser user,</span></span><span class="hljs-function"><span class="hljs-params">                                          @RequestParam(<span class="hljs-string">"goodsId"</span>)</span><span class="hljs-keyword">long</span> goodsId) </span>&#123;    <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//验证用户</span>        <span class="hljs-keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);    &#125;    <span class="hljs-keyword">try</span> &#123;        BufferedImage image  = miaoshaService.createVerifyCode(user, goodsId);<span class="hljs-comment">//得到验证码</span>        OutputStream out = response.getOutputStream();<span class="hljs-comment">//输出验证码</span>        ImageIO.write(image, <span class="hljs-string">"JPEG"</span>, out);<span class="hljs-comment">//使用ImageIO，以JPEG的格式，把图片写入到输出流</span>        out.flush();<span class="hljs-comment">//刷新</span>        out.close();<span class="hljs-comment">//关闭</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<span class="hljs-comment">//如果出了异常，就抛出秒杀失败异常</span>        e.printStackTrace();        <span class="hljs-keyword">return</span> Result.error(CodeMsg.MIAOSHA_FAIL);    &#125;&#125;</code></pre><p><code>service</code>层</p><p>思路：画一张图片，生成验证码后，把验证码画到图片上，然后把计算结果保存到redis中</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> BufferedImage <span class="hljs-title">createVerifyCode</span><span class="hljs-params">(MiaoshaUser user, <span class="hljs-keyword">long</span> goodsId)</span> </span>&#123;    <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span> || goodsId &lt;=<span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">int</span> width = <span class="hljs-number">80</span>;<span class="hljs-comment">//定义图片宽度</span>    <span class="hljs-keyword">int</span> height = <span class="hljs-number">32</span>;<span class="hljs-comment">//图片高度</span>    <span class="hljs-comment">//create the image</span>    BufferedImage image = <span class="hljs-keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);<span class="hljs-comment">//创建BufferedImage对象，参数为宽度、高度、RGB</span>    Graphics g = image.getGraphics();<span class="hljs-comment">//获取这个图像，拿到这个图像后就可以在这个图像上写验证码了</span>    <span class="hljs-comment">// set the background color</span>    g.setColor(<span class="hljs-keyword">new</span> Color(<span class="hljs-number">0xDCDCDC</span>));<span class="hljs-comment">//设置背景颜色</span>    g.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<span class="hljs-comment">//背景颜色填充</span>    <span class="hljs-comment">// draw the border</span>    g.setColor(Color.black);<span class="hljs-comment">//画笔为黑色</span>    g.drawRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width - <span class="hljs-number">1</span>, height - <span class="hljs-number">1</span>);<span class="hljs-comment">//用画笔画了一个黑色的矩形框</span>    <span class="hljs-comment">// create a random instance to generate the codes</span>    Random rdm = <span class="hljs-keyword">new</span> Random();    <span class="hljs-comment">// make some confusion</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<span class="hljs-comment">//在图片上生成50个干扰点</span>        <span class="hljs-keyword">int</span> x = rdm.nextInt(width);        <span class="hljs-keyword">int</span> y = rdm.nextInt(height);        g.drawOval(x, y, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">//上面这些都是基本设置，下面才是生成验证码</span>    <span class="hljs-comment">// generate a random code</span>    String verifyCode = generateVerifyCode(rdm);<span class="hljs-comment">//生成验证码</span>    g.setColor(<span class="hljs-keyword">new</span> Color(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//设置验证码颜色</span>    g.setFont(<span class="hljs-keyword">new</span> Font(<span class="hljs-string">"Candara"</span>, Font.BOLD, <span class="hljs-number">24</span>));<span class="hljs-comment">//设置字体</span>    g.drawString(verifyCode, <span class="hljs-number">8</span>, <span class="hljs-number">24</span>);<span class="hljs-comment">//把验证码写到图片上</span>    g.dispose();<span class="hljs-comment">//关闭画笔</span>    <span class="hljs-comment">//把验证码存到redis中</span>    <span class="hljs-keyword">int</span> rnd = calc(verifyCode);<span class="hljs-comment">//计算一下验证码</span>    redisService.set(MiaoshaKey.getMiaoshaVerifyCode, user.getId()+<span class="hljs-string">","</span>+goodsId, rnd);<span class="hljs-comment">//把计算结果存到redis中</span>    <span class="hljs-comment">//输出图片   </span>    <span class="hljs-keyword">return</span> image;&#125;</code></pre><p>生成验证码</p><p>随机生成三个十以内的数字，做加减乘。为了简化代码，不做除法，因为除法可能会除0。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] ops = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[] &#123;<span class="hljs-string">'+'</span>, <span class="hljs-string">'-'</span>, <span class="hljs-string">'*'</span>&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment">     * + - *</span><span class="hljs-comment">     * */</span><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">generateVerifyCode</span><span class="hljs-params">(Random rdm)</span> </span>&#123;    <span class="hljs-keyword">int</span> num1 = rdm.nextInt(<span class="hljs-number">10</span>);<span class="hljs-comment">//数字</span>    <span class="hljs-keyword">int</span> num2 = rdm.nextInt(<span class="hljs-number">10</span>);    <span class="hljs-keyword">int</span> num3 = rdm.nextInt(<span class="hljs-number">10</span>);    <span class="hljs-keyword">char</span> op1 = ops[rdm.nextInt(<span class="hljs-number">3</span>)];<span class="hljs-comment">//运算符</span>    <span class="hljs-keyword">char</span> op2 = ops[rdm.nextInt(<span class="hljs-number">3</span>)];    String exp = <span class="hljs-string">""</span>+ num1 + op1 + num2 + op2 + num3;    <span class="hljs-keyword">return</span> exp;<span class="hljs-comment">//返回验证码</span>&#125;</code></pre><p>计算验证码结果：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(String exp)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        ScriptEngineManager manager = <span class="hljs-keyword">new</span> ScriptEngineManager();<span class="hljs-comment">//使用ScriptEngine计算验证码</span>        ScriptEngine engine = manager.getEngineByName(<span class="hljs-string">"JavaScript"</span>);<span class="hljs-comment">//使用JavaScript的V8引擎</span>        <span class="hljs-keyword">return</span> (Integer)engine.eval(exp);<span class="hljs-comment">//返回计算结果</span>    &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre><p>当用户输入验证码，点击立即秒杀按钮后，服务端需要做一个验证。也就是说秒杀之前，先要通过请求<code>path</code>方法，生成秒杀路径。所以我们需要在这里做<strong>验证码的校验</strong>。</p><pre><code class="hljs java"><span class="hljs-meta">@AccessLimit</span>(seconds=<span class="hljs-number">5</span>, maxCount=<span class="hljs-number">5</span>, needLogin=<span class="hljs-keyword">true</span>)<span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/path"</span>, method=RequestMethod.GET)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title">getMiaoshaPath</span><span class="hljs-params">(HttpServletRequest request, MiaoshaUser user,</span></span><span class="hljs-function"><span class="hljs-params">                                     @RequestParam(<span class="hljs-string">"goodsId"</span>)</span><span class="hljs-keyword">long</span> goodsId,</span><span class="hljs-function">                                     @<span class="hljs-title">RequestParam</span><span class="hljs-params">(value=<span class="hljs-string">"verifyCode"</span>, defaultValue=<span class="hljs-string">"0"</span>)</span><span class="hljs-keyword">int</span> verifyCode</span><span class="hljs-function">                                    ) </span>&#123;    <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);    &#125;    <span class="hljs-keyword">boolean</span> check = miaoshaService.checkVerifyCode(user, goodsId, verifyCode);<span class="hljs-comment">//输入用户、商品ID和用户输入的验证码，去redis中校验验证码</span>    <span class="hljs-keyword">if</span>(!check) &#123;<span class="hljs-comment">//如果校验失败</span>        <span class="hljs-keyword">return</span> Result.error(CodeMsg.REQUEST_ILLEGAL);<span class="hljs-comment">//就返回请求非法</span>    &#125;    String path  =miaoshaService.createMiaoshaPath(user, goodsId);    <span class="hljs-keyword">return</span> Result.success(path);&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkVerifyCode</span><span class="hljs-params">(MiaoshaUser user, <span class="hljs-keyword">long</span> goodsId, <span class="hljs-keyword">int</span> verifyCode)</span> </span>&#123;    <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span> || goodsId &lt;=<span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//参数验证</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">//从redis中取出来验证码</span>    Integer codeOld = redisService.get(MiaoshaKey.getMiaoshaVerifyCode, user.getId()+<span class="hljs-string">","</span>+goodsId, Integer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-keyword">if</span>(codeOld == <span class="hljs-keyword">null</span> || codeOld - verifyCode != <span class="hljs-number">0</span> ) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">//从redis中删除这个验证码</span>    redisService.delete(MiaoshaKey.getMiaoshaVerifyCode, user.getId()+<span class="hljs-string">","</span>+goodsId);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><h4 id="7-4-3-接口防刷限流"><a href="#7-4-3-接口防刷限流" class="headerlink" title="7.4.3 接口防刷限流"></a>7.4.3 接口防刷限流</h4><p>限制用户在一个接口在5秒钟内最多访问5次，超过5次就是非法的，禁止访问</p><p>思路：使用缓存，当用户访问接口时，把访问次数放到缓存中，同时给这个<strong>访问次数加一个有效期</strong>，如果在5秒钟内再次访问就加1，如果访问次数超过了5，就返回一个失败。到了下一个5秒钟，就清空访问次数。</p><p>使用拦截器，拦截器中拦截请求的次数。</p><p>使用注解实现：@AccessLimit</p><pre><code class="hljs java"><span class="hljs-meta">@Retention</span>(RUNTIME)<span class="hljs-meta">@Target</span>(METHOD)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AccessLimit &#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">seconds</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxCount</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">needLogin</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;&#125;</code></pre><p>springboot定义拦截器。（拦截器首先执行，参数解析后执行）</p><pre><code class="hljs java"> <span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessInterceptor</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">HandlerInterceptorAdapter</span></span>&#123;     <span class="hljs-meta">@Autowired</span>    MiaoshaUserService userService;     <span class="hljs-meta">@Autowired</span>    RedisService redisService;    <span class="hljs-comment">//preHandle，方法执行前进行拦截，主要有两个功能：一个是设置访问次数、一个是判断页面是否登录后才可以查看</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//HandlerMethod 是一个包含了handler的Bean本身和请求方法的对象！也就是说，所谓的handler在这里，是指包含了我们请求的Controller类和Method方法的对象</span>        <span class="hljs-keyword">if</span>(handler <span class="hljs-keyword">instanceof</span> HandlerMethod) &#123;<span class="hljs-comment">//instanceof 左边是对象，右边是类，所以判断handler是不是这个类的对象实例（子类、接口实现都算）</span>            MiaoshaUser user = getUser(request, response);<span class="hljs-comment">//取出用户</span>            UserContext.setUser(user);<span class="hljs-comment">//保存用户到ThreadLoacl，本地线程变量副本</span>            HandlerMethod hm = (HandlerMethod)handler;<span class="hljs-comment">//</span>            AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">//拿到方法上的注解</span>            <span class="hljs-keyword">if</span>(accessLimit == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//如果没有注解，说明我们没有使用这么注解</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">int</span> seconds = accessLimit.seconds();<span class="hljs-comment">//获得秒</span>            <span class="hljs-keyword">int</span> maxCount = accessLimit.maxCount();<span class="hljs-comment">//获得次数</span>            <span class="hljs-keyword">boolean</span> needLogin = accessLimit.needLogin();<span class="hljs-comment">//判断是否登录</span>            String key = request.getRequestURI();<span class="hljs-comment">//获得用户key，默认是路径</span>            <span class="hljs-keyword">if</span>(needLogin) &#123;<span class="hljs-comment">//判断这个方法是否需要登录，如果需要登录</span>                <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//如果用户为空</span>                    render(response, CodeMsg.SESSION_ERROR);<span class="hljs-comment">//给客户端一个提示</span>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//返回失败</span>                &#125;                key += <span class="hljs-string">"_"</span> + user.getId();<span class="hljs-comment">//如果需要登录，那么再添加一个_和用户ID</span>            &#125;<span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//do nothing</span>            &#125;            <span class="hljs-comment">//处理访问次数和时间</span>            AccessKey ak = AccessKey.withExpire(seconds);<span class="hljs-comment">//设置Key的有效期</span>            Integer count = redisService.get(ak, key, Integer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">//先从缓存根据key取出来访问次数</span>            <span class="hljs-keyword">if</span>(count  == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//如果用户访问次数为空，说明在某个时间段内，是第一次访问</span>                redisService.set(ak, key, <span class="hljs-number">1</span>);            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count &lt; maxCount) &#123;<span class="hljs-comment">//访问次数小于最大次数（指定时间内）</span>                redisService.incr(ak, key);<span class="hljs-comment">//那么就增加一次</span>            &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果大于最大次数，输出一个错误信息给客户端</span>                render(response, CodeMsg.ACCESS_LIMIT_REACHED);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">//返回给客户端一个提示信息</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">render</span><span class="hljs-params">(HttpServletResponse response, CodeMsg cm)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;        response.setContentType(<span class="hljs-string">"application/json;charset=UTF-8"</span>);        OutputStream out = response.getOutputStream();<span class="hljs-comment">//获得响应的输出流</span>        String str  = JSON.toJSONString(Result.error(cm));<span class="hljs-comment">//转车JSON</span>        out.write(str.getBytes(<span class="hljs-string">"UTF-8"</span>));<span class="hljs-comment">//按照UTF的格式写出</span>        out.flush();        out.close();    &#125;     <span class="hljs-function"><span class="hljs-keyword">private</span> MiaoshaUser <span class="hljs-title">getUser</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;        String paramToken = request.getParameter(MiaoshaUserService.COOKI_NAME_TOKEN);        String cookieToken = getCookieValue(request, MiaoshaUserService.COOKI_NAME_TOKEN);        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken;        <span class="hljs-keyword">return</span> userService.getByToken(response, token);    &#125;     <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getCookieValue</span><span class="hljs-params">(HttpServletRequest request, String cookiName)</span> </span>&#123;        Cookie[]  cookies = request.getCookies();        <span class="hljs-keyword">if</span>(cookies == <span class="hljs-keyword">null</span> || cookies.length &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">for</span>(Cookie cookie : cookies) &#123;            <span class="hljs-keyword">if</span>(cookie.getName().equals(cookiName)) &#123;                <span class="hljs-keyword">return</span> cookie.getValue();            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125; &#125;</code></pre><p>注册拦截器</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span></span>&#123;     <span class="hljs-meta">@Autowired</span>    UserArgumentResolver userArgumentResolver;    <span class="hljs-comment">//注册</span>    <span class="hljs-meta">@Autowired</span>    AccessInterceptor accessInterceptor;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addArgumentResolvers</span><span class="hljs-params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;        argumentResolvers.add(userArgumentResolver);    &#125;    <span class="hljs-comment">//把拦截器注册到WebConfig</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;        registry.addInterceptor(accessInterceptor);    &#125; &#125;</code></pre><h4 id="7-5-前端优化"><a href="#7-5-前端优化" class="headerlink" title="7.5 前端优化"></a>7.5 前端优化</h4><p>不到时间，秒杀按钮不可以点击，都是灰色的。但是HTTP是以明文传输的，这种只能防普通人，真有人想看地址，还是可以看到的。这种只防君子，不防小人，真正的<strong>安全性判断</strong>，还是应该放在服务端</p><h2 id="8-压测对比"><a href="#8-压测对比" class="headerlink" title="8 压测对比"></a>8 压测对比</h2><h3 id="8-1-优化前压测"><a href="#8-1-优化前压测" class="headerlink" title="8.1 优化前压测"></a>8.1 优化前压测</h3><p>项目一有压测结果，吞吐量在1000左右</p><h3 id="8-2-优化后压测"><a href="#8-2-优化后压测" class="headerlink" title="8.2 优化后压测"></a>8.2 优化后压测</h3><p>压测参数：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626170346.png" srcset="/img/loading.gif" alt="image-20200626170343575"></p><p>压测结果以及硬件配置：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626170927.png" srcset="/img/loading.gif" alt="image-20200626170923470"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1：服务器QPS一直上不去：本地QPS可以达到1500+，服务器只有几十。怀疑是服务器带宽太小。看了一下，的确如此</p><blockquote><p><a href="https://blog.csdn.net/mian_CSDN/article/details/78995304?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/mian_CSDN/article/details/78995304?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200625214043.png" srcset="/img/loading.gif" alt="image-20200625214040437"></p><p>2：运行jar包时，一直报错，删了tomcat的embed文件夹看看</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626093106.png" srcset="/img/loading.gif" alt="image-20200626093102146"></p><p>解决方案：端口被占用了，关闭这个进程</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626093804.png" srcset="/img/loading.gif" alt="image-20200626093800898"></p><p><a href="https://jingyan.baidu.com/article/a17d5285d1b03c8099c8f26a.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/a17d5285d1b03c8099c8f26a.html</a></p><p>3：为什么使用谷歌和火狐浏览器访问地址，会出现不一样的响应结果：</p><p>其中火狐出现的页面时正常页面，谷歌这个页面很奇怪啊。。。每次都会提示不同的错误</p><p>谷歌：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626162931.png" srcset="/img/loading.gif" alt="image-20200626162928457"></p><p>火狐：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626162704.png" srcset="/img/loading.gif" alt="image-20200626162701665"></p><p>解决方案：请了一下谷歌浏览器的缓存就OK了</p><p>3：为啥我的压测，数据库里面的数据没有变过？</p><p>第一次怀疑可能是因为我的token没有放到redis中</p><p><a href="https://blog.csdn.net/Serena0814/article/details/89648174" target="_blank" rel="noopener">https://blog.csdn.net/Serena0814/article/details/89648174</a></p><p>解决方案：很奇怪，我把请求方式从POST改成GET，再从GET改成POST，就可以了，下面是秒杀结果图结果。但是我把数据库中数据恢复到原来值时，发现秒杀再次失败，数据库中的值没有任何改动</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626205851.png" srcset="/img/loading.gif" alt="image-20200626205846234"></p><p>3.1 为什么我一运行SpringBoot，他就会自动给我生成秒杀订单？而且是自己生成用户。IDEA报错是，有重复的键插入。</p><p>答案：这个错误是说明，有多个用户正在重复秒杀，所以报错，也就是说代码没有问题</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626211821.png" srcset="/img/loading.gif" alt="image-20200626211818083"></p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626212118.png" srcset="/img/loading.gif" alt="image-20200626212115541"></p><p>4：为啥我启动miaosha_6这个包，数据库就会自动生成对应的秒杀用户和订单，我还没有开始秒杀啊！</p><p>再次运行，就会报错，提示我数据库中已经有相同的数据，不可以再次插入相同数据，问题是我只是启动了springboot啊，还没有开始插入数据，这数据从哪里来的？</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200626204447.png" srcset="/img/loading.gif" alt="image-20200626204444103"></p><p>解决方案：这个包问题，重新解压这个包，用新的代码跑</p><p>5：为什么我每次运行IDEA，压测时看不到消息队列的接受信息，只能看到发送信息，再次启动时，才可以看到接受信息？</p><p>第一次启动，压测时只有发送信息：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200627092425.png" srcset="/img/loading.gif" alt="image-20200627092422400"></p><p>再次启动才有接受信息：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200627092447.png" srcset="/img/loading.gif" alt=""></p><p>5：使用miaosha_5跑压测，一切正常，使用6，各种报错，问题见6</p><p>6：加入redis后，明明已经有了库存判断，但是redis还是会为负数，而且修改后的商品数量也不会写到数据库中，为什么？</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200627092646.png" srcset="/img/loading.gif" alt="image-20200627092643358"></p><p>7：解决方案：</p><p>修改消息队列的消费者大小：把下面两个参数调大以后，上面的问题，基本不会出现。<strong>但是Redis里面的库存还是为负数，虽然数据库里面的值都大于0</strong></p><pre><code class="hljs properties"><span class="hljs-meta">spring.rabbitmq.listener.simple.concurrency</span>= <span class="hljs-string">100</span><span class="hljs-meta">spring.rabbitmq.listener.simple.max-concurrency</span>= <span class="hljs-string">100</span></code></pre><p>结果：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200627095032.png" srcset="/img/loading.gif" alt="image-20200627095027768"></p><p>8：浏览器不同，导致的结果不同：</p><p>解决方案：清空谷歌浏览器缓存即可</p><p>谷歌：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200627130027.png" srcset="/img/loading.gif" alt=""></p><p>火狐：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200627130042.png" srcset="/img/loading.gif" alt="image-20200627130038404"></p><p>9：总结经验：</p><p>清空一下redis缓存、浏览器缓存、消息队列、重新运行，这四步可以解决80%的问题</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code class="hljs xml">#thymeleafspring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.htmlspring.thymeleaf.cache=falsespring.thymeleaf.content-type=text/htmlspring.thymeleaf.enabled=truespring.thymeleaf.encoding=UTF-8spring.thymeleaf.mode=HTML5#是否开启缓存pageCache.enbale=true   #打印mybatis sqllog4j.logger.com.ibatis=DEBUGlog4j.logger.com.ibatis.common.jdbc.SimpleDataSource=DEBUGlog4j.logger.com.ibatis.common.jdbc.ScriptRunner=DEBUGlog4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUGlog4j.logger.Java.sql.Connection=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG #mybatismybatis.type-aliases-package=com.geekq.miaosha.domain#开启驼峰转换 configuration config-location 不能同時存在 如果要走流程 请 放开注释mybatis.configuration.map-underscore-to-camel-case=true#mybatis.mapperLocations = classpath:com/geekq/miaosha/dao/*.xml mybatis.mapperLocations=classpath:mybatis/mapper/*.xml#配置xml方式 因为与 mybatis.configuration.map-underscore-to-camel-case 仅用于测试#mybatis.config-location=classpath:mybatis/mybatis-config.xml #add mybatismybatis.#datasourcespring.datasource.url=jdbc:mysql://localhost:3306/miaosha?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driver#druidspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.filters=statspring.datasource.maxActive=100spring.datasource.initialSize=100spring.datasource.maxWait=600spring.datasource.minIdle=50spring.datasource.timeBetweenEvictionRunsMillis=60000spring.datasource.minEvictableIdleTimeMillis=300000spring.datasource.validationQuery=select 'x'spring.datasource.testWhileIdle=truespring.datasource.testOnBorrow=falsespring.datasource.testOnReturn=falsespring.datasource.poolPreparedStatements=truespring.datasource.maxOpenPreparedStatements=20#static,spring对静态资源的处理spring.resources.add-mappings=truespring.resources.cache-period= 3600spring.resources.chain.cache=truespring.resources.chain.enabled=truespring.resources.chain.gzipped=truespring.resources.chain.html-application-cache=truespring.resources.static-locations=classpath:/static/#redis#redis.host=127.0.0.1redis.host=39.100.103.243redis.port=6379redis.timeout=100redis.password=123456redis.poolMaxTotal=1000redis.poolMaxIdle=500redis.poolMaxWait=500#server.port=8003 #rabbitmqspring.rabbitmq.host=127.0.0.1spring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.virtual-host=/spring.rabbitmq.listener.simple.concurrency= 100spring.rabbitmq.listener.simple.max-concurrency= 100spring.rabbitmq.listener.simple.prefetch= 1spring.rabbitmq.listener.simple.auto-startup=truespring.rabbitmq.listener.simple.default-requeue-rejected= truespring.rabbitmq.template.retry.enabled=truespring.rabbitmq.template.retry.initial-interval=1000spring.rabbitmq.template.retry.max-attempts=3spring.rabbitmq.template.retry.max-interval=10000spring.rabbitmq.template.retry.multiplier=1.0spring.rabbitmq.publisher-confirms=truespring.rabbitmq.listener.direct.acknowledge-mode=manualspring.rabbitmq.listener.simple.acknowledge-mode=manual ## maven隔离#spring.profiles.active=dev</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>秒杀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复习资料</title>
    <link href="/2020/06/21/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    <url>/2020/06/21/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/</url>
    
    <content type="html"><![CDATA[<h1 id="复习资料"><a href="#复习资料" class="headerlink" title="复习资料"></a>复习资料</h1><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><a href="https://mp.weixin.qq.com/s/v1RBxtoevdAjXb4NyBxcsQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/v1RBxtoevdAjXb4NyBxcsQ</a></p><p><a href="https://www.nowcoder.com/discuss/442414" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/442414</a></p><p><a href="https://zhuanlan.zhihu.com/p/90936222" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/90936222</a></p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h3><p>Java基础概念：<a href="https://blog.csdn.net/cheidou123/article/details/95041367" target="_blank" rel="noopener">https://blog.csdn.net/cheidou123/article/details/95041367</a></p><p>Object类有哪些方法？各有什么作用：<a href="https://www.cnblogs.com/u013533289/p/11754461.html" target="_blank" rel="noopener">https://www.cnblogs.com/u013533289/p/11754461.html</a></p><p>String a=new String(“a”)创建几个对象：<a href="https://blog.csdn.net/yishao_20140413/article/details/23598113" target="_blank" rel="noopener">https://blog.csdn.net/yishao_20140413/article/details/23598113</a></p><h3 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h3><p>Volatile：<a href="https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg</a></p><p>守护线程和本地线程的区别：<a href="https://www.cnblogs.com/guoyu1/p/12161692.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoyu1/p/12161692.html</a></p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p><a href="https://zhuanlan.zhihu.com/p/34426768" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34426768</a></p><p>类加载：</p><p>内存结构：</p><p>GC算法 垃圾回收：</p><p>JVM调优 命令调优：</p><p>垃圾收集器：G1、CMS</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>91道MySQL面试题和答案：<a href="https://zhuanlan.zhihu.com/p/114993399" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/114993399</a></p><p>索引：<a href="https://zhuanlan.zhihu.com/p/73204847" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73204847</a></p><p>查询语句不同元素（select–from–where–group by–having–order by）执行先后顺序：<a href="https://www.cnblogs.com/mark5/p/11078361.html" target="_blank" rel="noopener">https://www.cnblogs.com/mark5/p/11078361.html</a></p><p>非关系型数据库和关系型数据库区别：<a href="https://www.zhihu.com/question/24225007/answer/257969925" target="_blank" rel="noopener">https://www.zhihu.com/question/24225007/answer/257969925</a></p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis 基础篇笔记：<a href="https://www.nowcoder.com/discuss/442561?type=5&amp;channel=2000&amp;source_id=discuss_terminal_discuss_hot" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/442561?type=5&amp;channel=2000&amp;source_id=discuss_terminal_discuss_hot</a></p><h2 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h2><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>linux命令：<a href="https://mp.weixin.qq.com/s/7bSwKiPmtJbs7FtRWZZqpA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/7bSwKiPmtJbs7FtRWZZqpA</a></p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>如何实现UDP的可靠传输：<a href="https://www.jianshu.com/p/6c73a4585eba" target="_blank" rel="noopener">https://www.jianshu.com/p/6c73a4585eba</a></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>排序算法</p><p>给定rand5（），实现一个方法rand7（）：<a href="https://zhuanlan.zhihu.com/p/59591972" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59591972</a></p><p>布隆过滤器：<a href="https://zhuanlan.zhihu.com/p/72378274" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/72378274</a></p><p>跳表：<a href="https://zhuanlan.zhihu.com/p/53975333" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53975333</a></p>]]></content>
    
    
    <categories>
      
      <category>复习大纲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>问题总结</title>
    <link href="/2020/06/21/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/06/21/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2>]]></content>
    
    
    <categories>
      
      <category>复习大纲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试出现的算法题</title>
    <link href="/2020/06/21/%E9%9D%A2%E8%AF%95%E5%87%BA%E7%8E%B0%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2020/06/21/%E9%9D%A2%E8%AF%95%E5%87%BA%E7%8E%B0%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="各公司出现过的面试算法题"><a href="#各公司出现过的面试算法题" class="headerlink" title="各公司出现过的面试算法题"></a>各公司出现过的面试算法题</h1><h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><p>1：相邻的单链表翻转</p><p>2：找出唯一一个只出现过一次的数字。</p><p>3：找零的最小方案：给一些特定的零钱，输出张数最小的方案。</p><p>4：一个数，奇数+1，偶数减半，直到最后为1，一共操作了几次。</p><p>5：根据五子棋盘上的点的位置，找出所有子是否落在两条线上x=a,y=b，若有多条线，输出最小a*1000+b的组合</p><p>6：小兔的棋盘</p><p>7：寻找迷宫中的最短路径，迷宫中1表示有墙，路不通，0表示可以走</p><p>8：LeetCode 76. Minimum Window Substring. Hard</p><p>9：leetcode原题 接雨水</p><p>10：设计一个函数能把给定数组的顺序完全随机打乱</p><p>11：给定一个拼手气红包总金额s 和 红包个数n 设计一个函数要求返回一个长度为n的数组代表n个金额随机的红包</p><h2 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h2><p>两个排序的数组求并集</p><p>之字打印二叉树</p><h2 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h2><p>输入一个01序列，输出每个点离最近的1的距离</p><h2 id="拼多多"><a href="#拼多多" class="headerlink" title="拼多多"></a>拼多多</h2><p>翻转数字，如123变成321，-123变成-321，210变成12这种</p><p>两个有序数组的合并，a数组足够大，能放下a和b两个数组里的数字</p><h2 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h2><p>给你个二叉树后序遍历你能反序列成一棵树吗？那你写代码吧，假设你已经存了每个点的深度和一个后续遍历序列</p><h2 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h2><p>二叉树的最长距离（递归的思想）</p><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><p>100亿个数找最大1000个：<strong>局部淘汰法</strong>。用一个容器保存前10000个数，然后将剩余的所有数字一一与容器内的最小数字相比。容器可以用（小顶堆）最小堆来实现</p><h2 id="银行"><a href="#银行" class="headerlink" title="银行"></a>银行</h2><p>最长连续子序列的和</p>]]></content>
    
    
    <categories>
      
      <category>复习大纲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2020/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="1-五层网络模型"><a href="#1-五层网络模型" class="headerlink" title="1 五层网络模型"></a>1 五层网络模型</h3><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200527223109.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528101732.png" srcset="/img/loading.gif" alt="image-20200528101728248"></p><p>作用</p><blockquote><ul><li><strong>1. 应用层</strong></li></ul><p>应用层（application-layer）的任务是通过<strong>应用进程间的交互来完成特定网络应用</strong>。应用层协议定义的是<strong>应用进程（进程：主机中正在运行的程序）间的通信和交互的规则</strong>。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为<strong>报文</strong>。</p><ul><li><strong>2. 运输层</strong></li></ul><p>运输层（transport layer）的主要任务就是负责<strong>向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。<strong>运输层为它上面的应用层提供通信服务。</strong></p><p>传输层两大重要的功能：复用 和 分用。<br>1.<strong>复用</strong>：在发送端，多个应用进程公用一个传输层；<br>2.<strong>分用</strong>：在接收端，传输层会根据端口号将数据分派给不同的应用进程。</p><ul><li><strong>3. 网络层</strong></li></ul><p>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， <strong>确保数据及时传送</strong>。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP / IP 体系结构中，由于<strong>网络层使用 IP</strong> 协议，因此分组也叫 <strong>IP 数据报</strong>，简称数据报。</p><ul><li><strong>4. 数据链路层</strong></li></ul><p>数据链路层（data link layer）链路是一个结点到另一个结点之间的<strong>物理线路</strong>，而中间没有其他交换结点。当传输数据时，还需要一些必要的<strong>通信协议</strong>来控制数据传输。因此，<strong>链路</strong>加上<strong>通信协议</strong>就是数据链路。</p><p>帧：数据链路层的协议数据单元为<strong>帧</strong>。数据链路层将网络层下发的<strong>IP数据报</strong>封装成帧。</p><ul><li><strong>5. 物理层</strong></li></ul><p>在物理层上所传送的数据单位是比特。物理层（physical layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p></blockquote><h4 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h4><p>应用层的任务是通过应用程序间的交互完成特定网络应用。</p><p>应用层协议定义的是应用进程之间的通信和交互规则，对于<strong>不同的网络应用需要不同的应用层协议</strong>。</p><p>常见的应用层协议有：DNS,HTTP,HTTPS,SMTP等</p><h5 id="1-1-1-DNS"><a href="#1-1-1-DNS" class="headerlink" title="1.1.1 DNS"></a>1.1.1 DNS</h5><p>DNS：域名解析系统，可以将域名映射成IP地址，使人更加方便的访问互联网</p><h5 id="1-1-2-HTTP（1-1）"><a href="#1-1-2-HTTP（1-1）" class="headerlink" title="1.1.2 HTTP（1.1）"></a>1.1.2 HTTP（1.1）</h5><p>HTTP：<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol，超文本传输协议。</p><h6 id="1-1-2-1-超文本"><a href="#1-1-2-1-超文本" class="headerlink" title="1.1.2.1 超文本"></a>1.1.2.1 超文本</h6><blockquote><p>早期文本指的是简单的字符文字，现在文本的含义已经扩展到图片、视频、压缩包等</p><p>超文本顾名思义：用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。HTML就是最常见的超文本，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等链接，经过浏览器解释，最终呈现出一个网页</p></blockquote><h6 id="1-1-2-2-传输"><a href="#1-1-2-2-传输" class="headerlink" title="1.1.2.2 传输"></a>1.1.2.2 传输</h6><blockquote><p>HTTP是一个专门在两点之间传输数据的<strong>双向协议</strong>。</p><p>这个两点可以是从互联网服务器到本地浏览器，也可以是服务器到服务器</p></blockquote><h6 id="1-1-2-3-状态码"><a href="#1-1-2-3-状态码" class="headerlink" title="1.1.2.3 状态码"></a>1.1.2.3 状态码</h6><blockquote><p>1XX：提示信息，目前是协议处理的中间状态，还需要后续操作</p><p>​        100：请求者应当<strong>继续</strong>提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</p><p>​        101：请求者已要求服务器<strong>切换协议</strong>，服务器已确认并准备切换</p><p>​        102：由WebDAV（RFC 2518）扩展的状态码，代表处理将被<strong>继续执行</strong>。</p><p>2XX：成功，报文已经收到并被正确处理</p><p>​        200 OK：最常见的成功状态码，表示一切正常</p><p>​        201：请求成功并且服务器创建了新的资源。</p><p>​        202：服务器已接受请求，但尚未处理。</p><p>​        203：服务器已成功处理了请求，但返回的信息可能来自另一来源。</p><p>​        204 No Content：服务器成功处理了请求，但没有返回任何内容</p><p>​        205：服务器成功处理了请求，但没有返回任何内容。</p><p>​        206 Partial Content：服务器成功处理了部分 GET 请求。。应用于HTTP分块下载或断电续传，表示响应返回的body数据并不是资源的全部，而是其中的一部分</p><p>3XX：重定向，资源发生变动，需要客户端重新发送请求。后续的请求地址（重定向目标）在本次响应的 Location 域中指明</p><p>​        301 Moved Permanently：永久重定向，说明请求的资源已经不存在了，需要用新的URL来再次访问</p><p>​        302 Found：临时重定向，说明请求的资源还在，但暂时需要用另一个URL来访问</p><p>​        304 Not Modified：不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称之为缓存重定向，用于缓存控制</p><p>​        301和302都会在响应头里使用字段Location，指明后续要跳转的URL，浏览器会自动重定向新的URL</p><p>4XX：客户端错误，请求的报文有误，服务器无法处理</p><p>​        400 Bad Request：表示客户端请求的报文有错误，服务器不理解请求的语法。</p><p>​        401：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p><p>​        403 Forbidden：表示服务器禁止访问资源，并不是客户端的请求出错</p><p>​        404 Not Found：请求的资源在服务器上不存在或者找不到，所以无法提供给客户端</p><p>​        405：禁用请求中指定的方法。</p><p>​        408：服务器等候请求时发生超时</p><p>​        410：如果请求的资源已永久删除，服务器就会返回此响应</p><p>​        414：请求的 URI（通常为网址）过长，服务器无法处理       </p><p>5XX：服务器错误，服务器处理请求时内部发生了错误</p><p>​        500 Internal Server Error：与400类似，一个笼统的错误码，具体原因不清楚</p><p>​        501 Not Implemented：客户端请求的功能还不支持</p><p>​        502 Bad GateWay：服务器自身工作正常，访问后端服务器发生了错误。通常是服务器作为网关或代理时返回的错误码</p><p>​        503 Service Unavailable：服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</p><p>​        504：服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p><p>​        505：服务器不支持请求中所用的 HTTP 协议版本。</p></blockquote><h6 id="1-1-2-4-常见字段"><a href="#1-1-2-4-常见字段" class="headerlink" title="1.1.2.4 常见字段"></a>1.1.2.4 常见字段</h6><p>Host</p><blockquote><p>客户端发送请求时，用来指定服务器的域名。如：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p></blockquote><p>Content-Length</p><blockquote><p>本次回应的数据长度（单位是字节）</p></blockquote><p>Connection</p><blockquote><p>最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。</p><p>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code></p><p>一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。</p></blockquote><p>Content-Type</p><blockquote><p>用于服务器回应时，告诉客户端，本次数据是什么格式</p><p>Content-Type: text/html; charset=utf-8</p><p>发送的是网页，编码格式是UTF-8</p><p>客户端请求时，可以使用Accept字段声明自己可以接受哪些数据格式</p></blockquote><p>Content-Encoding</p><blockquote><p>说明数据的压缩方法，表示服务器返回的数据使用了什么压缩格式</p><p>Content-Encoding: gzip</p><p>客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法。</p><p>Accept-Encoding: gzip, deflate</p></blockquote><h6 id="1-1-2-5-Get和Post的区别"><a href="#1-1-2-5-Get和Post的区别" class="headerlink" title="1.1.2.5 Get和Post的区别"></a>1.1.2.5 Get和Post的区别</h6><p>Get和Post都是HTTP协议中的两种发送请求的方法</p><blockquote><p><strong>GET 和 POST 方法没有实质区别</strong>，只是报文格式不同</p><p>GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议，无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。</p></blockquote><p>Get</p><blockquote><p>对数据长度有限制，发送数据时，GET方法向URL添加数据，URL的长度是受限制的（最大2048个字节）</p><ul><li>HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。</li></ul><p>对数据的类型有限制，只允许ASCII字符</p><p>安全性较差，以明文的方式发送数据。</p><p>发送的数据在URL中，所有人都可见</p></blockquote><p>Post</p><blockquote><p>对数据长度无限制</p><p>对数据的类型没有限制</p><p>比GET安全，发送的数据不会被保存在浏览器历史或web服务器日志中</p><p>发送的数据不会显示在URL中</p></blockquote><p>从标准上看，区别是：</p><blockquote><p>GET 用于获取信息，是无副作用的，是幂等的，且可缓存</p><ul><li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</li></ul><p>POST 用于修改服务器上的数据，有副作用，非幂等，不可缓存</p><ul><li><p><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。</p></li><li><p>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</p></li><li><p>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的</p></li></ul></blockquote><p>参数</p><blockquote><p>GET 方法参数写法：在约定中，我们的参数是写在 <code>?</code> 后面，用 <code>&amp;</code> 分割</p></blockquote><p>安全性</p><blockquote><p>按照网上大部分文章的解释，POST 比 GET 安全，因为数据在地址栏上不可见。</p><p>然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。</p><p>要想安全传输，就只有加密，也就是 HTTPS。</p></blockquote><h6 id="1-1-2-6-特性"><a href="#1-1-2-6-特性" class="headerlink" title="1.1.2.6 特性"></a>1.1.2.6 特性</h6><p>HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。</p><p>简单</p><blockquote><p>HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，<strong>易于理解</strong>，降低了学习和使用的门槛。</p></blockquote><p>灵活和易于扩展</p><blockquote><p>HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</p><p>同时 HTTP 由于是工作在应用层（ <code>OSI</code> 第七层），则它<strong>下层可以随意变化</strong>。</p><p>HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC。</p></blockquote><p>应用广泛和跨平台</p><blockquote><p>HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，HTTP 的应用<strong>片地开花</strong>，同时天然具有<strong>跨平台</strong>的优越性。</p></blockquote><p>缺点是无状态、明文传输，不安全。</p><p>无状态</p><blockquote><p>服务器不需要记录HTTP的状态，减轻了服务器的负担。但是另一方面，服务器没有记录状态，导致后续在关联性操作时会很麻烦</p><p>解决方法：Cookie技术</p><p>Cookie通过在请求和响应报文中加入Cookie信息来控制客户端的状态</p></blockquote><p>明文传输</p><blockquote><p>明文传输导致信息很容易被窃取，如果有账号和密码等重要信息，被窃取后会产生巨大损失</p></blockquote><p>不安全</p><blockquote><p>通信使用明文：内容会被窃取</p><p>不验证通信方的身份：可能遇到虚假的通信方</p><p>无法证明报文的完整性：报文可能会被篡改</p><p>解决方案：HTTPS，引入SSL/TLS层</p></blockquote><h6 id="1-1-2-7-性能"><a href="#1-1-2-7-性能" class="headerlink" title="1.1.2.7 性能"></a>1.1.2.7 性能</h6><p>HTTP 协议是基于 <strong>TCP/IP</strong>，并且使用了「<strong>请求 - 应答</strong>」的通信模式，所以性能的关键就在这<strong>两点</strong>里。</p><p>长连接</p><blockquote><p>早起的HTTP(1.0)主要的性能问题就是每发起一次请求，都会建立起一次TCP连接，服务器响应完毕后立即断开连接。多了很多额外的TCP连接建立和断开，增加通信开销</p><p>解决方法：HTTP（1.1）提出了长连接的概念，好处是减少了多余的TCP建立的重复建立和断开造成的额外开销，降低了服务器的负担</p><p>长连接（持久连接）特点：如果任意一方没有明确要求断开连接，则会一直保持连接状态</p></blockquote><p>管道网络传输</p><blockquote><p>长连接的建立，使得管道网络传输成为可能。即在同一个TCP连接中，客户端可以发起多个请求，只要第一个请求发出去了，不必等待其回来，就可以发送第二请求，减少了整体响应时间</p><p>但是可能会产生对头阻塞：因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据。</p></blockquote><h6 id="1-1-2-8-方法"><a href="#1-1-2-8-方法" class="headerlink" title="1.1.2.8 方法"></a>1.1.2.8 方法</h6><blockquote><p>GET：获取资源，当前网络中绝大部分使用的都是 GET；</p><p>HEAD：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分；</p><p>POST：传输实体主体</p><p>PUT：上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><p>PATCH：对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p><p>OPTIONS：查询指定的 URL 支持的方法；</p><p>CONNECT：要求在与代理服务器通信时建立隧道。使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><p>TRACE：追踪路径。服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p></blockquote><h5 id="1-1-3-HTTPS"><a href="#1-1-3-HTTPS" class="headerlink" title="1.1.3 HTTPS"></a>1.1.3 HTTPS</h5><h6 id="1-1-3-1-与HTTP的区别"><a href="#1-1-3-1-与HTTP的区别" class="headerlink" title="1.1.3.1 与HTTP的区别"></a>1.1.3.1 与HTTP的区别</h6><blockquote><p>安全上：HTTPS在TCPHTTP网络层直接加了SSL/TLS安全协议，使得报文能够加密传输</p><p>连接建立：HTTP只需要TCP三次握手建立连接后就可以传输，而HTTPS在TCP三次握手之后，还需要进行SSL/TLS握手，才可以进行加密报文传输</p><p>端口号：HTTP是80，HTTPS是443</p><p>HTTPS还需要向CA申请数字证书，保证服务器的身份</p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528092612.png" srcset="/img/loading.gif" alt="image-20200528092605901"></p><p>HTTP 由于是明文传输，所以安全上存在以下三个风险</p><blockquote><ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li><li><strong>篡改风险</strong>，比如强制入垃圾广告，视觉污染，用户眼容易瞎。</li><li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li></ul></blockquote><p>HTTPS解决了这三个问题</p><blockquote><ul><li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li><li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li><li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li></ul></blockquote><p>解决方法</p><blockquote><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li></ul></blockquote><h6 id="1-1-3-2-混合加密"><a href="#1-1-3-2-混合加密" class="headerlink" title="1.1.3.2 混合加密"></a>1.1.3.2 混合加密</h6><p>HTTPS采用的是对称加密和非对称加密结合的混合加密</p><ul><li><p>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</p></li><li><p>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据</p></li></ul><p>采用「混合加密」的方式的原因：</p><ul><li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528093256.png" srcset="/img/loading.gif" alt="image-20200528093251931"></p><h6 id="1-1-3-3-摘要算法"><a href="#1-1-3-3-摘要算法" class="headerlink" title="1.1.3.3 摘要算法"></a>1.1.3.3 摘要算法</h6><p><strong>摘要算法</strong>用来实现<strong>完整性</strong>，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528093357.png" srcset="/img/loading.gif" alt="image-20200528093353346"></p><p>用户在发送前，先用摘要算法编码一下明文，得到摘要，然后把明文和摘要一起发送过去，客户端得到明文和摘要后，再用相同的摘要算法，编码一下明文，得到的摘要和发送过来的摘要进行对比，两者相同，就说明数据是完整的</p><h6 id="1-1-3-4-数字证书"><a href="#1-1-3-4-数字证书" class="headerlink" title="1.1.3.4 数字证书"></a>1.1.3.4 数字证书</h6><p>客户端先向服务端索取公钥，然后用公钥加密信息，服务器收到信息后，再用私钥解密。但是公钥可能被篡改。</p><p>解决方法是将服务器公钥放在数字证书中（由CA颁发），只要证书是可信的，公钥就是可信的</p><h6 id="1-1-3-5-建立连接"><a href="#1-1-3-5-建立连接" class="headerlink" title="1.1.3.5 建立连接"></a>1.1.3.5 建立连接</h6><p>SSL/TLS协议基本流程</p><blockquote><p>客户端向服务器索要并验证服务器的公钥</p><p>双方协商产生会话秘钥</p><p>双方采用会话秘钥进行加密通信</p></blockquote><h6 id="1-1-3-6-HTTP的演变"><a href="#1-1-3-6-HTTP的演变" class="headerlink" title="1.1.3.6 HTTP的演变"></a><strong>1.1.3.6 HTTP的演变</strong></h6><p><strong>HTTP/1.1相较于HTTP/1.0的改进</strong></p><blockquote><p>使用了长连接，改善了1.0的短连接造成的性能开销</p><p>支持管道网络传输</p></blockquote><p><strong>HTTP/1.1的缺点</strong></p><blockquote><p><strong>请求/响应头未经压缩就发送，信息越多，延迟越大</strong></p><p><strong>发送冗长的首部，每次发送相同的首部浪费资源</strong></p><p><strong>服务器是按照请求的顺序响应的，容易发生对头阻塞</strong></p><p><strong>没有请求优先级控制</strong></p><p><strong>请求只能从客户端开始，服务端只能被动响应</strong></p></blockquote><p><strong>HTTP/2相较于HTTP/1.1的改进</strong></p><blockquote><p><strong>HTTP/2 协议是基于 HTTPS 的，所以HTTP/2保证了安全性</strong></p><p>头部压缩：如果<strong>同时发出多个请求，头是一样的，那么协议会帮助你相除重复部</strong>分（HPACK算法，客户端和服务端会维护一个头信息表，字段都会存入这个表中，并且生成一个索引号，以后就不送相同的字段了，只发送索引号，提高了速度）</p><p>二进制格式：HTTP/2采用了二进制格式，头信息和数据体都是二进制，并且统称为帧：头信息帧和数据帧。收到报文后无需转成二进制，直接解析二进制即可，提高传输效率</p><p><em>数据流</em>：HTTP/2的数据包不是按照顺序发送的，所以需要对数据包做标记，指出属于哪个响应。客户端发出的数据包编号为奇数，服务端为偶数。<strong>客户端可以指定数据流的优先级，优先级高的请求，服务端优先响应</strong></p><p>多路复用：HTTP/2可以<strong>在一个连接中并发多个请求或者回应</strong>，而不用按照顺序一一对应，<strong>解决了HTTP/1.1的对头阻塞，降低了延迟。</strong></p><p><strong>服务器推送</strong>：服务器不再是被动的响应，也可以主动向客户端发送消息。举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送（Server Push，也叫 Cache Push）。</p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528095532.png" srcset="/img/loading.gif" alt="image-20200528095528025"></p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528095758.png" srcset="/img/loading.gif" alt="image-20200528095753595"></p><p><strong>HTTP/3相较于HTTP/2的改进</strong></p><blockquote><p>HTTP2的主要问题是：<strong>多个 HTTP 请求在复用一个 TCP 连接</strong>，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p><ul><li><p>HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</p></li><li><p>HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</p><p>这都是基于 TCP 传输层的问题，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p><p>UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。</p><p>UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p><p>QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP/2 的多路复用的协议。</p><p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以 HTTP/3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</p><ul><li>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，<strong>其他流不会受到影响</strong>。</li><li>TL3 升级成了最新的 <code>1.3</code> 版本，头部压缩算法也升级成了 <code>QPack</code>。</li><li>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 <code>TLS/1.3</code> 的三次握手。QUIC 直接把以往的 TCP 和 <code>TLS/1.3</code> 的 6 次交互<strong>合并成了 3 次，减少了交互次数</strong>。</li></ul></li></ul></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528100604.png" srcset="/img/loading.gif" alt="image-20200528100559981"></p><h4 id="1-2-传输层"><a href="#1-2-传输层" class="headerlink" title="1.2 传输层"></a>1.2 传输层</h4><h5 id="1-2-1-TCP"><a href="#1-2-1-TCP" class="headerlink" title="1.2.1 TCP"></a>1.2.1 TCP</h5><p>Transmission Control Protocol：传输控制协议。</p><p>TCP是面向链接的，提供可靠交付的，有流量控制，拥塞控制，提供全双工通信，面向字节流的协议。</p><h6 id="1-2-1-1-首部格式"><a href="#1-2-1-1-首部格式" class="headerlink" title="1.2.1.1 首部格式"></a>1.2.1.1 首部格式</h6><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200621094156" srcset="/img/loading.gif" alt="img"></p><blockquote><p>源端口和目的端口：顾名思义，发送数据时的端口号和接受数据的端口号</p><p>序号seq：用于对字节流进行编号，例如序号为500，表示第一个字节的编号为500，如果携带的数据长度为100，那么下一个报文段的序号应该是600</p><p>确认号ack：期望收到的下一个报文段的序号，比如服务端收到客服端发来的一个报文段，序号为500，携带的长度为300，那么服务端期望收到的下一个报文段的序号为800，服务端发送给客户端的确认报文段中的确认号就是800</p><p><strong>数据偏移</strong> 占4位：它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指<strong>出TCP报文段的首部长度</strong>。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的</p><p>控制位：从左到右分别是：CWR,ECE,URG,ACK,PSH,RST,SYN,FIN。</p><p>​    <strong>CWR</strong>：CWR与ECE都用于IP首部的ECN字段，ECE标志为1时，通知对方已将拥塞窗口缩小。</p><p>​    <strong>ECE</strong>：若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1</p><p>​    <strong>URG：</strong>该位设为 1，表示包中有需要紧急处理的数据，它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送</p><p>​    <strong>ACK：</strong>占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。</p><p>​    <strong>PSH：</strong>该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；</p><p>​    <strong>RST：</strong>该位设为 1，表示 TCP 连接出现异常必须强制断开连接；</p><p>​    <strong>SYN：</strong>用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；</p><p>​    当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1，因此SYN置为1就表示这是一个连接请求或连接接受报文。</p><p>​    <strong>FIN：</strong>该位设为 1，表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段</p><p>每个主机又对对方的 FIN 包进行确认应答之后可以断开连接。不过，主机收到 FIN 设置为 1 的 TCP 段之后不必马上回复一个 FIN 包，而是可以等到缓冲区中的所有数据都因为已成功发送而被自动删除之后再发 FIN 包；</p><p><strong>窗口：</strong>窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。</p><p>​    <strong>窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化</strong>。</p><p><strong>检验和</strong>    占2字节。检验和字段检验的范围包括首部和数据这两部分，和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部</p><p>紧急指针  占2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可以发送紧急数据。</p><p><strong>选项</strong>：长度可变，最长可达4字节。当没有使用“选项”时，TCP的首部长度是20字节。</p><p>​    TCP最初只规定了一种选项，即最大报文段长度MSS（Maximum Segment Szie）。注意MSS这个名词含义。MSS是每一个TCP报文段中的<strong>数据字段的最大长度</strong>。数据字段加上TCP首部才等于整个的TCP报文段。所以MSS并不是整个TCP报文段的最大长度，而是“TCP报文段长度减去TCP首部长度”。</p><p>为什么要规定一个最大报文长度MSS呢？这并不是考虑接受方的接收缓存可能存放不下TCP报文段中的数据。实际上，MSS与接收窗口值没有关系。我们知道，TCP报文段的数据部分，<strong>至少要加上40字节的首部</strong>（TCP首部20字节和IP首部20字节，这里还没有考虑首部中的可选部分）<strong>才能组装成一个IP数据报</strong>。若选择较小的MSS长度，网络的利用率就降低。设想在极端情况下，当TCP报文段只含有1字节的数据时，在IP层传输的数据报的开销至少有40字节（包括TCP报文段的首部和IP数据报的首部）。这样，对网络的利用率就不会超过1/41。到了数据链路层还要加上一些开销。但反过来，若TCP报文段非常长，那么在IP层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片组成成原来的TCP报文段，当传输出错时还要进行重传，这些也都会使开销增大。</p><p>​    <strong>因此，MSS应尽可能大些</strong></p></blockquote><h6 id="1-2-1-2-三次握手"><a href="#1-2-1-2-三次握手" class="headerlink" title="1.2.1.2 三次握手"></a>1.2.1.2 三次握手</h6><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528113912.png" srcset="/img/loading.gif" alt="image-20200528113908791"></p><blockquote><p>假设 A 为客户端，B 为服务器端。</p><p>最初客户端和服务端都处于 CLOSED(关闭) 状态。本例中 A（Client） 主动打开连接，B（Server） 被动打开连接。</p><p>第一次握手：A 的 TCP 客户端进程也是首先创建传输控制块 TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位 SYN=1，同时选择一个初始序号 seq = x。TCP 规定，SYN 报文段（即 SYN = 1 的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。</p><p>第二次握手：B 收到连接请求报文后，如果同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务端进程进入 SYN-RCVD（同步收到）状态。</p><p>第三次握手：TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y + 1，而自己的序号 seq = x + 1。这时 ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。</p><p>SYN：同步序列编号（Synchronize Sequence Numbers）。</p><p>ack=x+1，这个1是因为SYN占据了一个序列号空间。SYN和FIN虽然不携带数据，但是都要消耗掉一个序号，所以要加1</p></blockquote><p>这里有两个ack，一个是大写的ACK，一个是小写的ack。</p><p>大写的是控制位中的ACK，小写的是确认号。</p><p>大写的ACK：TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1</p><p>小写的ack：接收到的上一次远端主机传来的seq然后+1，再发送给远端主机。提示远端主机已经成功接收上一次所有数据。</p><p><strong>三次握手的目的</strong></p><blockquote><p>是让客户端和服务端确认对方和自己的发送接受能力都正常</p><p>指定自己的初始化序列号，为后面的可靠传送做准备</p><p>如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到</p></blockquote><p>确认双方的接受能力、发送能力是否正常</p><blockquote><p>第一次握手成功</p><p>​    服务端知道：</p><p>​        客户端的发送能力正常</p><p>​        服务端的接受能力正常</p><p>第二次握手成功</p><p>​    客户端知道：</p><p>​        服务端的发送能力正常，接受能力正常</p><p>​        客户端的发送能力正常，接受能力正常</p><p>第三次握手成功，说明</p><p>​    服务端知道：</p><p>​        客户端的接受能力正常</p><p>​        服务端的发送能力正常</p></blockquote><p><strong>两次握手不可以吗？</strong></p><blockquote><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接</p><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p></blockquote><p><strong>什么是半连接队列？</strong></p><blockquote><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p></blockquote><p><strong>全连接队列</strong></p><blockquote><p>就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p></blockquote><p><strong>ISN是固定的吗？</strong></p><blockquote><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p></blockquote><p><strong>半连接队列</strong></p><blockquote><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><p>这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ….</p></blockquote><p><strong>三次握手过程可以携带数据吗?</strong></p><blockquote><p>第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p><p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。</p></blockquote><p><strong>传了SYN，为什么还要传ACK</strong></p><blockquote><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p></blockquote><h6 id="1-2-1-3-四次挥手"><a href="#1-2-1-3-四次挥手" class="headerlink" title="1.2.1.3 四次挥手"></a>1.2.1.3 四次挥手</h6><p>传输结束后，通信的双方都可以释放连接。现在 A 和 B 都处于 ESTABLISHED 状态</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528133640.png" srcset="/img/loading.gif" alt="image-20200528133637323"></p><blockquote><p>第一次挥手：A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq = u（等于前面已传送过的数据的最后一个字节的序号加 1），这时 A 进入 FIN-WAIT-1（终止等待1）状态，等待 B 的确认。请注意：TCP 规定，FIN 报文段即使不携带数据，也将消耗掉一个序号。</p><p>第二次挥手：B 收到连接释放报文段后立即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v（等于 B 前面已经传送过的数据的最后一个字节的序号加1），然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务端进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。A 收到来自 B 的确认后，就进入 FIN-WAIT-2(终止等待2)状态，等待 B 发出的连接释放报文段。</p><p>第三次挥手：若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。假定 B 的序号为 w（在半关闭状态，B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK(最后确认)状态，等待 A 的确认。</p><p>第四次挥手：A 在收到 B 的连接释放报文后，必须对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack = w + 1，而自己的序号 seq = u + 1（前面发送的 FIN 报文段要消耗一个序号）。然后进入 TIME-WAIT(时间等待) 状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL（MSL：最长报文段寿命）后，A 才能进入到 CLOSED 状态，然后撤销传输控制块，结束这次 TCP 连接。当然如果 B 一收到 A 的确认就进入 CLOSED 状态，然后撤销传输控制块。所以在释放连接时，B 结束 TCP 连接的时间要早于 A。</p></blockquote><p><strong>2MSL等待状态</strong></p><blockquote><p>MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。</p><p><strong>2MSL就是一个发送和一个回复所需的最大时间</strong></p><p>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p><p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP<strong>再次发送最后</strong>的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p></blockquote><p><strong>为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？</strong></p><blockquote><p>1 为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，B 就无法按照正常步骤进入 CLOSED 状态。</p><p>2 防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</p></blockquote><p><strong>为什么建立连接是三次握手，而关闭连接是四次挥手？</strong></p><blockquote><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了</p><p>当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。</p><p>但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p></blockquote><h6 id="1-2-1-4-滑动窗口"><a href="#1-2-1-4-滑动窗口" class="headerlink" title="1.2.1.4  滑动窗口"></a>1.2.1.4  滑动窗口</h6><p>TCP 利用滑动窗口实现流量控制的机制。滑动窗口（Sliding window）是一种流量控制技术</p><p>滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报</p><h6 id="1-2-1-5-TCP如何保证可靠传输"><a href="#1-2-1-5-TCP如何保证可靠传输" class="headerlink" title="1.2.1.5 TCP如何保证可靠传输"></a>1.2.1.5 TCP如何保证可靠传输</h6><p>数据包校验</p><blockquote><p>目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；</p></blockquote><p>对失序数据包重排序</p><blockquote><p>既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；</p></blockquote><p>丢弃重复数据</p><blockquote><p>对于重复数据，能够丢弃重复数据；</p></blockquote><p>超时重发</p><blockquote><p>当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p></blockquote><p>流量控制</p><blockquote><p>TCP 使用的流量控制协议是可变大小的滑动窗口协议。</p><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><p>TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制</p></blockquote><h6 id="1-2-1-6-拥塞控制"><a href="#1-2-1-6-拥塞控制" class="headerlink" title="1.2.1.6 拥塞控制"></a>1.2.1.6 拥塞控制</h6><p>CP 拥塞控制的目标是最大化利用网络上瓶颈链路的带宽。</p><p>拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。</p><p><strong>拥塞控制就是为了防止过多的数据注入到网络中</strong>，这样就可以使网络中的路由器或链路不致于过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p><strong>常见的 TCP 拥塞控制算法</strong>：Linux 内核默认的 Reno 算法</p><p>Reno 被许多教材（例如：《计算机网络——自顶向下的方法》）所介绍，适用于低延时、低带宽的网络，它将拥塞控制的过程分为四个阶段：<strong>慢启动、拥塞避免、快重传和快恢复</strong></p><blockquote><p>慢启动阶段思路是不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小，在没有出现丢包时每收到一个 ACK 就将拥塞窗口大小加一（单位是 MSS，最大单个报文段长度），每轮次发送窗口增加一倍，呈指数增长，若出现丢包，则将拥塞窗口减半，进入拥塞避免阶段；</p><p>当窗口达到慢启动阈值或出现丢包时，进入拥塞避免阶段，窗口每轮次加一，呈线性增长；当收到对一个报文的三个重复的 ACK 时，认为这个报文的下一个报文丢失了，进入快重传阶段，要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认；</p><p>快重传完成后进入快恢复阶段，将慢启动阈值修改为当前拥塞窗口值的一半，同时拥塞窗口值等于慢启动阈值，然后进入拥塞避免阶段，重复上述过程。</p></blockquote><p>慢开始</p><blockquote><p>cwnd：拥塞窗口</p><p>慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</p><p><strong>ssthresh (Slow Start Threshold)，</strong>慢启动的峰值线，一旦超过该峰值线，则进入拥塞避免。</p><p>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：<br>  当cwnd &lt; ssthresh时，使用慢开始算法。<br>  当cwnd &gt; ssthresh时，改用拥塞避免算法。<br>  当cwnd = ssthresh时，慢开始与拥塞避免算法任意。</p></blockquote><p>拥塞避免</p><blockquote><p>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1</p><p>当网络发生拥塞，把ssthresh值更新为此时CWND值的一半如下图24的一半，cwnd重新设置为1。重新执行慢开始算法</p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528145400.png" srcset="/img/loading.gif" alt="image-20200528145357482"></p><p>快重传和快恢复</p><blockquote><p>在 TCP/IP 中，快速重传和快恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。</p><p>没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。</p><p>有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。</p><p>有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和快恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p><p><strong>FRR：冗余 ACK</strong>来处理的。我们都知道，数据包是有序号的，如果A给B发送M1, M2, M3, M4, M5…N个数据包，如果B收到了M1, M2, M4….却始终没有收到M3，这个时候就会重复确认M2，意在告诉A,M3还没收到，可能是丢失。当A连续收到了三个确认M2的ACK，且M3超时事件还没发生。A就知道M3可能丢失了，这个时候A就不必等待M3设置的计时器到期了，而是快速重传M3。并且把ssthresh设置为MAX（此时的cwnd值）的一半，即ssthresh = MAX/2，但是这个时候并非把控制窗口N设置为1，而是让N = ssthresh，N在一个一个增长。</p></blockquote><h6 id="1-2-1-7-对应的应用层协议"><a href="#1-2-1-7-对应的应用层协议" class="headerlink" title="1.2.1.7 对应的应用层协议"></a>1.2.1.7 对应的应用层协议</h6><blockquote><p>FTP：文件传输协议，使用 21 端口</p><p>SMTP：简单邮件传送协议， 25 号端口</p><p>POP3：POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口</p><p>HTTP：从 Web 服务器传输超文本到本地浏览器的传送协议</p><p>Telnet：它是一种用于远程登陆的端口，23端口</p></blockquote><h6 id="1-2-1-8-粘包"><a href="#1-2-1-8-粘包" class="headerlink" title="1.2.1.8 粘包"></a>1.2.1.8 粘包</h6><blockquote><p>客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。</p><p>TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；</p><p>从 TCP 的帧结构也可以看出，在 <strong>TCP 的首部没有表示数据长度的字段。</strong></p><p>基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。</p><p>接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。</p></blockquote><p>粘包产生的原因</p><p>发送方</p><blockquote><p>采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 <strong>Nagle 算法</strong>，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个<strong>合并过程就是在发送缓冲区中进行的</strong>，也就是说<strong>数据发送出来它已经是粘包的状态了</strong>。</p></blockquote><p>接收方</p><blockquote><p>接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置<strong>接收缓冲区</strong>，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的<strong>读取数据函数不能及时的把缓冲区中的数据拿出来</strong>，而下一个数据又到来<strong>并有一部分放入的缓冲区末尾</strong>，等我们<strong>读取数据时就是一个粘包</strong>。（放数据的速度 &gt; 应用层拿数据速度）</p></blockquote><p>解决方法</p><blockquote><p>分包机制一般有两个通用的解决方法：</p><p>特殊字符控制；</p><p>在包头首都添加数据包的长度。</p><p>注意：UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。</p></blockquote><h5 id="1-2-2-UDP"><a href="#1-2-2-UDP" class="headerlink" title="1.2.2 UDP"></a>1.2.2 UDP</h5><h6 id="1-2-2-1-首部格式："><a href="#1-2-2-1-首部格式：" class="headerlink" title="1.2.2.1 首部格式："></a>1.2.2.1 首部格式：</h6><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528150014.png" srcset="/img/loading.gif" alt="image-20200528150012159"></p><blockquote><p>源端口：发送端端口</p><p>目标端口：接收端端口</p><p>包长度：UDP首部长度跟数据长度之和</p><p>校验和：目的是提供可靠的UDP首部和数据</p></blockquote><h6 id="1-2-2-2-特点"><a href="#1-2-2-2-特点" class="headerlink" title="1.2.2.2 特点"></a>1.2.2.2 特点</h6><blockquote><p>UDP 是无连接的；</p><p>UDP 尽最大努力交付，即不保证可靠交付</p><p>UDP 是面向报文的</p><p>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；</p><p>UDP 支持一对一、一对多、多对一和多对多的交互通信；</p><p>UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</p></blockquote><h5 id="1-2-2-3-对应的应用层协议"><a href="#1-2-2-3-对应的应用层协议" class="headerlink" title="1.2.2.3 对应的应用层协议"></a>1.2.2.3 对应的应用层协议</h5><blockquote><p>DNS：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。</p><p>SNMP：简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p><p>TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在端口 69 上使用 UDP 服务。</p></blockquote><h3 id="2-七层网络模型"><a href="#2-七层网络模型" class="headerlink" title="2 七层网络模型"></a>2 七层网络模型</h3><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200527221554.png" srcset="/img/loading.gif" alt="image-20200527221549514"></p><h3 id="3-TCP-IP四层协议"><a href="#3-TCP-IP四层协议" class="headerlink" title="3  TCP/IP四层协议"></a>3  TCP/IP四层协议</h3><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200527223114.png" srcset="/img/loading.gif" alt=""></p><h3 id="4-常见面试题"><a href="#4-常见面试题" class="headerlink" title="4 常见面试题"></a>4 常见面试题</h3><h4 id="4-1-在浏览器中输入-URL-地址到显示主页的过程？"><a href="#4-1-在浏览器中输入-URL-地址到显示主页的过程？" class="headerlink" title="4.1 在浏览器中输入 URL 地址到显示主页的过程？"></a>4.1 在浏览器中输入 URL 地址到显示主页的过程？</h4><p>步骤</p><blockquote><ol><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>发送请求</li><li>处理请求并返回HTTP报文</li><li>渲染页面</li></ol></blockquote><h5 id="4-1-1-URL解析"><a href="#4-1-1-URL解析" class="headerlink" title="4.1.1 URL解析"></a>4.1.1 URL解析</h5><p>URL：Universal Resource Locator 统一资源定位符，俗称网页地址或者网址。</p><p>URL组成</p><blockquote><p>传输协议、服务器、域名、端口、虚拟目录、文件名、参数、锚</p><p>http             www       baidu.com 80</p></blockquote><p>当我们在浏览器输入URL后，浏览器首先对拿到的URL进行识别，抽取出域名字段</p><h5 id="4-1-2-DNS查询"><a href="#4-1-2-DNS查询" class="headerlink" title="4.1.2 DNS查询"></a>4.1.2 DNS查询</h5><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528154631.png" srcset="/img/loading.gif" alt="image-20200528154628623"></p><p>第一步：浏览器缓存</p><blockquote><p>浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询</p></blockquote><p>第二步：操作系统缓存</p><blockquote><p>操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p></blockquote><p>第三步：路由器缓存</p><blockquote><p>路由器也有自己的缓存。</p></blockquote><p>第四步 ISP DNS 缓存</p><blockquote><p>ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p></blockquote><p>第五步 根域名服务器查询</p><blockquote><p>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：</p><p>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地DNS服务器的过程）</p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528154927.png" srcset="/img/loading.gif" alt="image-20200528154924741"></p><h5 id="4-1-3-TCP连接"><a href="#4-1-3-TCP连接" class="headerlink" title="4.1.3 TCP连接"></a>4.1.3 TCP连接</h5><p>主机浏览器通过DNS解析得到了目标服务器的IP地址后，与服务器建立TCP连接。</p><p>连接成功后，客户端向服务端发送请求。</p><h5 id="4-1-4-浏览器通过http协议发送请求"><a href="#4-1-4-浏览器通过http协议发送请求" class="headerlink" title="4.1.4 浏览器通过http协议发送请求"></a>4.1.4 <strong>浏览器通过http协议发送请求</strong></h5><p>TCP/IP分为五层，发送数据时，每层都要对数据进行封装，物理层传输bit。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528155151.png" srcset="/img/loading.gif" alt="image-20200528155148409"></p><h6 id="4-1-4-1-应用层：发送HTTP请求"><a href="#4-1-4-1-应用层：发送HTTP请求" class="headerlink" title="4.1.4.1 应用层：发送HTTP请求"></a>4.1.4.1 应用层：发送HTTP请求</h6><p>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p><ul><li>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等</li><li>请求主体（其他参数）</li></ul><p>其中需要注意的点：</p><ul><li>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</li></ul><h6 id="4-1-4-2-传输层：TCP传输报文"><a href="#4-1-4-2-传输层：TCP传输报文" class="headerlink" title="4.1.4.2 传输层：TCP传输报文"></a>4.1.4.2 传输层：TCP传输报文</h6><p>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。</p><p>在建立连接前，会先进行 TCP 三次握手。</p><h6 id="4-1-4-3-网络层：IP协议查询Mac地址"><a href="#4-1-4-3-网络层：IP协议查询Mac地址" class="headerlink" title="4.1.4.3 网络层：IP协议查询Mac地址"></a>4.1.4.3 <strong>网络层：IP协议查询Mac地址</strong></h6><p>将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。</p><p>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p><blockquote><p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p></blockquote><h6 id="4-1-4-4-链路层：以太网协议"><a href="#4-1-4-4-链路层：以太网协议" class="headerlink" title="4.1.4.4 链路层：以太网协议"></a>4.1.4.4 <strong>链路层：以太网协议</strong></h6><p><strong>以太网协议</strong></p><p>根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：</p><ul><li>标头：数据包的发送者、接受者、数据类型</li><li>数据：数据包具体内容</li></ul><p><strong>Mac 地址</strong></p><p>以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p><p><strong>广播</strong></p><p>发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。</p><h6 id="4-1-5-服务器接收请求并返回HTTP报文"><a href="#4-1-5-服务器接收请求并返回HTTP报文" class="headerlink" title="4.1.5 服务器接收请求并返回HTTP报文"></a>4.1.5 服务器接收请求并返回HTTP报文</h6><p>服务器端经过物理层<strong>→</strong>数据链路层<strong>→</strong>网络层<strong>→</strong>传输层<strong>→</strong>应用层，解析请求报文，发送HTTP响应报文。</p><h5 id="4-1-6-渲染页面"><a href="#4-1-6-渲染页面" class="headerlink" title="4.1.6 渲染页面"></a>4.1.6 渲染页面</h5><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528162245.png" srcset="/img/loading.gif" alt="image-20200528162242378"></p><h4 id="4-2-对称加密和非对称加密是什么？"><a href="#4-2-对称加密和非对称加密是什么？" class="headerlink" title="4.2 对称加密和非对称加密是什么？"></a>4.2 对称加密和非对称加密是什么？</h4><p>信息的保密性我们可以使用对称加密和非对称加密来完成，使用对称加密来完成，速度相对非对称加密很快，但是存在一个安全问题，<strong>密钥如何传递？</strong>由此通用的方法是使用<strong>非对称加密+对称加密来完成</strong>。客户端使用公钥对对称加密的密钥进行加密，然后传递给服务端，服务端使用私钥进行解密确认密钥，开始传输数据。</p><p>在加密算法之外，面临一个问题，那就是：秘钥的分发。就是说，解密方如何获得加密方的秘钥呢？ 从而出现了：对称加密和非对称加密。</p><h5 id="4-2-1-对称加密"><a href="#4-2-1-对称加密" class="headerlink" title="4.2.1 对称加密"></a>4.2.1 对称加密</h5><p>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。</p><p>对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6</p><h5 id="4-2-2-非对称加密"><a href="#4-2-2-非对称加密" class="headerlink" title="4.2.2 非对称加密"></a>4.2.2 非对称加密</h5><p>非对称加密。比如RSA</p><p>公开密钥与私有密钥是一对，如果<strong>用公开密钥对数据进行加密，只有用对应的私有密钥才能解密</strong>；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p><p>甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。</p><p>非对称加密指使用一对非对称密钥，即：公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</p><p>比如：A和B通信，A把自己的公钥K1发给B，B收到K1后，自己先生成一个秘钥K2，然后用接收到的K1对K2进行加密，把加密后的秘钥发送给A。A用自己的<strong>非对称加密的私钥</strong>，解开了公钥K1的加密，获得了K2。</p><p>中间人攻击：AB通信，中间人C截获了A的公钥后，自己另外成一对公钥私钥，把自己的公钥K3，发给B，B收到K3以为是A发过来的，然后B用K3对K2加密，把加密后的秘钥发给A，这个过程中再次被中间人截获，然后中间人用自己的私钥解密，然后再用A发来的公钥K1对K2加密，把加密后的秘钥发给A。这样一来，两个人后续的通信尽管用Key2做了对称加密，但是中间人已经掌握了Key2，所以可以轻松进行解密。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528183147.png" srcset="/img/loading.gif" alt=""></p><p>解决方法：引入第三方</p><h5 id="4-2-3-证书颁发机构CA"><a href="#4-2-3-证书颁发机构CA" class="headerlink" title="4.2.3 证书颁发机构CA"></a>4.2.3 证书颁发机构CA</h5><p>数字证书是由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了持有人的相关信息，服务器的公钥，签署者签名信息（数字签名）等，<strong>最重要的是公钥在数字证书中，从而保证发送方的公钥是真的</strong>。</p><p>数字证书上由持有人的相关信息，通过这点可以确定其不是一个中间人；但是证书也是可以伪造的，如何保证证书为真呢？<strong>各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥</strong>。所以只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528183355.png" srcset="/img/loading.gif" alt="image-20200528183353566"></p><blockquote><p>有一种算法，叫做hash算法。是单向加密。就是只能从明文得到密文，却无法从密文得到明文。这种算法有一个好处，就是明文哪怕只有一位不一样，加密后得到的密文也不一样。所以常用来进行比较明文是否被篡改过。</p></blockquote><p>数字证书生成过程：</p><blockquote><p>首先，有一个权威的证书签发机构，称为CA——全球就那么几个公司比较权威啦，这个机构，先用RSA产生一对公私钥。<br>私钥自己留着藏起来，你要是能偷到手就厉害了。<br>然后用自己的私钥对自己的公钥进行签名，生成所谓的数字证书。<br>这个过程大概是这样的：<br>先生成一个文件，文件内容大概是这样的：<br><strong>公钥内容</strong><br>签发者ID—-谁签发的证书<br>Subject—-也就是这个证书签发给谁。这里subject和签发者ID相同。<br>有效期<br>其他信息</p><p>以上内容都是明文。我们称为<strong>内容P</strong>。</p><p>然后使用hash算法，对内容P进行hash计算，得到一个hash值H。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200621121421.png" srcset="/img/loading.gif" alt="image-20200621121417956"></p><p>然后使用签发机构的私钥对H进行RSA加密，得到<strong>签名信息S</strong>。这个步骤称为<strong>签名</strong>，<strong>就是用私钥对某公开内容的hash值进行加密。</strong><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200621121438.png" srcset="/img/loading.gif" alt="image-20200621121434764"></p><p>然后将P，S连成一个文件，这个文件就是所谓的<strong>数字证书</strong>了。所以数字证书里，包括证书持有者的身份信息，证书信息，证书持有人的公钥，以及签名信息。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200621121459.png" srcset="/img/loading.gif" alt="image-20200621121451392"></p><p>现在假设某人得到了这个证书，如何<strong>确认这个证书属于谁的呢</strong>？<br>我们看数字证书里有些什么？可以得到P，可以得到S。<br>我们用<strong>同样的hash算法对P进行hash计算，得到一个hash值H1.</strong><br>P里有公钥，签发者ID，Subject，有效期，及其他信息。我们用公钥解密S，得到了一个值H’。<br>这个H‘，正常情况，或者说期望正常的话，应该就是制作数字证书的时候，用私钥对S加密的H。是否真如期望一样呢？比较一番就知道了。<br>现在对比H’和H1是否相等，如果相等，那么就证明这个证书是有签发者签发给subject的证书，就是符合期望了，也就是正常情况。否则就说明：1.内容P被篡改过，或者2.证书不是由CA签发的。<br>这个是对自签发证书的验证过程。需要说明的是，这种自签发证书的验证不常使用，但如何验证证书的原理类似。</p><p>既然自己可以给自己签发证书，那黑客宣称自己是某著名CA，然后给自己签发一个证书。那验证者如何来验证这个证书是黑客自己的呢还是那个著名的CA呢？<br>如果仅仅按照上文所说的自签发证书验证过程来看，是无法确认身份的。<br>啥？那搞毛啊？<br>不要急，这个问题，就是CA存在的意义了。</p><p>所谓<strong>全球权威的CA</strong>，就那么几个公司，这几个公司的证书，被各软件厂商设置成“<strong>可信任的根证书</strong>”了。所谓的根证书，是<strong>指这个证书是受信任的起始点，随后可以用这个证书来证明其他的证书</strong>。就好像你爸爸绝对相信你是好人，然后你再证明你的朋友A是好人，于是你爸爸相信A也是好人一样。所谓其他的证书，自然就是由CA签发的证书了，这些证书无法享受CA可信任的根证书待遇。</p><p>至于这些CA是怎么把自己的数字证书交给软件厂商而且让他们信任自己，我也不知道。如果你知道了，你就可以自己给自己签发一个证书，交给微软的IE，或者firefox等，让他们把你的证书嵌入到软件里去。这样一来，你就成了全球权威的CA之一了！</p><p>现在知道了，自签发的数字证书，要被各软件信任，是不容易的。一旦CA的根证书存在用户的系统了，就可以用这个根证书来验证其他证书了。并用被验证过的证书来认证身份</p></blockquote><p>当客户端发起请求时，服务器<strong>将该数字证书发送给客户端</strong>，客户端通过<strong>CA机构提供的公钥对加密密文进行解密获得散列值（数字签名）</strong>，同时将证书内容使用相同的散列算法进行Hash得到另一个散列值，比对两个散列值，如果两者相等则说明证书没问题。</p><p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性。但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p><h5 id="4-3-Cookie-和-Session的区别"><a href="#4-3-Cookie-和-Session的区别" class="headerlink" title="4.3 Cookie 和 Session的区别"></a>4.3 Cookie 和 Session的区别</h5><p>cookie保存在客户端，session保存在服务器端，<br>        cookie目的是跟踪会话，保存用户喜好或者保存用户名密码<br>        session用来跟踪会话，通过服务端记录用户的状态</p><h4 id="有哪些协议是基于-TCP-的，哪些是基于-UDP"><a href="#有哪些协议是基于-TCP-的，哪些是基于-UDP" class="headerlink" title="有哪些协议是基于 TCP 的，哪些是基于 UDP"></a>有哪些协议是基于 TCP 的，哪些是基于 UDP</h4><p>基于TCP的有FTP、Telnet、SMTP、HTTP、POP3与DNS<br>基于UDP的有TFTP、SNMP、DHCP与DNS<br>其中DNS既可以基于TCP，也可以基于UDP</p><p> QQ默认用的是UDP和腾讯自己的QICQ协议，但是QQ登录时选择TCP选项，也用到了TCP协议。微信主要是TCP协议。</p><p> IP地址</p><h4 id="请简述TCP-UDP的区别"><a href="#请简述TCP-UDP的区别" class="headerlink" title="请简述TCP\UDP的区别"></a>请简述TCP\UDP的区别</h4><blockquote><p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p><p>两者的区别大致如下：</p><ul><li>TCP面向连接，UDP面向非连接即发送数据前不需要建立链接</li><li>TCP提供可靠的服务（数据传输），UDP无法保证</li><li>TCP面向字节流，UDP面向报文</li><li>TCP数据传输慢，UDP数据传输快</li></ul></blockquote><h4 id="请简单说一下你了解的端口及对应的服务？"><a href="#请简单说一下你了解的端口及对应的服务？" class="headerlink" title="请简单说一下你了解的端口及对应的服务？"></a>请简单说一下你了解的端口及对应的服务？</h4><blockquote><p>80:http</p><p>443:https</p><p>3306:tomcat</p><p>6379:redis</p><p>22:SSH</p><p>8080:8080端口同80端口，是被用于WWW代理服务的，可以实现网页</p></blockquote><h4 id="IP地址有哪几类"><a href="#IP地址有哪几类" class="headerlink" title="IP地址有哪几类"></a>IP地址有哪几类</h4><blockquote><p>P 地址编址方案将 IP 地址空间划分为 A、B、C、D、E 五类，其中 A、B、C 是基本类，D、E 类作为多播和保留使用，为特殊地址。</p><p>判断IP地址类别，就看四组数中的第一组数</p><p>A 类地址：以 0 开头，第一个字节范围：0~127；</p><p>B 类地址：以 10 开头，第一个字节范围：128~191；</p><p>C 类地址：以 110 开头，第一个字节范围：192~223；</p><p>D 类地址：以 1110 开头，第一个字节范围为 224~239；</p><p>E 类地址：以 1111 开头，保留地址</p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200621122216.png" srcset="/img/loading.gif" alt="img"></p><h4 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a><strong>TCP/IP四层模型</strong></h4><blockquote><p>自底而上分别是数据链路层、网络层、传输层和应用层</p><p><strong>数据链路层实现了网卡接口的网络驱动程序，以处理数据在物理媒介（比如以太网、令牌环等）上的传输。</strong></p><p>​    数据链路层两个常用的协议是ARP协议（Address Resolve Protocol，地址解析协议）和RARP协议</p><p><strong>网络层实现数据包的选路和转发。</strong></p><p><strong>传输层为两台主机上的应用程序提供端到端（end to end）的通信。与网络层使用的逐跳通信方式不同，传输层只关心通信的起始端和目的端，而不在乎数据包的中转过程。</strong></p><p><strong>应用层负责处理应用程序的逻辑。</strong></p></blockquote><h4 id="HTTP-协议包括哪些请求？"><a href="#HTTP-协议包括哪些请求？" class="headerlink" title="HTTP 协议包括哪些请求？"></a>HTTP 协议包括哪些请求？</h4><blockquote><ul><li>GET：对服务器资源的简单请求</li><li>POST：用于发送包含用户提交数据的请求</li></ul><p>简述HTTP中GET和POST的区别</p><p>从原理性看：</p><ul><li>根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的</li><li>根据HTTP规范，POST请求表示可能修改服务器上资源的请求</li></ul><p>从表面上看：</p><ul><li>GET请求的数据会附在URL后面，POST的数据放在HTTP包体</li><li>POST安全性比GET安全性高</li></ul></blockquote><h4 id="ARP-协议的工作原理？"><a href="#ARP-协议的工作原理？" class="headerlink" title="ARP 协议的工作原理？"></a>ARP 协议的工作原理？</h4><p>MAC地址是硬件地址，Ip只是逻辑地址</p><blockquote><p>网络层的 ARP 协议完成了 <strong>IP 地址与物理地址的映射</strong>。首先，每台主机都会在自己的 ARP 缓冲区中建立一个 <strong>ARP 列表</strong>，以<strong>表示 IP 地址和 MAC 地址的对应关系</strong>。当<strong>源主机需要将一个数据包要发送到目的主机时</strong>，会首<strong>先检查自己 ARP 列表</strong>中是否存在该 IP 地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向<strong>本地网段发起一个 ARP 请求的广播包</strong>，查询此目的主机对应的 MAC 地址。</p><p>此 ARP 请求数据包里包括<strong>源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址</strong>。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机<strong>首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中</strong>，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后<strong>给源主机发送一个 ARP 响应数据包</strong>，告诉对方<strong>自己是它需要查找的 MAC 地址</strong>；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址<strong>添加到自己的 ARP 列表中</strong>，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</p></blockquote><h4 id="谈谈你对-ARQ-协议的理解？"><a href="#谈谈你对-ARQ-协议的理解？" class="headerlink" title="谈谈你对 ARQ 协议的理解？"></a>谈谈你对 ARQ 协议的理解？</h4><blockquote><ul><li><strong>自动重传请求 ARQ 协议</strong></li></ul><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。</p><ul><li><strong>连续 ARQ 协议</strong></li></ul><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p></blockquote><h4 id="DNS-的解析过程？"><a href="#DNS-的解析过程？" class="headerlink" title="DNS 的解析过程？"></a>DNS 的解析过程？</h4><blockquote><p>1 浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址，如果有，解析结束。</p><p>2 如果<strong>浏览器缓存</strong>中没有（专业点叫还没命中），浏览器会检查<strong>操作系统</strong>缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在windows中可通过c盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的ip地址，那浏览器会首先使用这个ip地址。</p><p>3 如果至此还没有命中域名，才会真正的请求<strong>本地域名服务器</strong>（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。</p><p>4 如果LDNS仍然没有命中，就直接跳到<strong>Root Server</strong> 域名服务器请求解析</p><p>5 根域名服务器返回给LDNS一个查询域的<strong>主域名服务器</strong>（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址</p><p>6 本地域名解析服务器向gTLD服务器发起请求。</p><p>7 gTLD服务器接收请求并返回<strong>Name Server服务器</strong></p><p>​    gTLD服务器接收本地域名服务器发起的请求，并根据需要解析的域名，找到该域名对应的<code>Name Server</code>域名服务器，通常情况下，这个<code>Name Server</code>服务器就是你注册的域名服务器，那么你注册的域名的服务商的服务器将承担起域名解析的任务。</p><p>8 Name Server服务器返回IP地址<strong>给本地服务器</strong></p><p>9 <strong>本地域名服务器缓存解析结果</strong></p><p>10 返回解析结果给用户</p></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>HTTP：<a href="https://mp.weixin.qq.com/s/4epUWMCLpwCBxxQgEbL8gA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/4epUWMCLpwCBxxQgEbL8gA</a></p><p>GET和POST的区别：<a href="https://zhuanlan.zhihu.com/p/57361216" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57361216</a></p><p>TCP和UDP：</p><p>​    <a href="https://zhuanlan.zhihu.com/p/86426969" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/86426969</a></p><p>​    <a href="https://blog.csdn.net/qq_38950316/article/details/81087809" target="_blank" rel="noopener">https://blog.csdn.net/qq_38950316/article/details/81087809</a></p><p>​    <a href="https://zhuanlan.zhihu.com/p/108822858" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/108822858</a></p><p>​    <a href="https://www.nowcoder.com/discuss/409281?channel=1000&amp;source_id=discuss_terminal_discuss_sim" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/409281?channel=1000&amp;source_id=discuss_terminal_discuss_sim</a></p><p>​    <a href="https://www.cnblogs.com/weilingfeng/archive/2019/05/10/10845882.html" target="_blank" rel="noopener">https://www.cnblogs.com/weilingfeng/archive/2019/05/10/10845882.html</a></p><p>​    <a href="https://zhuanlan.zhihu.com/p/84316213" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/84316213</a></p><p>两次握手：<a href="https://blog.csdn.net/ljq140421/article/details/77864208" target="_blank" rel="noopener">https://blog.csdn.net/ljq140421/article/details/77864208</a></p><p>两种ack的区别：<a href="https://blog.csdn.net/baiyan3212/article/details/81302448" target="_blank" rel="noopener">https://blog.csdn.net/baiyan3212/article/details/81302448</a></p><p>ack+1的原因：<a href="https://www.cnblogs.com/suyunhong/p/10582962.html" target="_blank" rel="noopener">https://www.cnblogs.com/suyunhong/p/10582962.html</a></p><p>在浏览器中输入网址发生了什么： <a href="https://4ark.me/post/b6c7c0a2.html" target="_blank" rel="noopener">https://4ark.me/post/b6c7c0a2.html</a></p><p>对称加密和非对称加密： <a href="https://www.jianshu.com/p/29e0ba31fb8d" target="_blank" rel="noopener">https://www.jianshu.com/p/29e0ba31fb8d</a></p><p>​                                            <a href="https://www.zhihu.com/question/24294477/answer/74783418" target="_blank" rel="noopener">https://www.zhihu.com/question/24294477/answer/74783418</a></p><p>TCP首部格式：<a href="https://blog.csdn.net/qq_32998153/article/details/79680704" target="_blank" rel="noopener">https://blog.csdn.net/qq_32998153/article/details/79680704</a></p><p><strong>计算机网络之面试常考</strong>： <a href="https://www.nowcoder.com/discuss/1937" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/1937</a></p>]]></content>
    
    
    <categories>
      
      <category>复习大纲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式面试题</title>
    <link href="/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式面试题"><a href="#设计模式面试题" class="headerlink" title="设计模式面试题"></a>设计模式面试题</h1><p>Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式</p><p>在 Java 中，什么叫观察者设计模式（observer design pattern）</p><p>使用工厂模式最主要的好处是什么？在哪里使用</p><p>举一个用 Java 实现的装饰模式(decorator design pattern) ？它是作用于对象层次还是类层次？ </p><p>在 Java 中，什么时候用重载，什么时候用重写？</p><p>举例说明什么情况下会更倾向于使用抽象类而不是接口</p><p>观察者模式</p><p>适配模式</p><p>工厂模式</p><p>问题来源：<a href="https://zhuanlan.zhihu.com/p/86536581" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/86536581</a></p>]]></content>
    
    
    <categories>
      
      <category>复习大纲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2020/06/19/Linux/"/>
    <url>/2020/06/19/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux面试问题"><a href="#Linux面试问题" class="headerlink" title="Linux面试问题"></a>Linux面试问题</h1><p>常见的命令</p><p>sed 和 awk 感觉linux必考。。</p><p>linux的使用场景，你什么时候会用linux – 》 布置服务器</p><p>怎么查看进程和杀死进程</p><p>打印一个文件夹中的所有文件</p><p>float在计算机中是怎么存储的，当时被问到的时候，我也在问自己，怎么存的<del>~</del> 佛了</p><p>线程和进程的区别</p><p>线程的通信方式，进程的通信方式</p><p>系统线程的数量上限是多少</p><p>页式存储的概念</p><p>内存碎片，你有了解过吗，有想过解决方案吗~</p><p>问题来源：<a href="https://zhuanlan.zhihu.com/p/86536581" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/86536581</a></p>]]></content>
    
    
    <categories>
      
      <category>复习大纲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx</title>
    <link href="/2020/06/19/nginx/"/>
    <url>/2020/06/19/nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="nginx面试问题"><a href="#nginx面试问题" class="headerlink" title="nginx面试问题"></a>nginx面试问题</h1><p>怎么配置负载均衡</p><p>怎么限流</p><p>怎么使用nginx缓存</p><p>为什么使用nginx，有别的替代品吗</p><p>请解释 x Nginx 如何处理 P HTTP 请求</p><p>在 x Nginx 中，如何使用未定义的服务器名称来阻止处理请求? ?</p><p>使用“ 反向代理服务器 ” 的优点是什么? </p><p> x Nginx 服务器上的 r Master 和 和 r Worker 进程分别是什么? </p><p>nginx的压力测试，你测试过吗，能抗住多少压力</p><p>你如何通过不同于 0 80 的端口开启 Nginx?</p><p>是否有可能将 x Nginx 的错误替换为 2 502 错误、 503</p><p> s stub_status 和 和 r sub_filter 指令的作用是什么? ?</p><p>问题来源：<a href="https://zhuanlan.zhihu.com/p/86536581" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/86536581</a></p>]]></content>
    
    
    <categories>
      
      <category>复习大纲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发</title>
    <link href="/2020/06/19/Java%E5%B9%B6%E5%8F%91/"/>
    <url>/2020/06/19/Java%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h2 id="1-synchronized"><a href="#1-synchronized" class="headerlink" title="1 synchronized"></a>1 synchronized</h2><p>1.1. 说一说自己对于 synchronized 关键字的了解</p><p><a href="https://www.cnblogs.com/duanxz/p/4967042.html" target="_blank" rel="noopener">https://www.cnblogs.com/duanxz/p/4967042.html</a></p><blockquote><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p></blockquote><p>1.2. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</p><blockquote><p><strong>synchronized关键字最主要的三种使用方式：</strong></p><ul><li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li><li><strong>修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li><li><strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><p><strong>总结：</strong> synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！</p></blockquote><p>1.3. 讲一下 synchronized 关键字的底层原理</p><blockquote><p><strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p><p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，<strong>线程试图获取锁也就是获取 monitor</strong>(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p></blockquote><p>对象头</p><blockquote><p>对象头包括两部分：Mark Word 和 类型指针。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200621145601.png" srcset="/img/loading.gif" alt="image-20200621145557167"></p><h6 id="Mark-Word-32位JVM，长度为32个比特，64位JVM，长度为64个比特"><a href="#Mark-Word-32位JVM，长度为32个比特，64位JVM，长度为64个比特" class="headerlink" title="Mark Word(32位JVM，长度为32个比特，64位JVM，长度为64个比特)"></a>Mark Word(32位JVM，长度为32个比特，64位JVM，长度为64个比特)</h6><p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。</p><p>32位的Hotspot虚拟机中，25个个比特用来存储对象哈希码，4个比特用来存储对象分代年龄，2个比特用来存储锁标志位，1个比特固定为0。</p><p><strong>identity_hashcode</strong>：25位的对象标识Hash码，采用延迟加载技术。调用方法<code>System.identityHashCode()</code>计算，并会将结果写到该对象头中。当对象被锁定时，该值会移动到管程Monitor中。</p><p><strong>age</strong>：4位的Java对象年龄。在GC中，如果对象在Survivor区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由于age只有4位，所以最大值为15，这就是<code>-XX:MaxTenuringThreshold</code>选项最大值为15的原因。</p><p>2个比特用来存储锁标志位：lock</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200621145934.png" srcset="/img/loading.gif" alt="image-20200621145930669"></p><h6 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h6><p>类型指针指向对象的类元数据，虚拟机通过这个指针确定该对象是哪个类的实例。</p></blockquote><p><strong>synchronized 修饰方法的的情况</strong></p><blockquote><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p></blockquote><p>1.4. 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗</p><blockquote><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><p>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><p><strong>偏向锁</strong></p><p>偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p><p><strong>轻量级锁</strong></p><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。<strong>轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作</strong></p><p><strong>轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</strong></p><p><strong>自旋锁和自适应自旋</strong></p><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p><p>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</p><p><strong>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。</strong> 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。<strong>为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋</strong>。</p><p><strong>在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了</strong>。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很可能再次成功的，进而它将会允许线程自旋相对更长的时间。</p><p><strong>锁消除</strong></p><p>锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间</p></blockquote><p>1.5 谈谈 synchronized和ReentrantLock 的区别</p><blockquote><p><strong>两者都是可重入锁</strong></p><p><strong>synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API</strong></p><p><strong>ReenTrantLock 比 synchronized 增加了一些高级功能</strong>：主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p><ul><li><strong>eenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li></ul></blockquote><p>1.6 讲一下Java内存模型</p><blockquote><p>java内存模型(Java Memory Model，JMM)是java虚拟机规范定义的，用来屏蔽掉java程序在各种不同的硬件和操作系统对内存的访问的差异</p><p>java内存模型的注意目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中读取变量值。此处的变量指的是实例字段、静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，因为后者是线程私有的，不会被共享，也就不存在竞争问题了。</p><p>java内存模型规定了所有变量都存储在主内存，每条线程都有自己的工作内存，线程的工作内存中保存了该线程使用的变量的主内存副本，线程对变量的读取、赋值等操作就必须在工作内存中读取，而不能直接读取内存的数据，不同线程的工作内存也无法直接访问对方工作内存中的变量，线程间传递变量必须通过主内存进行。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200621154628.png" srcset="/img/loading.gif" alt=""></p><p>关于主内存和工作内存之间的交互，java内存模型定义了8种操作来完成</p><p>java虚拟机中主内存和工作内存交互，就是一个变量如何从主内存传输到工作内存中，如何把修改后的变量从工作内存同步回主内存。</p><ul><li><strong>lock(锁定)</strong>:作用于主内存的变量，一个变量在同一时间只能一个线程锁定，该操作表示这条线成独占这个变量</li><li><strong>unlock(解锁)</strong>:作用于主内存的变量，表示这个变量的状态由处于锁定状态被释放，这样其他线程才能对该变量进行锁定</li><li><strong>read(读取)</strong>:作用于主内存变量，表示把一个主内存变量的值传输到线程的工作内存，以便随后的load操作使用</li><li><strong>load(载入)</strong>:作用于线程的工作内存的变量，表示把read操作从主内存中读取的变量的值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)</li><li><strong>use(使用)</strong>:作用于线程的工作内存中的变量，表示把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作</li><li><strong>assign(赋值)</strong>:作用于线程的工作内存的变量，表示把执行引擎返回的结果赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作</li><li><strong>store(存储)</strong>:作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便随后的write操作使用</li><li><strong>write(写入)</strong>:作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中</li></ul></blockquote><p>1.7 说说 synchronized 关键字和 volatile 关键字的区别</p><blockquote><p>synchronized关键字和volatile关键字比较</p><ul><li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。但是<strong>volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块</strong>。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用 synchronized 关键字的场景还是更多一些</strong>。</li><li><strong>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</strong></li><li><strong>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</strong></li><li><strong>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</strong></li></ul></blockquote><h2 id="2-ThreadLocal"><a href="#2-ThreadLocal" class="headerlink" title="2 ThreadLocal"></a>2 ThreadLocal</h2><p>3.1. ThreadLocal简介</p><blockquote><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。<strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p><p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get（）</code> 和<code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p><p>再举个简单的例子：</p><p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来避免这两个线程竞争的。</p></blockquote><p>3.3. ThreadLocal原理</p><blockquote><p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个  <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p></blockquote><p>3.4. ThreadLocal 内存泄露问题</p><blockquote><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p></blockquote><h2 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3 线程池"></a>3 线程池</h2><p>4.1. 为什么要用线程池？</p><blockquote><p><strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul></blockquote><p>4.2. 实现Runnable接口和Callable接口的区别</p><blockquote><p><strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是<strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。</p></blockquote><p>4.3. 执行execute()方法和submit()方法的区别是什么呢？</p><blockquote><ol><li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol></blockquote><p>4.4. 如何创建线程池</p><blockquote><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p>xecutors 返回线程池对象的弊端如下：</p><ul><li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ：允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。</li><li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ：允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li></ul><p><strong>方式一：通过构造方法实现</strong>.</p><p><strong>方式二：通过Executor 框架的工具类Executors来实现</strong>我们可以创建三种类型的ThreadPoolExecutor：</p><ul><li><strong>FixedThreadPool</strong> ：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li></ul></blockquote><p>4.5 ThreadPoolExecutor 构造函数分析</p><blockquote><p><strong><code>ThreadPoolExecutor</code> 重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。线程池中最大的存活线程数</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。有三种阻塞队列</li><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。<ol><li>给线程命名，查看创建线程数</li><li>给线程设置是否是后台运行</li><li>设置线程优先级</li></ol></li><li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li></ul></blockquote><p>4.6 ThreadPoolExecutor 饱和策略</p><blockquote><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong>：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul></blockquote><p>4.7 阻塞队列</p><blockquote><p>主要有3种类型的BlockingQueue可供选择：无界队列，有界队列和同步移交</p></blockquote><h2 id="4-JUC包"><a href="#4-JUC包" class="headerlink" title="4 JUC包"></a>4 JUC包</h2><p>4.1. 介绍一下Atomic 原子类</p><blockquote><p>Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p><p>所以，所谓原子类说简单点就是具有原子/原子操作特征的类。</p></blockquote><p>4.2. JUC 包中的原子类是哪4类?</p><blockquote><p><strong>基本类型</strong></p><p>使用原子的方式更新基本类型</p><ul><li>AtomicInteger：整形原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean：布尔型原子类</li></ul><p><strong>数组类型</strong></p><p>使用原子的方式更新数组里的某个元素</p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray：引用类型数组原子类</li></ul><p><strong>引用类型</strong></p><ul><li>AtomicReference：引用类型原子类</li><li>AtomicStampedReference：原子更新引用类型里的字段原子类</li><li>AtomicMarkableReference ：原子更新带有标记位的引用类型</li></ul><p><strong>对象的属性修改类型</strong></p><ul><li>AtomicIntegerFieldUpdater：原子更新整形字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li></ul></blockquote><p>4.3. 讲讲 AtomicInteger 的使用</p><blockquote><p>public final int get() <em>//获取当前的值</em><br>public final int getAndSet(int newValue)<em>//获取当前的值，并设置新的值</em><br>public final int getAndIncrement()<em>//获取当前的值，并自增</em><br>public final int getAndDecrement() <em>//获取当前的值，并自减</em><br>public final int getAndAdd(int delta) <em>//获取当前的值，并加上预期的值</em><br>boolean compareAndSet(int expect, int update) <em>//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</em><br>public final void lazySet(int newValue)<em>//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</em></p><p>使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。</p><pre><code class="hljs java">&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerTest</span> </span>&#123;       <span class="hljs-keyword">private</span> AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger();     <span class="hljs-comment">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;                 count.incrementAndGet();       &#125;          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;               <span class="hljs-keyword">return</span> count.get();       &#125;&gt;&#125;</code></pre></blockquote><p>4.4. 能不能给我简单介绍一下 AtomicInteger 类的原理</p><blockquote><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p><pre><code class="hljs java">&gt;<span class="hljs-comment">//AtomicInteger 类的部分源码：</span>   <span class="hljs-comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> valueOffset;   <span class="hljs-keyword">static</span> &#123;       <span class="hljs-keyword">try</span> &#123;           valueOffset = unsafe.objectFieldOffset               (AtomicInteger.class.getDeclaredField("value"));       &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(ex); &#125;   &#125;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;</code></pre></blockquote><h2 id="5-AQS"><a href="#5-AQS" class="headerlink" title="5 AQS"></a>5 AQS</h2><p>6.1. AQS 介绍</p><blockquote><p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。</p><p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p></blockquote><p>6.2. AQS 原理分析</p><blockquote><p><strong>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200621162211.png" srcset="/img/loading.gif" alt="image-20200621162208194"></p></blockquote><p>6.2.2. AQS 对资源的共享方式</p><blockquote><p><strong>AQS定义两种资源共享方式</strong></p><ul><li><p><strong>Exclusive</strong>（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：</p></li><li><ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><p><strong>Share</strong>（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p></li></ul><p>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p></blockquote><p>6.2.3. AQS底层使用了模板方法模式</p><blockquote><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</li><li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ol><p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p><p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p></blockquote><p>6.3. AQS 组件总结</p><blockquote><ul><li><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li><li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来<strong>控制线程等待</strong>，它可以让某<strong>一个线程</strong>等待直到倒计时结束，再开始执行。</li><li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，<strong>让一组线程到达一个屏障（也可以叫同步点）时被阻塞</strong>，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li></ul></blockquote><h2 id="6-线程安全"><a href="#6-线程安全" class="headerlink" title="6 线程安全"></a>6 线程安全</h2><p>“线程安全”也不是指线程的安全，而是指内存的安全。为什么如此说呢？这和操作系统有关。</p><p>目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。</p><p>在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。对于一个共享数据，线程A执行中是值A，但是假如线程A等待一段时间后，变成了值B，这就产生了安全风险。</p><p>解决方法：</p><p>CAS或者ThreadLocal</p><p>要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的，这不就安全了嘛。相信你已经猜到了，我要表达的就是ThreadLocal类了。</p><h2 id="7-volatile"><a href="#7-volatile" class="headerlink" title="7 volatile"></a>7 volatile</h2><p>资料来源：</p><p>JavaGuide: <a href="https://mp.weixin.qq.com/s/cdHfTTvMpH60SwG2bjTMBw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/cdHfTTvMpH60SwG2bjTMBw</a></p><p>对象头：<a href="https://www.cnblogs.com/makai/p/12466541.html" target="_blank" rel="noopener">https://www.cnblogs.com/makai/p/12466541.html</a></p><p>Java内存模型：<a href="https://www.jianshu.com/p/15106e9c4bf3" target="_blank" rel="noopener">https://www.jianshu.com/p/15106e9c4bf3</a></p>]]></content>
    
    
    <categories>
      
      <category>复习大纲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2020/06/19/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/06/19/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java面试问题"><a href="#Java面试问题" class="headerlink" title="Java面试问题"></a>Java面试问题</h1><h2 id="为什么String定义为final"><a href="#为什么String定义为final" class="headerlink" title="为什么String定义为final"></a>为什么String定义为final</h2><blockquote><p>为了安全性和效率</p><p>用final就是<strong>拒绝继承</strong>,防止其内部的方法被重写，乱改。为了线程安全(字符串自己便是线程安全的)。比如我们使用string作为hash的键，如果string是可变的，那么键也是可变的。</p><p><strong>字符串常量池</strong>,  在大量使用字符串的情况下，可以节省内存空间，提高效率。但之所以能实现这个特性，String的不可变性是最基本的一个必要条件</p><p>final修饰的对象只是引用地址不可变，内容还是能变的</p><p>执行效率可以这么解释，面向对象有一个多态的性质，如果可以改变，就可以被复写，子类如果复写了某个方法，虚函数表就被用上了；如果是final型的，jvm就直接去用了，根本不用去虚函数表里面找</p><p>​      ———-只要声明成final ，JVM才不用对相关方法在虚函数表中查询，而直接定位到string类的相关方法上，提高了执行效率。基础类以保证执行效率为第一要素。</p></blockquote><h2 id="描述下java集合，项目中用到哪些。"><a href="#描述下java集合，项目中用到哪些。" class="headerlink" title="描述下java集合，项目中用到哪些。"></a>描述下java集合，项目中用到哪些。</h2><blockquote><ul><li><p>Collection</p></li><li><ul><li><p>List</p></li><li><p><strong>ArrayList</strong></p></li><li><p>LinkedList</p></li><li><p>Vector(了解，已过时)</p></li></ul></li><li><p>Set</p><ul><li><p><strong>HashSet</strong></p><ul><li>LinkedHashSet</li></ul></li><li><p>TreeSet</p></li></ul></li><li><p>Map</p><ul><li><p><strong>HashMap</strong></p></li><li><p>LinkedHashMap</p></li></ul></li><li><p>TreeMap</p></li><li><p>ConcurrentHashMap</p></li><li><p>Hashtable(了解，，已过时)</p></li></ul></blockquote><h2 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h2><blockquote><p>这两个类都实现了List接口，它们都是<strong>有序</strong>的集合(存储有序)，<strong>底层是数组</strong>。我们可以按位置索引号取出某个元素，<strong>允许元素重复和为null</strong>。</p><ul><li>ArrayList是非同步的</li><li>Vector是同步的</li><li>Vector增长原来的一倍，ArrayList增长原来的0.5倍</li></ul></blockquote><h3 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h3><blockquote><ul><li><p><strong>同步性：</strong></p></li><li><p>HashMap是非同步的</p></li><li><p>Hashtable是同步的</p></li><li><p>需要同步的时候，我们往往不使用，而使用ConcurrentHashMap</p></li></ul><ul><li><p><strong>是否允许为null：</strong></p></li><li><p>HashMap允许为null</p></li><li><p>Hashtable不允许为null</p></li></ul><p>HashMap把Hashtable的contains方法去掉了，改成了containsValue和containsKey</p></blockquote><h2 id="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢"><a href="#Set里的元素是不能重复的，那么用什么方法来区分重复与否呢" class="headerlink" title="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢"></a>Set里的元素是不能重复的，那么用什么方法来区分重复与否呢</h2><blockquote><p>Set集合如果添加的元素相同时，<strong>是根本没有插入的(仅修改了一个无用的value值)</strong></p></blockquote><h2 id="Collection和Collections的区别"><a href="#Collection和Collections的区别" class="headerlink" title="Collection和Collections的区别"></a>Collection和Collections的区别</h2><blockquote><ol><li>Collection是集合的上级<strong>接口</strong>，继承它的有Set和List接口</li><li>Collections是集合的<strong>工具类</strong>，提供了一系列的静态方法对集合的搜索、查找、同步等操作</li></ol></blockquote><h2 id="ArrayList-LinkedList的存储性能和特性"><a href="#ArrayList-LinkedList的存储性能和特性" class="headerlink" title="ArrayList,LinkedList的存储性能和特性"></a>ArrayList,LinkedList的存储性能和特性</h2><blockquote><p>rrayList的底层是数组，LinkedList的底层是双向链表。</p><ul><li>ArrayList它支持以角标位置进行索引出对应的元素(随机访问)，而LinkedList则需要遍历整个链表来获取对应的元素。因此<strong>一般来说ArrayList的访问速度是要比LinkedList要快的</strong></li><li>ArrayList由于是数组，对于删除和修改而言消耗是比较大(复制和移动数组实现)，LinkedList是双向链表删除和修改只需要修改对应的指针即可，消耗是很小的。因此<strong>一般来说LinkedList的增删速度是要比ArrayList要快的</strong></li></ul></blockquote><h2 id="Java中HashMap的key值要是为类对象则该类需要满足什么条件？"><a href="#Java中HashMap的key值要是为类对象则该类需要满足什么条件？" class="headerlink" title="Java中HashMap的key值要是为类对象则该类需要满足什么条件？"></a>Java中HashMap的key值要是为类对象则该类需要满足什么条件？</h2><blockquote><p><strong>需要同时重写该类的hashCode()方法和它的equals()方法</strong>。</p><ul><li>在插入元素的时候是<strong>先算出该对象的hashCode</strong>。如果hashcode相等话的。那么表明该对象是存储在同一个位置上的。</li><li>如果调用equals()方法，<strong>两个key相同</strong>，则<strong>替换元素</strong></li><li>如果调用equals()方法，<strong>两个key不相同</strong>，则说明该<strong>hashCode仅仅是碰巧相同</strong>，此时是散列冲突，将新增的元素放在桶子上</li></ul><p>一般来说，我们会认为：<strong>只要两个对象的成员变量的值是相等的，那么我们就认为这两个对象是相等的</strong>！因为，Object底层比较的是两个对象的地址，而对我们开发来说这样的意义并不大~这也就为什么我们要重写<code>equals()</code>方法</p><p>重写了equals()方法，就要重写hashCode()的方法。因为<strong>equals()认定了这两个对象相同</strong>，而<strong>同一个对象调用hashCode()方法时</strong>，是应该返回相同的值的！</p></blockquote><h2 id="StringBuilder和StringBuffer的区别。"><a href="#StringBuilder和StringBuffer的区别。" class="headerlink" title="StringBuilder和StringBuffer的区别。"></a>StringBuilder和StringBuffer的区别。</h2><blockquote><p>StringBuilder是线程不安全，StringBuffer是线程安全。这是因为源代码中StringBuffer的很多方法都被关键字<strong>synchronized</strong> 修饰了，而StringBuilder没有。</p><p>StringBuffer、StringBuilder和String一样，也用来代表字符串。String类是不可变类，任何对String的改变都 会引发新的String对象的生成；StringBuffer则是可变类，任何对它所指代的字符串的改变都不会产生新的对象。</p><p>三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String</p></blockquote><h2 id="HashMap中常用的方法有哪些，什么时候会触发树化，jdk1-7和1-8实现的差异，1-7的实现为什么会出现死锁，画图说明下。HashMap和TreeMap的区别。"><a href="#HashMap中常用的方法有哪些，什么时候会触发树化，jdk1-7和1-8实现的差异，1-7的实现为什么会出现死锁，画图说明下。HashMap和TreeMap的区别。" class="headerlink" title="HashMap中常用的方法有哪些，什么时候会触发树化，jdk1.7和1.8实现的差异，1.7的实现为什么会出现死锁，画图说明下。HashMap和TreeMap的区别。"></a>HashMap中常用的方法有哪些，什么时候会触发树化，jdk1.7和1.8实现的差异，1.7的实现为什么会出现死锁，画图说明下。HashMap和TreeMap的区别。</h2><blockquote><p>HashMap通过hashcode对其内容进行快速查找，而 TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap.</p><p>存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，会按照排序后的顺序迭代元素，两个相比较的key不得抛出classCastException。主要用于存入元素的时候对元素进行自动排序，迭代输出的时候就按排序顺序输出</p><p><strong>为什么HashMap需要加载因子？</strong></p><p>必须在“冲突的机会”与“空间利用率”之间，寻找一种平衡与折衷。</p><p>那么为什么选择了0.75作为HashMap的加载因子呢？这个跟一个统计学里很重要的原理——泊松分布有关。</p><p>在理想情况下，使用随机哈希码，在扩容阈值（加载因子）为0.75的情况下，节点出现在频率在Hash桶（表）中遵循参数平均为0.5的泊松分布。忽略方差，即X = λt，P(λt = k)，其中λt = 0.5的情况</p></blockquote><h2 id="说下枚举类型，底层实现原理，项目中是如何使用的。"><a href="#说下枚举类型，底层实现原理，项目中是如何使用的。" class="headerlink" title="说下枚举类型，底层实现原理，项目中是如何使用的。"></a>说下枚举类型，底层实现原理，项目中是如何使用的。</h2><blockquote><p>枚举是可以防止反序列化的，以及反射</p><p>枚举是一种特殊类。一个枚举在经过编译器编译过后，变成了一个抽象类，它继承了java.lang.Enum；而枚举中定义的枚举常量，变成了相应的public static final属性，而且其类型就是抽象类的类型，名字就是枚举常量的名字</p></blockquote><h2 id="详细描述Error和Exception-运行期和编译期-的区别。"><a href="#详细描述Error和Exception-运行期和编译期-的区别。" class="headerlink" title="详细描述Error和Exception(运行期和编译期)的区别。"></a>详细描述Error和Exception(运行期和编译期)的区别。</h2><blockquote><p>Error是一般不可处理的，由jvm抛出的严重性的问题。<br>Exception可以处理的。常见的Exception有</p><p>IOException:</p><p>RuntimeException:</p><pre><code class="hljs angelscript"> ClassNotFoundException找不到对应类因此 NullPointerException空指针异常类 llegalArgumentException参数异常 ClassCastException类型强制转换异常ArithmeticException算术异常类---<span class="hljs-built_in">int</span> a=<span class="hljs-number">5</span>/<span class="hljs-number">0</span>;&gt;ArrayIndexOutOfBoundsException数组下标越界异常</code></pre></blockquote><h2 id="创建线程的方式，线程的生命周期。"><a href="#创建线程的方式，线程的生命周期。" class="headerlink" title="创建线程的方式，线程的生命周期。"></a>创建线程的方式，线程的生命周期。</h2><blockquote><p>新建状态（New）: 当线程对象创建后，即进入新建状态，如：Thread t = new MyThread();</p><p>就绪状态（Runnable）: 当调用线程对象的start()方法时，线程即进入就绪状态。处于就绪状态的线程只是说明此线程已经做好准备，随时等待CPU调度执行，并不是说执行了start()方法就立即执行。</p><p>运行状态（Running）: 当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。</p><p>阻塞状态（Blocked）: 处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。</p><p>死亡状态: 线程执行完毕或者是异常退出，该线程结束生命周期。</p></blockquote><p>ThrealLocal实现原理，为什么会出现内存泄漏。</p><p>volatile关键字原理，项目中是如何使用的。</p><p>synchronized和lock的区别，底层实现原理。AQS队列实现原理，用了哪些设计模式。公平锁和非公平锁、独占锁和共享锁、读写锁分别是如何实现的，为什么说非公平锁比公平锁性能高。</p><h2 id="序列化和反序列化。"><a href="#序列化和反序列化。" class="headerlink" title="序列化和反序列化。"></a>序列化和反序列化。</h2><blockquote><p>Java序列化就是指就是将内存中的对象转换为字节序列，方便持久化到磁盘或者网络传输。</p><p>步骤：第一: 将对象转换为字节数组  第二: 将字节数组存储到磁盘</p><p>Java反序列化就是将字节序列转换为内存中的对象</p><p>序列化最重要的作用：在传递和保存对象时.保证对象的完整性和可传递性。对象转换为有序字节流,以便在网络上传输或者保存在本地文件中。</p><p>反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。</p></blockquote><h2 id="深拷贝和浅拷贝区别。"><a href="#深拷贝和浅拷贝区别。" class="headerlink" title="深拷贝和浅拷贝区别。"></a>深拷贝和浅拷贝区别。</h2><blockquote><p>深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用</p><p>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝</p><p>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝</p></blockquote><h2 id="java内部类的区别-成员内部类、静态嵌套类、方法内部类、匿名内部类-。"><a href="#java内部类的区别-成员内部类、静态嵌套类、方法内部类、匿名内部类-。" class="headerlink" title="java内部类的区别(成员内部类、静态嵌套类、方法内部类、匿名内部类 )。"></a>java内部类的区别(成员<em>内部类<em>、静态嵌套类、方法</em>内部类<em>、匿名</em>内部类</em> )。</h2><blockquote><p>成员内部类与实例变量、实例方法一样，属于外部类对象</p><p>静态内部类是使用<code>static</code>修饰的成员内部类，属于外部类—-非静态内部类中不能含有静态内部类</p><p>局部内部类是在方法体中定义的内部类</p><p>匿名内部类是没有类名的内部类，匿名内部类的定义与对象创建时一起的，一般时给接口的引用或抽象类的引用赋值匿名内部类对象</p><pre><code class="hljs haxe">&gt;<span class="hljs-keyword">new</span> <span class="hljs-type"></span>实现接口（）&gt;&#123;   <span class="hljs-comment">//匿名内部类类体部分</span>&gt;&#125;&gt;<span class="hljs-keyword">new</span> <span class="hljs-type"></span>父类构造器（实参列表）&gt;&#123; <span class="hljs-comment">//匿名内部类类体部分</span>&gt;&#125;</code></pre><p>管什么类编译后都会生成独立的字节码文件</p></blockquote><h2 id="java线程池参数描述，线程池工作原理，线程池如何调优。"><a href="#java线程池参数描述，线程池工作原理，线程池如何调优。" class="headerlink" title="java线程池参数描述，线程池工作原理，线程池如何调优。"></a>java线程池参数描述，线程池工作原理，线程池如何调优。</h2><blockquote><p>使用线程池大致有3个好处</p><p><strong>第一：降低资源消耗。</strong>通过重复利用已创建的线程降低线程创建和销毁造成的消耗，减少了每次创建线程、销毁线程的开销。<br><strong>第二：提高响应速度。</strong>当任务到达时，任务可以不需要等到线程创建就能立即执行。<br><strong>第三：提高线程的可管理性。</strong>线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源</p><p><strong>线程池创建</strong></p><p>ThreadPoolExecutor是线程池的真正实现,通过构造方法的一系列参数,来构成不同配置的线程池</p><p>七大参数+四大拒绝策略：</p><pre><code class="hljs axapta">&gt;<span class="hljs-keyword">public</span> ThreadPoolExecutor(<span class="hljs-keyword">int</span> corePoolSize, <span class="hljs-meta">#核心线程数</span>               <span class="hljs-keyword">int</span> maximumPoolSize, <span class="hljs-meta">#最大线程数</span>               <span class="hljs-keyword">long</span> keepAliveTime,, <span class="hljs-meta">#该线程池中非核心线程闲置超时时长</span>               TimeUnit unit,<span class="hljs-meta">#keepAliveTime单位</span>               BlockingQueue&lt;Runnable&gt; workQueue, <span class="hljs-meta">#阻塞队列</span>               ThreadFactory threadFactory,<span class="hljs-meta">#创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</span>               RejectedExecutionHandler handler) <span class="hljs-meta">#饱和策略</span>&gt;corePoolSize：线程池新建线程的时候，如果当前线程总数小于corePoolSize，则新建的是核心线程，如果超过corePoolSize，则新建的是非核心线程核心线程默认情况下会一直存活在线程池中，即使这个核心线程啥也不干(闲置状态)。                     &gt;<span class="hljs-keyword">int</span> maximumPoolSize： 该线程池中线程总数最大值，线程总数 = 核心线程数 + 非核心线程数。  &gt;keepAliveTime：一个非核心线程，如果不干活(闲置状态)的时长超过这个参数所设定的时长，就会被销毁掉，如果设置allowCoreThreadTimeOut = <span class="hljs-keyword">true</span>，则会作用于核心线程。&gt;BlockingQueue workQueue：该线程池中的任务队列：维护着等待执行的Runnable对象，当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务。&gt;常用的workQueue类型：SynchronousQueue：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;线程数达到了maximumPoolSize而不能新建线程&gt;的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大LinkedBlockingQueue：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSizeArrayBlockingQueue：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误DelayQueue：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务&gt;RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常&gt;AbortPolicy：不处理，直接抛出异常。&gt;CallerRunsPolicy：若线程池还没关闭，调用当前所在线程来运行任务，r.run()执行。&gt;DiscardOldestPolicy：LRU策略，丢弃队列里最近最久不使用的一个任务，并执行当前任务。&gt;DiscardPolicy：不处理，丢弃掉，不抛出异常。</code></pre><p><strong>向线程池提交任务</strong></p><p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法</p><p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功</p><p>submit()方法用于提交需要返回值的任务。</p><p>线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get(long timeout，TimeUnit unit)，在指定的时间内会等待任务执行，超时则抛出超时异常，等待时候会阻塞当前线程<br><strong>关闭线程池</strong></p><p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，它们的原理是遍历线<br>程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程</p><p>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</p><p>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</p><p><strong>线程池状态</strong></p><p>1、RUNNING</p><p>(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。<br>(2) 状态切换：线程池的初始化状态是RUNNING。线程池被一旦被创建，就处于RUNNING状态，且线程池中的任务数为0</p><p>2、 SHUTDOWN</p><p>(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。<br>(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p><p>3、STOP</p><p>(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。<br>(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p><p>4、TIDYING</p><p>(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。<br>(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</p><p>5、 TERMINATED</p><p>(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。<br>(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200619212551.png" srcset="/img/loading.gif" alt="image-20200619212548437"></p><p>主线程到达一个条件，需要多个子线程去执行任务，等子任务都执行完后再往下走，如何编写代码(CountDownLatch)。</p><h2 id="写个程序，两个线程交叉打印1到100的数字，需要多种实现方式。"><a href="#写个程序，两个线程交叉打印1到100的数字，需要多种实现方式。" class="headerlink" title="写个程序，两个线程交叉打印1到100的数字，需要多种实现方式。"></a>写个程序，两个线程交叉打印1到100的数字，需要多种实现方式。</h2><pre><code class="hljs java"><span class="hljs-comment">//https://blog.csdn.net/u013760665/article/details/88805644</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPrint</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> Thread t1,t2;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runThread</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        t1=<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread1());        t2=<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread2());        t1.start();        t2.start();    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span><span class="hljs-class">    </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">100</span>)            &#123;                <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)                &#123;                    System.out.println(i);                    i++;                    flag=<span class="hljs-number">2</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span><span class="hljs-class">    </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">100</span>)            &#123;                <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">2</span>)                &#123;                    System.out.println(i);                    i++;                    flag=<span class="hljs-number">1</span>;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="Hashmap-源码级掌握，扩容，红黑树，最小树化容量，hash冲突解决，有些面试官会提出发自灵魂的审问，比如为什么是红黑树，别的树不可以吗；为什么8的时候树化，4不可以吗，等等"><a href="#Hashmap-源码级掌握，扩容，红黑树，最小树化容量，hash冲突解决，有些面试官会提出发自灵魂的审问，比如为什么是红黑树，别的树不可以吗；为什么8的时候树化，4不可以吗，等等" class="headerlink" title="Hashmap 源码级掌握，扩容，红黑树，最小树化容量，hash冲突解决，有些面试官会提出发自灵魂的审问，比如为什么是红黑树，别的树不可以吗；为什么8的时候树化，4不可以吗，等等"></a>Hashmap 源码级掌握，扩容，红黑树，最小树化容量，hash冲突解决，有些面试官会提出发自灵魂的审问，比如为什么是红黑树，别的树不可以吗；为什么8的时候树化，4不可以吗，等等</h2><blockquote><p>为啥使用红黑树：</p><p>AVL树和红黑树有几点比较和区别：<br>（1）AVL树是更加严格的平衡，因此可以提供更快的查找速度，一般读取查找密集型任务，适用AVL树。<br>（2）红黑树更适合于插入修改密集型任务。<br>（3）通常，AVL树的旋转比红黑树的旋转更加难以平衡和调试。</p></blockquote><h2 id="concureentHashMap，段锁，如何分段，和hashmap在hash上的区别，性能，等等"><a href="#concureentHashMap，段锁，如何分段，和hashmap在hash上的区别，性能，等等" class="headerlink" title="concureentHashMap，段锁，如何分段，和hashmap在hash上的区别，性能，等等"></a>concureentHashMap，段锁，如何分段，和hashmap在hash上的区别，性能，等等</h2><blockquote><p>JDK7：ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。默认情况下，initialCapacity等于16，loadFactor等于0.75，concurrencyLevel等于16.</p><p>JDK8：在JDK1.7之前，ConcurrentHashMap是通过分段锁机制来实现的，所以其最大并发度受Segment的个数限制。因此，在JDK1.8中，ConcurrentHashMap的实现原理摒弃了这种设计，而是选择了与HashMap类似的数组+链表+红黑树的方式实现，而加锁则采用CAS和synchronized实现。<br><a href="https://blog.csdn.net/bill_xiang_/article/details/81122044" target="_blank" rel="noopener">https://blog.csdn.net/bill_xiang_/article/details/81122044</a></p></blockquote><h2 id="HashTable-，同步锁，这块可能会问你synchronized关键字-1-6之后提升了什么，怎么提升的这些"><a href="#HashTable-，同步锁，这块可能会问你synchronized关键字-1-6之后提升了什么，怎么提升的这些" class="headerlink" title="HashTable ，同步锁，这块可能会问你synchronized关键字 1.6之后提升了什么，怎么提升的这些"></a>HashTable ，同步锁，这块可能会问你synchronized关键字 1.6之后提升了什么，怎么提升的这些</h2><blockquote><p>在Hashtable中的绝大部分方法都是使用synchronized进行修饰的。比如Hashtable 提供的几个主要方法，包括 get(), put(), remove() 等。不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性，但是也大大的降低了执行效率。</p></blockquote><blockquote><p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong></p></blockquote><blockquote><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><p>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><p><strong>偏向锁</strong>的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为<strong>轻量级锁</strong>的优化手段(1.6之后加入的)。轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作…..轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</p><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为<strong>自旋锁</strong>的优化手段。</p><p>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</p><p>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。<strong>在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了</strong>。</p><p><strong>锁消除</strong></p><p>锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。</p><p><strong>锁粗化:</strong>就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁</p><p><strong>适应性自旋</strong> 当前锁处于膨胀，会进行自旋。自旋是需要消耗CPU的，如果一直获取不到锁的话，那线程一直处在自旋状态，消耗CPU资源。为了解决这个问题JDK采用—<strong>适应性自旋</strong>，线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。另外自旋虽然会占用CPU资源，但不会一直占用CPU资源，每隔一段时间会通过<strong>os::NakedYield方法</strong>放弃CPU资源，或通过<strong>park方法</strong>挂起；如果其他线程完成锁的膨胀操作，则退出自旋并返回</p></blockquote><h2 id="Synchronized-和-ReenTrantLock-的对比"><a href="#Synchronized-和-ReenTrantLock-的对比" class="headerlink" title="Synchronized 和 ReenTrantLock 的对比"></a>Synchronized 和 ReenTrantLock 的对比</h2><blockquote><p><strong>两者都是可重入锁</strong></p><p>​    “可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><p><strong>synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API</strong></p><p>​    synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><p><strong>ReenTrantLock 比 synchronized 增加了一些高级功能</strong></p><p>​    主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p><p>​    <strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>​    ReenTrantLock可以<strong>指定是公平锁还是非公平锁</strong>。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。</p><p>​    synchronized关键字与wait()和notify/notifyAll()方法相结合可以<strong>实现等待/通知机制</strong>，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</p></blockquote><h2 id="ArrayList-优势，扩容，什么时候用"><a href="#ArrayList-优势，扩容，什么时候用" class="headerlink" title="ArrayList 优势，扩容，什么时候用"></a>ArrayList 优势，扩容，什么时候用</h2><blockquote><p>ArrayList的底层是一个动态数组，ArrayList首先会对传进来的初始化参数initalCapacity进行判断，如果参数等于0，则将数组初始化为一个空数组，如果不等于0，将数组初始化为一个容量为10的数组。初始容量也可以自定义指定。随着不断添加元素，数组大小增加，当数组的大小大于初始容量的时候(比如初始为10，当添加第11个元素的时候)，就会进行扩容，新的容量为旧的容量的1.5倍。<br>扩容的时候，会以新的容量建一个原数组的拷贝，修改原数组，指向这个新数组，原数组被抛弃，会被GC回收。</p></blockquote><h2 id="LinkedList-优势，什么时候用，和arraylist的区别-等等"><a href="#LinkedList-优势，什么时候用，和arraylist的区别-等等" class="headerlink" title="LinkedList 优势，什么时候用，和arraylist的区别 等等"></a>LinkedList 优势，什么时候用，和arraylist的区别 等等</h2><blockquote><p>​    ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</p><p>  对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</p><p>  对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</p></blockquote><h2 id="基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理"><a href="#基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理" class="headerlink" title="基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理"></a>基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理</h2><blockquote><p>自动装箱就是Java自动将原始类型值转换成对应的包装类型，如将int的变量转换成Integer对象，这个过程叫做装箱。反之将Integer引用类型转换成int类型值，这个过程叫做拆箱。因为装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。</p><p>自动装箱时编译器调用valueOf将基本类型值转换成引用类型。</p><p>自动拆箱时，编译器通过调用类似intValue()，doubleValue()这类的方法将对象转换成原始类型值。</p></blockquote><h2 id="String-，StringBuffer，StringBuilder哪个是安全的"><a href="#String-，StringBuffer，StringBuilder哪个是安全的" class="headerlink" title="String ，StringBuffer，StringBuilder哪个是安全的"></a>String ，StringBuffer，StringBuilder哪个是安全的</h2><blockquote><p><strong>String 字符串常量<br>StringBuffer 字符串变量（线程安全）<br>StringBuilder 字符串变量（非线程安全）</strong></p><p>String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</p></blockquote><h2 id="什么是泛型，怎么用泛型"><a href="#什么是泛型，怎么用泛型" class="headerlink" title="什么是泛型，怎么用泛型"></a>什么是泛型，怎么用泛型</h2><blockquote><p>“泛型” 意味着编写的代码可以被不同类型的对象所重用。泛型的提出是为了编写重用性更好的代码。泛型的本质是<strong>参数化类型</strong>，也就是说所操作的<strong>数据类型</strong>被指定为一个<strong>参数</strong>。实现一个通用的、可以处理不同类型的方法</p></blockquote><h2 id="static能不能修饰threadLocal，为什么，这道题我当时一听到其实挺懵逼的"><a href="#static能不能修饰threadLocal，为什么，这道题我当时一听到其实挺懵逼的" class="headerlink" title="static能不能修饰threadLocal，为什么，这道题我当时一听到其实挺懵逼的"></a>static能不能修饰threadLocal，为什么，这道题我当时一听到其实挺懵逼的</h2><blockquote><p>ThreadLocal并不是一个Thread，而是Thread的局部变量。ThreadLocal的作用是提供线程范围内的局部变量，这种变量在<strong>线程的生命周期内起作用</strong>。作用：提供一个线程内公共变量，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度，或者为线程提供一个私有的变量副本，这样每一个线程都可以<strong>随意修改自己的变量副本，而不会对其他线程产生影响</strong>，真正诠释了“Local”的含义。</p></blockquote><h2 id="Comparable和Comparator接口是干什么的，其区别"><a href="#Comparable和Comparator接口是干什么的，其区别" class="headerlink" title="Comparable和Comparator接口是干什么的，其区别"></a>Comparable和Comparator接口是干什么的，其区别</h2><blockquote><p>Comparable &amp; Comparator 都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序</p><p>java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明已经存在的对象小于，等于，大于输入对象。</p><p>Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。</p><ol><li><p>Comparable 自然排序。（实体类实现，需要继承这个接口才可以调用）</p></li><li><p>Comparator 是定制排序。（不想实现Comparable接口的集合排序，不需要继承接口）</p><pre><code class="hljs java">Collections.sort(list,<span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;()&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<span class="hljs-keyword">return</span> o2 - o1;&#125;&#125;);</code></pre></li></ol><p>Comparable:  内部比较器，一个类如果想要使用    Collections.sort(list) 方法进行排序，则需要实现该接口</p><p>Comparator:  外部比较器用于对那些没有实现Comparable接口或者对已经实现的Comparable中的排序规则不满意进行排序.无需改变类的结构，更加灵活。（策略模式）</p></blockquote><h2 id="多态的原理是什么"><a href="#多态的原理是什么" class="headerlink" title="多态的原理是什么"></a>多态的原理是什么</h2><blockquote><ol><li><p>编译时多态（又称静态多态）</p><p>重载（overload）就是编译时多态的一个例子，编译时多态在编译时就已经确定，运行时运行的时候调用的是确定的方法。</p></li><li><p>运行时多态（又称动态多态）</p><p>常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定。这也是为什么有时候多态方法又被称为延迟方法的原因。</p></li></ol><p><strong>多态通常有两种实现方法：</strong></p><ol><li>子类继承父类（extends）</li><li>类实现接口（implements）</li></ol><p>其核心之处就在于对父类方法的改写或对接口方法的实现，以取得在运行时不同的执行效果。</p><p>要使用多态，在声明对象时就应该遵循一条法则：父类引用指向子类对象：<code>List list =　newArrayList();</code></p><p>定义方法参数时也通常总是应该优先使用父类类型或接口类型</p><p>最大的好处在于结构的灵活性：假如某一天我认为ArrayList的特性无法满足我的要求，我希望能够用LinkedList来代替它，那么只需要在对象创建的地方把new ArrayList()改为new LinkedList即可，其它代码一概不用改动。</p><p>多态最大的用途我认为在于对设计和架构的复用，更进一步来说，《设计模式》中提倡的针对接口编程而不是针对实现编程就是充分利用多态的典型例子。</p></blockquote><h2 id="接口和抽象类，面试官问我是怎么理解的，我说接口对应功能，抽象类对应属性，然后面试官给我说了他的看法，说抽象类更偏向于一种模板-然后又交流了一下各自的想法"><a href="#接口和抽象类，面试官问我是怎么理解的，我说接口对应功能，抽象类对应属性，然后面试官给我说了他的看法，说抽象类更偏向于一种模板-然后又交流了一下各自的想法" class="headerlink" title="接口和抽象类，面试官问我是怎么理解的，我说接口对应功能，抽象类对应属性，然后面试官给我说了他的看法，说抽象类更偏向于一种模板~ 然后又交流了一下各自的想法"></a>接口和抽象类，面试官问我是怎么理解的，我说接口对应功能，抽象类对应属性，然后面试官给我说了他的看法，说抽象类更偏向于一种模板~ 然后又交流了一下各自的想法</h2><blockquote><p>继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如狗是否能钻火圈，能则可以实现这个接口，不能就不实现这个接口。</p></blockquote><h2 id="如何通过反射和设置对象私有字段的值"><a href="#如何通过反射和设置对象私有字段的值" class="headerlink" title="如何通过反射和设置对象私有字段的值"></a>如何通过反射和设置对象私有字段的值</h2><blockquote><p>通过类对象的getDeclaredField()方法获取字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了</p></blockquote><h2 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)的区别是什么"></a>快速失败(fail-fast)和安全失败(fail-safe)的区别是什么</h2><blockquote><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p><p>快速失败（fail—fast）</p><p>​     在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</p><p>​     原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>  注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p><p>  场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p><p>安全失败（fail—safe）</p><p>  采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p><p>  原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p><p>  缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p>​     场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p></blockquote><h2 id="synchronized-的实现原理以及锁优化？"><a href="#synchronized-的实现原理以及锁优化？" class="headerlink" title="synchronized 的实现原理以及锁优化？"></a>synchronized 的实现原理以及锁优化？</h2><blockquote><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p><ol><li><strong>普通同步方法，锁是当前实例对象；</strong></li><li><strong>静态同步方法，锁是当前类的class对象；</strong></li><li><strong>同步方法块，锁是括号里面的对象。</strong></li></ol><p><strong>同步代码块：</strong></p><p>　　monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；</p><p><strong>同步方法</strong></p><p>　　synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在JVM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的<strong>accessflags字段中的synchronized标志位置1</strong>，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示class做为锁对象。</p></blockquote><p>Java对象头</p><blockquote><p>对象在内存中存储分为三块区域：对象头、实例数据和对齐填充 HotSpot虚拟机的对象头(Object Header)包括两部分信息: 第一部分<strong>“Mark Word”:</strong> 用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等.</p><p>第二部分<strong>“Klass Pointer”:</strong> 对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。(数组，对象头中还须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。 )</p><p>什么是Monitor？</p><p>　　我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。 </p><p>　　与一切皆对象一样，所有的Java对象是天生的Monitor，<strong>每一个Java对象都有成为Monitor的潜质</strong>，因为在Java的设计中 ，每一个Java对象自打娘胎里出来<strong>就带了一把看不见的锁，它叫做内部锁或者Monitor锁</strong>。 </p><p>　　Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），<strong>同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用</strong>。　　</p></blockquote><p>volatile 的实现原理？</p><blockquote><p>特性:</p><p>​    保证了不同线程对该变量操作的内存可见性——–如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值<br>​    禁止指令重排序</p><p><strong>内存可见性</strong></p><p>​    JMM规定所有变量都是存在主存中的，类似于上面提到的普通内存，每个线程又包含自己的工作内存，方便理解就可以看成CPU上的寄存器或者高速缓存。所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值在同步回主内存。</p><p>在线程执行时，首先会从主存中read变量值，再load到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。</p><p>禁止指令重排序</p><p>​    顾名思义：禁止编译器优化，指令执行代码的顺序。</p><p>​    加入volatile关键字的代码会多出一个lock前缀指令。<br><strong>lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</strong><br><strong>① 重排序时不能把后面的指令重排序到内存屏障之前的位置</strong><br><strong>② 使得本CPU的Cache写入内存</strong><br><strong>③ 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。</strong></p><p><strong>volatile不能保证原子性</strong></p></blockquote><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><blockquote><p>JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。</p><p><strong>原子性</strong></p><p>​    Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。</p><p><strong>可见性</strong></p><p>​    <strong>Java就是利用volatile来提供可见性的。</strong><br>当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。<br>其实通过synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是synchronized和Lock的开销都更大。</p><p><strong>有序性（Ordering）</strong><br>   JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段：</p></blockquote><h2 id="synchronized-在静态方法和普通方法的区别？"><a href="#synchronized-在静态方法和普通方法的区别？" class="headerlink" title="synchronized 在静态方法和普通方法的区别？"></a>synchronized 在静态方法和普通方法的区别？</h2><blockquote><p>synchronized修饰不加static的方法，锁是加在单个对象上，不同的对象没有竞争关系；修饰加了static的方法，锁是加载类上，这个类所有的对象竞争一把锁。</p></blockquote><h2 id="怎么实现所有线程在等待某个事件的发生才会去执行？"><a href="#怎么实现所有线程在等待某个事件的发生才会去执行？" class="headerlink" title="怎么实现所有线程在等待某个事件的发生才会去执行？"></a>怎么实现所有线程在等待某个事件的发生才会去执行？</h2><blockquote><p>java里面实现这个有两个办法，countdownlatch和cyclicbarrier。</p></blockquote><p>countdownlatch和cyclicbarrier</p><blockquote><p>countDownLatch是在java1.5被引入，跟它一起被引入的工具类还有CyclicBarrier、Semaphore、concurrentHashMap和BlockingQueue。</p><p>存在于java.util.cucurrent包下。</p><p>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</p><p>是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</p><pre><code class="hljs java">&gt;<span class="hljs-comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123; &#125;;   &gt;<span class="hljs-comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123; &#125;;  &gt;<span class="hljs-comment">//将count值减1</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countDown</span><span class="hljs-params">()</span> </span>&#123; &#125;;  </code></pre><p><strong>CyclicBarrier——–循环栅栏</strong></p><p>举个例子，就像生活中我们会约朋友们到某个餐厅一起吃饭，有些朋友可能会早到，有些朋友可能会晚到，但是这个餐厅规定必须等到所有人到齐之后才会让我们进去。这里的朋友们就是各个线程，餐厅就是 CyclicBarrier。</p><p>作用就是会让所有线程都等待完成后才会继续下一步行动。</p><pre><code class="hljs java">&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException</span><span class="hljs-function">&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException</span></code></pre><p><a href="https://www.jianshu.com/p/333fd8faa56e" target="_blank" rel="noopener">https://www.jianshu.com/p/333fd8faa56e</a></p><p><strong>CountDownLatch和CyclicBarrier区别：</strong><br>1.countDownLatch是一个计数器，线程完成一个记录一个，计数器递减，只能只用一次<br>2.CyclicBarrier的计数器更像一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供reset功能，可以多次使用</p><p>CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现的</p></blockquote><p>CAS？CAS 有什么缺陷，如何解决？</p><blockquote><p>Compare And Swap</p><p>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力</p><p>ABA问题====解决方法加版本号或者时间戳</p></blockquote><p>List，Map，Set接口在取元素时，各有什么特点</p><blockquote><p>List和set具有相似性质，它们都是单列的元素的集合，所以它们有一个共同的父接口，叫做Collection</p><p>Set里面不允许有重复的元素，所谓重复，即是不能有两个相等(注意，不是仅仅是相同)的对象</p><p>List表示有先后顺序的集合</p><p>Map与List和Set不同，它是双列的集合</p></blockquote><p>如何线程安全的实现一个计数器</p><h2 id="生产者消费者模式，要求手写过代码，还是要知道的"><a href="#生产者消费者模式，要求手写过代码，还是要知道的" class="headerlink" title="生产者消费者模式，要求手写过代码，还是要知道的"></a>生产者消费者模式，要求手写过代码，还是要知道的</h2><blockquote><p>（1）生产者生产数据到缓冲区中，消费者从缓冲区中取数据。<br>（2）如果缓冲区已经满了，则生产者线程阻塞；<br>（3）如果缓冲区为空，那么消费者线程阻塞。</p><p>Step:</p><p>（1）定义一个缓存队列，选择一个集合当做缓存，给予缓存上限，缓存队列只有两种行为（生产数据和消费数据）；<br>（2）定义一个生产者线程，调用缓存队列中的生产行为；<br>（3）定义一个消费者线程，调用缓存队列中的消费行为；</p><p>定义一个缓冲区</p><pre><code class="hljs java">&gt;<span class="hljs-keyword">package</span> test;&gt;<span class="hljs-keyword">import</span> java.util.Iterator;&gt;<span class="hljs-keyword">import</span> java.util.LinkedHashMap;&gt;<span class="hljs-keyword">import</span> java.util.Map;&gt;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PublicQueue</span> &lt;<span class="hljs-title">T</span>&gt;</span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> putIndex=<span class="hljs-number">0</span>;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxCount=<span class="hljs-number">50</span>;   <span class="hljs-keyword">private</span> LinkedHashMap&lt;Integer,T&gt; linkedHashMap=<span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T msg)</span></span><span class="hljs-function">   </span>&#123;       <span class="hljs-keyword">if</span>(linkedHashMap.size()==maxCount)       &#123;           <span class="hljs-keyword">try</span> &#123;               wait();           &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;               e.printStackTrace();           &#125;       &#125;<span class="hljs-keyword">else</span> &#123;           notify();       &#125;       linkedHashMap.put(putIndex,msg);       System.out.println(<span class="hljs-string">"生产一个产品，当前商品角标为："</span>+putIndex+<span class="hljs-string">"===文本为："</span>+msg+<span class="hljs-string">"===缓存长度为："</span>+linkedHashMap.size());       putIndex = (putIndex + <span class="hljs-number">1</span> &gt;= maxCount) ? (putIndex + <span class="hljs-number">1</span>) % maxCount : putIndex + <span class="hljs-number">1</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> T <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">if</span> (maxCount == <span class="hljs-number">0</span>) &#123;           <span class="hljs-keyword">try</span> &#123;               wait();           &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;               e.printStackTrace();           &#125;       &#125; <span class="hljs-keyword">else</span> &#123;           notifyAll();       &#125;       Iterator it=linkedHashMap.entrySet().iterator();       T t=<span class="hljs-keyword">null</span>;       <span class="hljs-keyword">if</span>(it.hasNext())       &#123;           Map.Entry&lt;Integer,T&gt; entry= (Map.Entry&lt;Integer, T&gt;) it.next();           t=entry.getValue();           <span class="hljs-keyword">int</span> index=entry.getKey();           linkedHashMap.remove(index);           System.out.println(<span class="hljs-string">"消费一个产品，当前商品角标为："</span>+index+<span class="hljs-string">"===文本为："</span>+ t +<span class="hljs-string">"===缓存长度为："</span>+linkedHashMap.size());       &#125;       <span class="hljs-keyword">return</span> t;   &#125;&gt;&#125;</code></pre><p>定义生产者和消费者</p><pre><code class="hljs java">&gt;<span class="hljs-keyword">package</span> test;&gt;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProduceThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;   <span class="hljs-keyword">private</span> PublicQueue publicQueue;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProduceThread</span><span class="hljs-params">(PublicQueue publicQueue)</span> </span>&#123;       <span class="hljs-keyword">this</span>.publicQueue = publicQueue;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;           publicQueue.add(String.valueOf(i));       &#125;   &#125;&gt;&#125;&gt;<span class="hljs-keyword">package</span> test;&gt;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;   <span class="hljs-keyword">private</span> PublicQueue publicQueue;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConsumerThread</span><span class="hljs-params">(PublicQueue publicQueue)</span> </span>&#123;       <span class="hljs-keyword">this</span>.publicQueue = publicQueue;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;           publicQueue.remove();       &#125;   &#125;&gt;&#125;</code></pre><p>测试类</p><pre><code class="hljs java">&gt;<span class="hljs-keyword">package</span> test;&gt;<span class="hljs-keyword">import</span> java.util.ArrayList;&gt;<span class="hljs-keyword">import</span> java.util.HashMap;&gt;<span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;&gt;<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;&gt;<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;&gt;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;       PublicQueue publicQueue=<span class="hljs-keyword">new</span> PublicQueue();       ConsumerThread consumerThread=<span class="hljs-keyword">new</span> ConsumerThread(publicQueue);       ProduceThread produceThread=<span class="hljs-keyword">new</span> ProduceThread(publicQueue);       Thread t1=<span class="hljs-keyword">new</span> Thread(consumerThread);       Thread t2=<span class="hljs-keyword">new</span> Thread(produceThread);       t1.start();       t2.start();   &#125;&gt;&#125;</code></pre><p><a href="https://blog.csdn.net/Virgil_K2017/article/details/89283946?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/Virgil_K2017/article/details/89283946?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p></blockquote><p>sleep 和yeild方法有什么区别</p><blockquote><p>① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br>② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；<br>③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；</p><p>sleep() 方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是 <strong>sleep() 方法不会释放“锁标志”</strong>，也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。</p><p>wait() 方法需要和 notify() 及 notifyAll() 两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在 synchronized 语句块内使用，也就是说，调用 wait()，notify() 和 notifyAll() 的任务在调用这些方法前必须拥有对象的锁。</p><p><strong>wait() 方法与 sleep() 方法的不同之处在于，wait() 方法会释放对象的“锁标志”</strong></p><p>yield() 方法和 sleep() 方法类似，也不会释放“锁标志”，区别在于，它没有参数，即 yield() 方法只是使当前线程重新回到可执行状态</p><p>join() 方法会使当前线程等待调用 join() 方法的线程结束后才能继续执行</p></blockquote><p>乐观锁和悲观锁的使用场景</p><blockquote><p>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。</p><p>乐观锁的常见实现方式：CAS+版本号/时间戳</p><p>悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。</p><p><strong>读取频繁使用乐观锁，写入频繁使用悲观锁</strong></p></blockquote><h2 id="悲观锁的常见实现方式：lock-synchronized-retreentlock"><a href="#悲观锁的常见实现方式：lock-synchronized-retreentlock" class="headerlink" title="悲观锁的常见实现方式：lock synchronized retreentlock"></a>悲观锁的常见实现方式：lock synchronized retreentlock</h2><h2 id="乐观锁：CAS-MVCC"><a href="#乐观锁：CAS-MVCC" class="headerlink" title="乐观锁：CAS MVCC"></a>乐观锁：CAS MVCC</h2><p>MVCC</p><blockquote><p>Multi-Version Concurrency Control,翻译为中文即 多版本并发控制</p><p>MVCC通过保存数据的历史版本，根据比较版本号来处理数据的是否显示，从而达到读取数据的时候不需要加锁就可以保证事务隔离性的效果</p></blockquote><p>读写锁的实现方式，16位int的前八位和后八位分别作为读锁和写锁的标志位</p><p>死锁的条件，怎么解除死锁，怎么观测死锁。</p><blockquote><ol><li>互斥条件：一个资源一次只能被一个进程使用</li><li>请求与保持条件：一个进程因为请求资源而阻塞时，对已经获得的资源保持不放</li><li>不剥夺条件：进程已经获得的资源，在未使用完之前，不能被强行剥夺</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li></ol><p>死锁的检测：</p><p>一个简单的死锁检测方法，准备两张表。</p><p>一张记录当前资源的分配，记录线程和它占有的资源的对应。</p><p>另一张记录当前等待资源的线程，记录等待的线程和它请求的资源的对应。</p><p>当能够检测到环路时，表示发生了死锁。</p><p>死锁的解除：</p><p>有两种方法，对应不同的操作。</p><p>第一种方法：进程终止，简单地终止一个或多个进程以打破循环等待。</p><ul><li>撤销所有死锁线程</li><li>一次终止一个线程直到取消死循环为止</li></ul><p>第二种方法：抢占资源，从一个或多个死锁进程中抢占一个或多个资源</p><ul><li>选择一个牺牲品</li><li>回滚</li><li>饥饿（在代价因素中加上回滚次数，回滚的越多则越不可能被作为牺牲品）</li></ul></blockquote><p>希望大家能够好好看一下反射的原理，怎么确定类，怎么调方法</p><blockquote><p>Class类就是Java 反射机制的入口，它封装了一个类或接口的运行时信息，通过调用Class类的方法可以获取这些信息</p></blockquote><p>RPC框架，同步异步，响应时间，这些都被问到过，还让设计过</p><p>同步，异步，阻塞，非阻塞 在深信服的面试中遇到过，最好再找一些应用场景加以理解</p><blockquote><p>同步和异步关注的是<strong>消息通信机制</strong> </p><p>所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由<em>调用者</em>主动等待这个<strong>调用</strong>的结果。</p><p>异步则是相反，<strong>调用\在发出之后，这个调用就直接返回了，所以没有返回结果</strong>。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><p>举个通俗的例子：<br>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。<br>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p><p>阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p></blockquote><p>问题+答案来源：</p><p><a href="https://zhuanlan.zhihu.com/p/35723259" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35723259</a></p><p>线程池：<a href="https://blog.csdn.net/lzxlfly/article/details/83904032" target="_blank" rel="noopener">https://blog.csdn.net/lzxlfly/article/details/83904032</a></p><p>锁：<a href="https://blog.csdn.net/qq_34337272/article/details/83409990" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/83409990</a></p><p>生产者和消费者：<a href="https://blog.csdn.net/Virgil_K2017/article/details/89283946?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/Virgil_K2017/article/details/89283946?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p><p>反射：<a href="https://blog.csdn.net/qq_34598667/article/details/99653905" target="_blank" rel="noopener">https://blog.csdn.net/qq_34598667/article/details/99653905</a></p><p>异步和同步：<a href="https://www.zhihu.com/question/19732473/answer/20851256" target="_blank" rel="noopener">https://www.zhihu.com/question/19732473/answer/20851256</a></p>]]></content>
    
    
    <categories>
      
      <category>复习大纲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2020/06/19/Redis/"/>
    <url>/2020/06/19/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis面试问题"><a href="#Redis面试问题" class="headerlink" title="Redis面试问题"></a>Redis面试问题</h1><ol><li>redis数据类型，说下跳跃表是如何实现的，可以用什么数据结构替换。</li><li>删除过期key策略有哪些，内存淘汰策略有哪些，分别什么时候触发。</li><li>redis线程模型和内存模型。</li><li>redis持久化机制。</li><li>redis集群方案。</li><li>让你设计一个redis，你会怎么做，有看过redis源码吗。</li><li>了解一致性hash算法吗，描述下。</li><li>用redis实现一个分布式锁。</li><li>缓存穿透、缓存击穿、缓存雪崩区别和解决方案。</li><li>布隆过滤器知道吗，说下原理。</li></ol><p>Redis用过哪些数据数据，以及Redis底层怎么实现</p><p>Redis缓存穿透，缓存雪崩</p><p>如何使用Redis来实现分布式锁</p><p>Redis的并发竞争问题如何解决</p><p>Redis持久化的几种方式，优缺点是什么，怎么实现的</p><p>Redis的缓存失效策略</p><p>Redis集群，高可用，原理</p><p>Redis缓存分片，Redis的数据淘汰策略</p><p>为什么选择redis，有什么好处，基于内存，抗压</p><p>redis集群怎么进行数据分配，hash槽</p><p>redis的主从复制是怎么实现的</p><p>redis的数据结构 最常问 hash是什么， sorted set怎么实现的</p><p>因为项目的原因，问我redis是怎么保证高可用的，主从和集群怎么加在一起</p><p>redis 和memcache的区别</p><p>redis 分布式锁的实现原理 setNX 啥的</p><p>redis模拟session，除了redis你还考虑过别的吗</p><p>redis的缓存击穿，怎么处理这个问题</p><p>redis是基于内存的，那么它有持久化吗，aof rdb</p><p>aof和rdb的优缺点，你在项目中使用的哪一个</p><p>问题来源：</p><p><a href="https://zhuanlan.zhihu.com/p/86536581" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/86536581</a></p>]]></content>
    
    
    <categories>
      
      <category>复习大纲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2020/06/19/MySQL/"/>
    <url>/2020/06/19/MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL面试问题"><a href="#MySQL面试问题" class="headerlink" title="MySQL面试问题"></a>MySQL面试问题</h1><ol><li>事务描述，ACID讲解。</li><li>事务隔离级别描述，脏读、不可重复读、幻读区别，MVCC机制讲解。</li><li>Innodb如何解决幻读，间隙锁实现详细描述。</li><li>left join和inner join的区别，嵌套子查询如何优化。</li><li>如果线上出现慢sql，如何定位和解决，有实际动手优化过慢sql吗。</li><li>binlog机制描述，binlog日志格式有哪些。</li><li>MySQL主从架构(读写分离)，主从数据复制过程，数据复制过程丢失如何处理。</li><li>分库分表如何实现，用过哪些分库分表插件，底层原理是怎样的。</li><li>索引有哪些种类，建立索引的原则，聚簇索引和非聚簇索引实现区别，联合索引如何使用。</li><li>mysql写入数据的时候，是先把数据写到缓冲区，然后再flush到磁盘的，如何在flush过程中发生了宕机，数据如何恢复。</li></ol><p>事务四大特性（ACID）原子性、一致性、隔离性、持久性？</p><p>事务的并发？事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？</p><p>MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？</p><p>MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景？</p><p>查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序</p><p>索引为什么要用B+树，B+树和B-树的区别是什么</p><p>mysql的默认事务级别，一共有哪些事务级别</p><p>mysql的一些语句，这些肯定需要掌握的</p><blockquote><p><a href="https://www.cnblogs.com/bchjazh/p/5997728.html" target="_blank" rel="noopener">https://www.cnblogs.com/bchjazh/p/5997728.html</a></p><pre><code class="hljs sql">&gt;选择：select *   from table1   where 范围&gt;插入：insert into table1(field1,field2)   values  (value1,value2)&gt;删除：delete from table1   where 范围&gt;更新：update table1   set field1=value1   where 范围&gt;查找：select *   from table1   where field1   like ’%value1%’   ---like的语法很精妙，查资料!&gt;排序：select *   from table1   order by field1,field2 [  desc  ]&gt;总数：select count as totalcount   from table1&gt;求和：select sum  (field1)   as sumvalue   from table1&gt;平均：select avg  (field1)   as avgvalue   from table1&gt;最大：select max  (field1)   as maxvalue   from table1&gt;最小：select min  (field1)   as minvalue   from table1</code></pre></blockquote><p>mysql锁，行锁，表锁 ，什么时候发生锁，怎么锁，原理</p><p>数据库优化，最左原则啊，水平分表，垂直分表</p><p>什么是临时表，临时表什么时候删除?</p><p>sql查询语句确定创建哪种类型的索引？如何优化查询？</p><p>聚集索引和非聚集索引区别？</p><blockquote><p>聚集索引（主键索引）：</p><p>​      聚集索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的记录数据。</p><p>​      聚集索引的叶子节点称为数据页，聚集索引的这个特性决定了索引组织表中的数据也是索引的一部分。</p><p>​    辅助索引（二级索引）：普通索引也叫二级索引，除聚簇索引外的索引，即非聚簇索引</p><p>​      非主键索引，叶子节点=键值+书签。Innodb存储引擎的书签就是相应行数据的主键索引值。</p><p>聚簇索引查询会比非聚集索引查询更快</p><p>因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询。</p><p>刚刚你提到主键索引查询只会查一次，而非主键索引需要回表查询多次。（后来我才知道，原来这个过程叫做回表）是所有情况都是这样的吗？非主键索引一定会查询多次吗？</p><p>覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。 如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = ‘keytest’;的时候，就可以通过覆盖索引查询，无需回表。</p><p><strong>如何实现覆盖索引</strong></p><p>将被查询的字段，建立到联合索引里去</p></blockquote><p>explain解析：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200620164822.png" srcset="/img/loading.gif" alt="image-20200620164819166"></p><blockquote><p>id:选择标识符——- id相同时，执行顺序由上至下，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执，id值越大，优先级越高，越先执行<br>select_type:表示查询的类型———-表示查询中每个select子句的类型</p><p>​    (1) SIMPLE(简单SELECT，不使用UNION或子查询等)</p><p>​    (2) PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</p><p>​    (3) UNION(UNION中的第二个或后面的SELECT语句)</p><p>​    (4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p><p>​    (5) UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)</p><p>​    (6) SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)</p><p>​    (7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)</p><p>​    (8) DERIVED(派生表的SELECT, FROM子句的子查询)</p><p>​    (9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p><p>table:输出结果集的表——–显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的）<br>partitions:匹配的分区<br><strong>type:表示表的连接类型</strong>——–对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。常用的类型有： <strong>ALL、index、range、 ref、eq_ref、const、system、**</strong>NULL（从左到右，性能从差到好）**</p><p>​    ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</p><p>​    index: Full Index Scan，index与ALL区别为index类型只遍历索引树</p><p>​    range:只检索给定范围的行，使用一个索引来选择行</p><p>​    ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p><p>​    eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</p><p>​    const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</p><p>​    NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成</p><p>possible_keys:表示查询时，可能使用的索引<br>key:表示实际使用的索引<br>key_len:索引字段的长度<br>ref:列与索引的比较——<strong>即哪些列或常量被用于查找索引列上的值</strong><br>rows:扫描出的行数(估算的行数)<br>filtered:按表条件过滤的行百分比<br>Extra:执行情况的描述和说明</p><p>​    Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p><p>​    Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by</p><p>​    Using filesort：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”</p><p>​    Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p><p>​    Impossible where：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。</p><p>​    Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p><p>​    No tables used：Query语句中使用from dual 或不含任何from子句</p></blockquote><p><strong>联合索引的最左前缀匹配</strong></p><blockquote><p>MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。</p></blockquote><p>MySQL的事务的隔离级别</p><blockquote><p>未提交读RU：一个事务可以读取到，另外一个事务尚未提交的变更。<br>已提交读RR：一个事务提交后，其变更才会被另一个事务读取到。<br>可重复读RC：在一个事务执行的过程中所读取到的数据，和事务启动时所看到的一致。 即事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。<br>串行化S：当操作一行数据时，读写分别都会加锁。当出现读写锁互斥时，会排队串行执行</p></blockquote><p><strong>MVCC</strong></p><blockquote><p>​    <strong>MVCC主要适用于Mysql的RC,RR隔离级别</strong></p><p>InnoDB在每行记录后面保存两个隐藏的列来，分别保存了当前行创建时的版本号和删除时的版本号。这里存储的并不是实际的时间值,而是系统版本号，当数据被修改时，版本号加1<br>　　在读取事务开始时，系统会给当前读事务一个版本号，事务会读取版本号&lt;=当前版本号的数据<br>　　此时如果其他写事务修改了这条数据，那么这条数据的版本号就会加1，从而比当前读事务的版本号高，读事务自然而然的就读不到更新后的数据了</p><p><a href="https://blog.csdn.net/w2064004678/article/details/83012387" target="_blank" rel="noopener">https://blog.csdn.net/w2064004678/article/details/83012387</a></p></blockquote><p>有哪些锁（乐观锁悲观锁），select 时怎么加排它锁？</p><p>非关系型数据库和关系型数据库区别，优势比较？</p><p>数据库三范式，根据某个场景设计数据表？</p><p>数据库的读写分离、主从复制，主从复制分析的 7 个问题？</p><p>使用explain优化sql和索引？</p><p>MySQL慢查询怎么解决？</p><p>什么是 内连接、外连接、交叉连接、笛卡尔积等？</p><p>mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决？</p><p>varchar和char的使用场景？</p><p>mysql 高并发环境解决方案？</p><p>数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）？</p><p><strong>Mysql中有哪几种锁？</strong></p><blockquote><p>1.表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><p>2.行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><ol start="3"><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ol></blockquote><p><strong>简述在MySQL数据库中MyISAM和InnoDB的区别</strong></p><blockquote><p><strong>MyISAM：</strong></p><p>不支持事务，但是每次查询都是原子的；</p><p>支持表级锁，即每次操作是对整个表加锁；</p><p>存储表的总行数；</p><p>一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；</p><p>采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。</p><p><strong>InnoDb：</strong></p><p>支持ACID的事务，支持事务的四种隔离级别；</p><p>支持行级锁及外键约束：因此可以支持写并发；</p><p>不存储总行数；</p><p>一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；</p><p>主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。</p><p>如果没有特别的需求，使用默认的Innodb即可。</p><p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p><p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p></blockquote><p><strong>Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</strong></p><blockquote><p>SQL标准定义的四个隔离级别为：</p><ol><li>read uncommited ：读到未提交数据</li><li>read committed：读已经提交，大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”，但不能避免“幻读”和“不可重复读取”。该级别适用于大多数系统。</li><li>repeatable read：重复读：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但不能避免“幻读”，但是带来了更多的性能损失。</li><li>serializable ：最严格的级别，事务串行执行，资源消耗最大</li></ol><p>不可重复读和幻读比较：<br>两者有些相似，但是前者针对的是update或delete，后者针对的insert。</p></blockquote><p><strong>CHAR和VARCHAR的区别？</strong></p><blockquote><p>1.CHAR和VARCHAR类型在存储和检索方面有所不同<br>2.CHAR列长度固定为创建表时声明的长度，长度值范围是1到255<br>3.当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。</p></blockquote><p><strong>列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？</strong></p><blockquote><p>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</p></blockquote><p><strong>LIKE声明中的％和_是什么意思？</strong></p><blockquote><p>％对应于0个或更多字符，_只是LIKE语句中的一个字符。</p></blockquote><p><strong>什么情况下设置了索引但无法使用</strong></p><blockquote><p>1.以“%”开头的LIKE语句，模糊匹配</p><ol start="2"><li><p>OR语句前后没有同时使用索引</p></li><li><p>数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）</p></li></ol></blockquote><p><strong>数据库中的事务是什么?</strong></p><blockquote><p>事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。</p></blockquote><p><strong>ACID</strong></p><blockquote><p>（1）原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。</p><p>（2）一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态</p><p>（3）隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，</p><p>（4） 持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。</p></blockquote><p><strong>SQL注入漏洞产生的原因？如何防止？</strong></p><blockquote><p>SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。</p><p>防止SQL注入的方式：<br>开启配置文件中的magic_quotes_gpc 和 magic_quotes_runtime设置</p><p>执行sql语句时使用addslashes进行sql语句转换</p><p>Sql语句书写尽量不要省略双引号和单引号</p><p>过滤掉sql语句中的一些关键词：update、insert、delete、select、 * </p><p>提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。</p></blockquote><p>索引</p><blockquote><p>索引的目的是什么？<br>快速访问数据表中的特定信息，提高检索速度<br>创建唯一性索引，保证数据库表中每一行数据的唯一性。<br>加速表和表之间的连接<br>使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间</p><p>索引对数据库系统的负面影响是什么？<br>负面影响：<br>创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。</p><p>为数据表建立索引的原则有哪些？<br>在最频繁使用的、用以缩小查询范围的字段上建立索引。</p><p>什么情况下不宜建立索引？<br>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。</p><p>交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。</p><p>内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。<br>外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。</p><p>左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL目前还不支持全外连接。</p></blockquote><p><strong>SQL语言包括哪几部分？每部分都有哪些操作关键字？</strong></p><blockquote><p>SQL语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）四个部分。</p><p>数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index等</p><p>数据操纵：Select ,insert,update,delete,</p><p>数据控制：grant,revoke</p><p>数据查询：select</p></blockquote><p><strong>什么是锁？</strong></p><blockquote><p>数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。</p><p>加锁是<strong>实现数据库并发控制</strong>的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。</p><p><strong>锁包括行级锁和表级锁</strong></p></blockquote><p><strong>如何通俗地理解三个范式？</strong></p><blockquote><p>第一范式：每个列都不可以再拆分。</p><p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p><p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p></blockquote><p><strong>主键、外键和索引的区别？</strong></p><blockquote><p>主键–唯一标识一条记录，不能有重复的，不允许为空</p><p>外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值</p><p>索引–该字段没有重复值，但可以有一个空值</p><p><strong>作用：</strong></p><p>主键–用来保证数据完整性</p><p>外键–用来和其他表建立联系用的</p><p>索引–是提高查询排序的速度</p></blockquote><p><strong>你可以用什么来确保表格里的字段只接受特定范围里的值?</strong></p><blockquote><p>Check限制，它在数据库表格里被定义，用来限制输入该列的值。</p></blockquote><p><strong>对SQL语句优化有哪些方法？（选择几条）</strong></p><blockquote><p>Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。</p><p>（2）用EXISTS替代IN、用NOT EXISTS替代NOT IN。</p><p>（3） 避免在索引列上使用计算</p><p>（4）避免在索引列上使用IS NULL和IS NOT NULL</p><p>（5）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 </p><p>（6）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p><p>（7）应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</p></blockquote><p><strong>为什么要使用数据库</strong></p><blockquote><ul><li>数据保存在内存</li></ul><p>优点：存取速度快</p><p>缺点：数据不能永久保存</p><ul><li>数据保存在文件</li></ul><p>优点：数据永久保存</p><p>缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便</p><ul><li>数据保存在数据库</li></ul><p>1）数据永久保存</p><p>2）使用SQL语句，查询方便效率高。</p><p>3）管理数据方便</p></blockquote><p><strong>创建索引的原则（重中之重）</strong></p><blockquote><p>1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>2）较频繁作为查询条件的字段才去创建索引</p><p>3）更新频繁字段不适合创建索引</p><p>4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p><p>5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p><p>6）定义有外键的数据列一定要建立索引。</p><p>7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p><p>8）对于定义为text、image和bit的数据类型的列不要建立索引。</p></blockquote><p><strong>创建索引的三种方式，删除索引</strong></p><blockquote><p>第一种方式：在执行CREATE TABLE时创建索引</p><p>第二种方式：使用ALTER TABLE命令去增加索引</p><p>第三种方式：使用CREATE INDEX命令创建</p><p>删除索引</p><p>根据索引名删除普通索引、唯一索引、全文索引：alter table 表名 drop KEY 索引名</p><p>alter table 表名 drop primary key（因为主键只有一个）</p></blockquote><p><strong>创建索引时需要注意什么？</strong></p><blockquote><p>非空字段</p><p>取值离散大的字段</p><p>索引字段越小越好</p></blockquote><p> <strong>使用索引查询一定能提高查询的性能吗？为什么</strong></p><blockquote><p>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p><p>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</p><p>基于非唯一性索引的检索</p></blockquote><p><strong>百万级别或以上的数据如何删除</strong></p><blockquote><ol><li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li><li>然后删除其中无用数据（此过程需要不到两分钟）</li><li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li><li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li></ol></blockquote><p><strong>前缀索引</strong></p><blockquote><p>index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引</p></blockquote><p><strong>什么是最左前缀原则？什么是最左匹配原则</strong></p><blockquote><p>在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边</p><p>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p></blockquote><p><strong>使用B树的好处</strong></p><blockquote><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p></blockquote><p><strong>使用B+树的好处</strong></p><blockquote><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p></blockquote><p><strong>Hash索引和B+树所有有什么区别或者说优劣呢?</strong></p><blockquote><p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p></blockquote><p>InnoDB<strong>聚集索引和普通索引</strong></p><blockquote><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</p><p>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</p><p>innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p><p>innodb存储引擎表是索引组织表，表中数据按照主键顺序存放。其聚集索引就是按照每张表的主键顺序构造一颗B+树，其叶子结点中存放的就是整张表的行记录数据，这些叶子节点成为数据页。</p><p>在Innodb中，聚簇索引默认就是主键索引。如果没有主键，则按照下列规则来建聚簇索引:</p><ul><li>没有主键时，会用一个非空并且唯一的索引列做为主键，成为此表的聚簇索引;</li><li>如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。</li></ul><p>由于主键使用了聚簇索引，如果主键是自增id，那么对应的数据也会相邻地存放在磁盘上，写入性能较高。如果是uuid等字符串形式，频繁的插入会使innodb频繁地移动磁盘块，写入性能就比较低了。</p></blockquote><p><strong>innodb引擎索引why使用了B+树结构，那么为什么不是其他类型树结构，例如二叉树呢？</strong></p><blockquote><p>计算机在存储数据的时候，有最小存储单元，这就好比人民币流通最小单位是分一样。文件系统的最小单元是块，一个块的大小是4k（这个值根据系统不同并且可设置），InnoDB存储引擎也有自己的最小储存单元—页（Page），一个页的大小是16K（这个值也是可设置的）。</p><p>文件系统中一个文件大小只有1个字节，但不得不占磁盘上4KB的空间。同理，innodb的所有数据文件的大小始终都是16384（16k）的整数倍。</p><p>所以在MySQL中，存放索引的一个块节点占16k，mysql每次IO操作会利用系统的预读能力一次加载16K。这样，如果这一个节点只放1个索引值是非常浪费的，因为一次IO只能获取一个索引值，所以不能使用二叉树。</p><p>B+树是多路查找树，一个节点能放n个值，n = 16K / 每个索引值的大小。<br>例如索引字段大小1Kb，这时候每个节点能放的索引值理论上是16个，这种情况下，二叉树一次IO只能加载一个索引值，而B+树则能加载16个。</p><p>B+树的路数为n+1，n是每个节点存在的值数量，例如每个节点存放16个值，那么这棵树就是17路。</p><p>从这里也能看出，B+树节点可存储多个值，所以B+树索引并不能找到一个给定键值的具体行。B+树只能找到存放数据行的具体页，然后把页读入到内存中，再在内存中查找指定的数据。</p><p>附：B树和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。</p></blockquote><p><strong>辅助索引</strong></p><blockquote><p>也称为非聚集索引，其叶子节点不包含行记录的全部数据，叶子结点除了包含键值以外，每个叶子结点中的索引行还包含一个书签，该书签就是相应行的聚集索引键。</p><p>创建的索引，如联合索引、唯一索引等，都属于非聚簇索引</p><p>联合索引是指对表上的多个列进行索引。联合索引也是一颗B+树，不同的是联合索引的键值数量不是1，而是大于等于2。联合索引的另一个好处已经对第二个键值进行了排序处理，有时候可以避免多一次的排序操作。</p><pre><code class="hljs sql">&gt;create index idx_age_name on user(age, name)</code></pre><p>覆盖索引，即从辅助索引中就可以得到查询所需要的所有字段值，而不需要查询聚集索引中的记录。覆盖索引的好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。</p><p>联合索引中如果不是按照索引最左列开始查找，无法使用索引；</p><p>必须把字段定义为NOT NULL并且提供默认值</p><p>禁止在更新十分频繁、区分度不高的属性上建立索引——更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能</p><p>禁止使用OR条件，必须改为IN查询</p></blockquote><p><strong>非聚簇索引一定会回表查询吗？</strong></p><blockquote><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p><p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询</p></blockquote><p> <strong>联合索引是什么？为什么需要注意联合索引中的顺序？</strong></p><blockquote><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p><p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p></blockquote><p><strong>ACID</strong></p><blockquote><p>原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p><p>一致性：执行事务前后，数据保持一致，事务前后数据的完整性必须保持一致。如果做一个财务系统，账户A转钱到账户B，那么账户A中减少的钱与账户B中增加的钱必须相等。</p><p>隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p><p>持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></blockquote><p><strong>脏读？幻读？不可重复读？</strong></p><blockquote><p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p><p>不可重复读(Non-repeatable read)：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。</p><p>幻读(Phantom Read):幻读是指一个<strong>事务内多次根据同一条件查询出来的记录行数</strong>不一致。，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p><p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p></blockquote><p><strong>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</strong></p><blockquote><p>数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable</p><p>READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p><p>READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p><p>REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p><p>SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p><p>Mysql 默认采用的 REPEATABLE_READ隔离级别</p><p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p></blockquote><p><strong>隔离级别与锁的关系</strong></p><blockquote><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p><p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p><p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p><p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p></blockquote><p><strong>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</strong></p><blockquote><p>在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p><p>MyISAM和InnoDB存储引擎使用的锁：</p><ul><li>MyISAM采用表级锁(table-level locking)。</li><li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li></ul><p>行级锁 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p><p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><p>表级锁 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p><p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p><p>页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p><p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p></blockquote><p>为何行级锁比表级锁开销大?</p><blockquote><p>可能是因为要判断每一行是否加锁？？</p></blockquote><p>MVCC</p><blockquote><p>MVCC定义：多版并发控制系统。可认为是行级锁的一个变种，它能够避免更多情况下的加锁操作。</p><p>作用：避免一些加锁操作，提升并发性能。</p><p>实现：通过在每行记录的后面保存行的创建时间和过期时间或删除时间（它们是隐藏的），这两个时间实际都是系统的版本号。每开始一个新的事务，版本号都会自动增加。</p><p>具体原理<br>select：innoBD查询时会检查以下两个条件：一个是数据行的版本号早于当前事务的版本号；另一个是行的删除版本号，要么没有，要么大于当前事务的版本号。</p><p>insert/delete：innoDB将当前的系统版本号作为新插入(删除)的数据行的版本号。</p><p>update：先新插入一行数据，并将当前系统版本号作为行的版本号，同时将当前系统版本号作为原来行的删除版本号。更新主键时，聚集索引和普通索引都会产生两个版本；而更新非主键时，只要普通索引会产生两个版本。</p><p>注意：MVCC只在read committed和repeatable read两个隔离级别下工作。</p><p>MVCC通过保存数据的历史版本，根据比较版本号来处理数据的是否显示，从而达到读取数据的时候不需要加锁就可以保证事务隔离性的效果</p></blockquote><p><strong>从锁的类别上分MySQL都有哪些锁呢？</strong></p><blockquote><p>从锁的类别上来讲，有共享锁和排他锁。</p><p>共享锁: 又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p><p>排他锁: 又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p><p>锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p></blockquote><p><strong>什么是死锁？怎么解决？</strong></p><blockquote><p>锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p>常见的解决死锁的方法</p><p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p><p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p><p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p><p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p></blockquote><p><strong>数据库的乐观锁和悲观锁是什么？怎么实现的？</strong></p><blockquote><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p><p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p></blockquote><p> <strong>SQL 约束有哪几种</strong></p><blockquote><p>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</p><p>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</p><p>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</p><p>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p><p>CHECK: 用于控制字段的值范围。</p></blockquote><p><strong>mysql中 in 和 exists 区别</strong></p><blockquote><p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询</p><p>如果查询的两个表大小相当，那么用in和exists差别不大。</p><p>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</p><p>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快</p></blockquote><p><strong>varchar与char的区别</strong></p><blockquote><p>char的特点</p><ul><li>char表示定长字符串，长度是固定的；</li><li>如果插入数据的长度小于char的固定长度时，则用空格填充；</li><li>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li><li>对于char来说，最多能存放的字符个数为255，和编码无关</li></ul><p>varchar的特点</p><ul><li>varchar表示可变长字符串，长度是可变的；</li><li>插入的数据是多长，就按照多长来存储；</li><li>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li><li>对于varchar来说，最多能存放的字符个数为65532</li></ul><p>总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</p><p><strong>varchar(50)中50的涵义</strong>：最多存放50个字符</p></blockquote><p> <strong>FLOAT和DOUBLE的区别是什么？</strong></p><blockquote><ul><li>FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</li><li>DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</li></ul></blockquote><p> <strong>drop、delete与truncate的区别</strong></p><blockquote><p>在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200620154955.jpg" srcset="/img/loading.gif" alt="img"></p><p> <strong>UNION与UNION ALL的区别？</strong></p><blockquote><ul><li>如果使用UNION ALL，不会合并重复的记录行</li><li>效率 UNION 高于 UNION ALL</li></ul></blockquote><p><strong>如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</strong></p><blockquote><p>使用explain命令来查看语句的执行计划</p><p>type(非常重要，可以看到有没有走索引) 访问类型</p></blockquote><p><strong>为什么要尽量设定一个主键？</strong></p><blockquote><p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p></blockquote><p><strong>主键使用自增ID还是UUID？</strong></p><blockquote><p>推荐使用自增ID，不要使用UUID。</p><p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p><p>总之，在数据量大一些的情况下，用自增主键性能会好一些。</p><p>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</p></blockquote><p><strong>字段为什么要求定义为not null？</strong></p><blockquote><p>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p></blockquote><p><strong>SQL语句优化的一些方法？</strong></p><blockquote><ul><li>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</li><li>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描</li><li>5.in 和 not in 也要慎用，否则会导致全表扫描，</li></ul></blockquote><p><strong>数据库优化</strong></p><blockquote><h3 id="1-为什么要优化"><a href="#1-为什么要优化" class="headerlink" title="1. 为什么要优化"></a><strong>1. 为什么要优化</strong></h3><ul><li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li><li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li><li>数据是存放在磁盘上的，读写速度无法和内存相比</li></ul><p>优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p></blockquote><p><strong>分库分表</strong></p><blockquote><p>主要有垂直分表和水平分表</p><p>垂直分区：<br>根据数据库里面数据表的相关性进行拆分。例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。<br>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。如下图所示，这样来说大家应该就更容易理解了。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200620155905.jpg" srcset="/img/loading.gif" alt="img"></p><p>垂直拆分的优点：可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p><p>垂直拆分的缺点：主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p><p><strong>水平分表：</strong></p><p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p></blockquote><p><strong>一些常见的主键生成策略</strong></p><blockquote><p>UUID 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。</p></blockquote><p><strong>MySQL的复制原理以及流程</strong></p><blockquote><p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p></blockquote><p><strong>主从复制的作用</strong></p><blockquote><ol><li>主数据库出现问题，可以切换到从数据库。</li><li>可以进行数据库层面的读写分离。</li><li>可以在从数据库上进行日常备份。</li></ol></blockquote><p>MySQL<strong>主从复制解决的问题</strong></p><blockquote><ul><li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li><li>负载均衡：降低单个服务器的压力</li><li>高可用和故障切换：帮助应用程序避免单点失败</li><li>升级测试：可以用更高版本的MySQL作为从库</li></ul></blockquote><p><strong>读写分离有哪些解决方案？</strong></p><blockquote><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读</p></blockquote><p> <strong>数据表损坏的修复方式有哪些？</strong></p><blockquote><p>使用 myisamchk 来修复，具体步骤：</p><ul><li>1）修复前将mysql服务停止。</li><li>2）打开命令行方式，然后进入到mysql的/bin目录。</li><li>3）执行myisamchk –recover 数据库所在路径/*.MYI</li><li></li></ul></blockquote><p>问题+答案来源：</p><p>知乎：<a href="https://zhuanlan.zhihu.com/p/59838091" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59838091</a></p><p>​        <a href="https://zhuanlan.zhihu.com/p/114993399" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/114993399</a></p><p><a href="https://zhuanlan.zhihu.com/p/107125866" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/107125866</a></p>]]></content>
    
    
    <categories>
      
      <category>复习大纲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssm</title>
    <link href="/2020/06/19/ssm/"/>
    <url>/2020/06/19/ssm/</url>
    
    <content type="html"><![CDATA[<h1 id="SSM面试问题"><a href="#SSM面试问题" class="headerlink" title="SSM面试问题"></a>SSM面试问题</h1><ol><li>Spring框架用到了哪些设计模式。</li><li>Spring生命周期详细描述。</li><li>Spring是如何解决循环依赖的。</li><li>Spring扩展点有哪些，项目中是如何应用的。</li><li>Spring IOC、AOP描述。</li><li>Spring事务和MySQL事务的区别，Spring事务传播机制介绍，Spring事务失效和解决方案。</li><li>Spring全局异常捕获如何编写。</li><li>AOP动态代理实现：jdk动态代理和cglib实现差异，cglib性能为什么比jdk动态代理性能高，Fastclass机制描述下，哪些方法不能被动态代理。</li><li>AOP失效举例，为什么会失效，如何解决。</li><li>BeanFactory和FactoryBean的区别。</li><li>Spring创建了单例对象，如果多线程并发对属性赋值，造成相互覆盖的情况，如何处理。</li><li>SpringMVC和SpringBoot的区别。</li></ol><p>spring的两大特性- ioc aop，实现原理</p><p>如果存在A依赖B，B依赖A，那么是怎么加到IOC中去的</p><p>beanFactory的理解，怎么加载bean</p><p>FactoryBean的理解</p><p>基于注解的形式，是怎么实现的， 你知道其原理吗，说一下</p><p>依赖冲突，有碰到过吗，你是怎么解决的~</p><p>bean的生命周期</p><p>spring中的自动装配方式</p><p>BeanFactory 和 FactoryBean</p><p>Spring IOC 的理解，其初始化过程？</p><p>BeanFactory 和 ApplicationContext？</p><p>Spring Bean 的生命周期，如何被管理的？Spring Bean 的加载过程是怎样的？</p><p>如果要你实现Spring AOP，请问怎么实现？</p><p>如果要你实现Spring IOC，你会注意哪些问题？</p><p>Spring 是如何管理事务的，事务管理机制？</p><p>Spring 的不同事务传播行为有哪些，干什么用的？</p><p>Spring 中用到了那些设计模式？</p><p>Spring MVC 的工作原理？</p><p>Spring 循环注入的原理？</p><p>Spring 如何保证 Controller 并发的安全？</p><p>你一般是怎么对mvc项目进行分层的</p><p>dispatch-servlet的工作原理</p><p>为什么有了springmvc还要在项目中使用spring？</p><p>springmvc的运行机制，dispatch -》 hanldermapping-—》handler -》handlerAdapter-》执行handler-》modelandview -》 返回mv -》 视图解析器-》返回view -》 渲染响应</p><p>怎么防止依赖注入</p><p>怎么让mapper 和xml对应</p><p>如何自动包装对象</p><p>和spring相比，做了什么改变</p><p>starter你知道哪些</p><p>如何部署springmvc项目 以及如何部署springboot项目</p><p>springboot的插件，你使用过哪些</p>]]></content>
    
    
    <categories>
      
      <category>复习大纲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm</title>
    <link href="/2020/06/19/jvm/"/>
    <url>/2020/06/19/jvm/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM面试问题"><a href="#JVM面试问题" class="headerlink" title="JVM面试问题"></a>JVM面试问题</h1><p>1、 JVM运行时数据区域和内存模型描述，jdk8为什么移除方法区。</p><p>2、 垃圾回收算法和垃圾回收器描述，在工作中，新生代和老年代分别用的什么垃圾回收器。</p><p>3、 新生代和老年代什么时候会触发GC。</p><p>4、 四种引用区别。</p><p>5、 CMS垃圾回收过程描述，CMS有哪些缺点，对比G1。</p><p>6、GC调优步骤，有实操过吗。</p><p>7、描述下JVM类加载过程，如何自定义类加载器。</p><blockquote><p>加载</p><p>加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。类的加载由类加载器完成，类加载器通常由JVM提供</p><p>连接</p><p>​    验证：主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。包括对于<strong>文件格式的验证</strong>，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</p><p>对于<strong>元数据的验证</strong>，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</p><p>对于<strong>字节码的验证</strong>，保证程序语义的合理性，比如要保证类型转换的合理性。</p><p>对于<strong>符号引用的验证</strong>，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p><p>​    准备：主要是为类变量（注意，不是实例变量）分配内存，并且赋予<strong>初值</strong>。</p><p>​    解析：将常量池内的符号引用替换为直接引用的过程。</p><p><strong>符号引用</strong>。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。</p><p><strong>直接引用</strong>。可以理解为一个内存地址，或者一个偏移量。比如<strong>类方法，类变量</strong>的直接引用是指向方法区的<strong>指针</strong>；而<strong>实例方法，实例变量</strong>的直接引用则是从实例的头指针开始算起到这个实例变量位置的<strong>偏移量</strong></p><p>初始化：这个阶段主要是对<strong>类变量</strong>初始化，是执行类构造器的过程。</p></blockquote><p>8、 描述下双亲委派模型，为什么需要双亲委派模型。</p><p>9、 泛型是如何实现的，逃逸分析知道吗，说下。</p><p>10、 OOM、内存泄漏如何排查，用到哪些工具，如果不用工具如何进行定位。</p><p>11、 机器负载变高如何排查，如果发现是jvm进程引起的，如何定位到代码行。</p><p>12、内存模型以及分区，需要详细到每个区放什么。</p><p>13、堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。</p><p>14、对象创建方法，对象的内存分配，对象的访问定位。</p><p>15、GC 的两种判定方法</p><blockquote><p>引用计数</p><p>可达性分析：GC Roots基本思路就是通过一系列的称为“GC Roots”的对象作为起始点， 从这些节点开始向下搜索， 搜索所走过的路径称为引用链（ Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（ 用图论的话来 说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的</p><p>GC Roots有以下几种：</p><ul><li><strong>虚拟机栈（栈帧中的局部变量表，Local Variable Table）</strong>中引用的对象。</li><li><strong>方法区中类静态属性</strong>引用的对象。</li><li><strong>方法区中常量</strong>引用的对象。</li><li><strong>本地方法栈中JNI（即一般说的Native方法）</strong>引用的对象。</li></ul><p>常量池是个什么东西？并不是说常量池就像一个池子一样，常量都装在里面，实际上常量池里面放的只是一些引用，这些引用指向了堆中的具体的对象。</p><p>方法区中有一个常量池叫做运行时常量池，方法区外有个常量池叫做字符串常量池，后者是全局共享的</p><p><a href="https://www.zhihu.com/question/55328596/answer/144027981" target="_blank" rel="noopener">https://www.zhihu.com/question/55328596/answer/144027981</a></p></blockquote><p>16、GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？</p><p>17、GC 收集器有哪些？CMS 收集器与 G1 收集器的特点</p><blockquote><p><strong>第一阶段，Serial（串行）收集器</strong></p><p>Serial收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p><p><strong>第二阶段，Parallel（并行）收集器</strong></p><p>Parallel收集器也称吞吐量收集器，相比Serial收集器，Parallel最主要的优势在于使用多线程去完成垃圾清理工作，这样可以充分利用多核的特性，大幅降低gc时间。</p><p><strong>第三阶段，CMS（并发）收集器</strong></p><p>CMS收集器在Minor GC时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。在Full GC时不再暂停应用线程，而是使用若干个后台线程定期的对老年代空间进行扫描，及时回收其中不再使用的对象。</p><p><strong>第四阶段，G1（并发）收集器</strong></p><p><strong>Serial 收集器</strong></p><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用复制算法，老年代采用标记 - 整理算法。</strong></p><p><strong>3．ParNew 收集器</strong></p><p>ParNew 收集器其实就是 Serial 收集器的<strong>多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p><p><strong>新生代采用复制算法，老年代采用标记 - 整理算法。</strong></p><p><strong>4．Parallel Scavenge 收集器</strong></p><p>Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。</p><p>Parallel Scavenge 收集器<strong>关注点是吞吐量</strong>（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</p><p><strong>5．Serial Old 收集器</strong></p><p>Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><p><strong>6．Parallel Old 收集器</strong></p><p>Parallel Scavenge 收集器的老年代版本。使用多线程和 “标记 - 整理” 算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><p><strong>7．CMS 收集器</strong></p><p>CMS（Concurrent Mark Sweep）收集器是一种<strong>以获取最短回收停顿时间为目标</strong>的收集器。它而非常符合在注重用户体验的应用上使用。</p><p>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的<strong>并发收集器</strong>，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p><p>从名字中的 Mark Sweep 这两个词可以看出，CMS 收集器是一种 “标记 - 清除” 算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。<strong>整个过程分为四个步骤：</strong></p><p><strong>（1）初始标记：</strong> 暂停所有的其他线程，并记录下直接与 GC Root 相连的对象，速度很快 ； </p><p><strong>（2）并发标记：</strong> 从GC Root的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，用户线程可以与垃圾收集线程并发运行</p><p><strong>（3）重新标记：</strong> <strong>修正</strong>并发标记期间，因用户程序继续运行导致标记产生变动的那一部分对象的标记记录</p><p><strong>（4）并发清除：</strong> 开启用户线程，同时 GC 线程开始对为标记的区域做清扫</p><p>CMS收集器是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li>对 CPU 资源敏感；</li><li>无法处理浮动垃圾；</li><li>它使用的回收算法 -“<strong>标记 - 清除</strong>” 算法会导致收集结束时<strong>会有大量空间碎片</strong>产生。</li></ul><p><strong>8．G1 收集器</strong></p><p>G1垃圾收集算法主要应用在多CPU大内存的服务中，在满足高吞吐量的同时，尽可能的满足垃圾回收时的暂停时间，G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。运作过程分为四个步骤</p><p>初始标记：标记GC Roots能直接关联到的对象，需要停顿线程。（找出还在用的对象）</p><p>并发标记：从GC Roots开始对堆中对象进行可达性分析，找出要回收的对象，但可以与用户程序并发运行，不需要停顿线程。（找出不再被使用的对象）</p><p>最终标记：处理并发标记遗留下的对象，暂停用户线程</p><p>筛选回收：对各个区域进行内存回收，暂停用户线程</p><p><strong>G1收集器的最大特点</strong></p><ul><li>G1最大的特点是引入分区的思路，弱化了分代的概念。</li></ul><p><strong>G1相比较CMS的改进</strong></p><ul><li>算法： G1基于<strong>标记-整理</strong>算法, 不会产生空间碎片，分配大对象时不会无法得到连续的空间而提前触发一次FULL GC。</li><li>停顿时间可控： G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象。</li><li>并行与并发：G1能更充分的利用CPU，多核环境下的硬件优势来缩短stop the world的停顿时间。</li></ul><p><strong>CMS和G1的区别</strong></p><ul><li>CMS中，堆被分为PermGen，YoungGen，OldGen；而YoungGen又分了两个survivo区域。在G1中，堆被平均分成几个区域(region)，在每个区域中，虽然也保留了新老代的概念，但是收集器是以整个区域为单位收集的。</li><li>G1在回收内存后会马上同时做合并空闲内存的工作、而CMS默认是在STW（stop the world）的时候做。</li><li>G1会在Young GC中使用、而CMS只能在O区使用。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/59861022" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59861022</a></p></blockquote><p>18、Minor GC 与 Full GC 分别在什么时候发生？</p><p>19、JVM 内存分哪几个区，每个区的作用是什么?</p><p>20、如和判断一个对象是否存活?(或者 GC 对象的判定方法)</p><p>21、java 中垃圾收集的方法有哪些?</p><p>22、类加载器双亲委派模型机制？</p><p>23、java 内存模型，java 类加载过程?</p><p>24、什么是类加载器，类加载器有哪些?</p><p>25、简述 java 内存分配与回收策率以及 Minor GC 和Major GC</p>]]></content>
    
    
    <categories>
      
      <category>复习大纲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云服务器搭建</title>
    <link href="/2020/06/19/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/06/19/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云服务器搭建"><a href="#阿里云服务器搭建" class="headerlink" title="阿里云服务器搭建"></a>阿里云服务器搭建</h1><h2 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h2><p>阿里云因为疫情推出了一个阿里云高校学生计划，学生党可以白嫖一个六个月的阿里云服务器</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200619080813.png" srcset="/img/loading.gif" alt="image-20200619080806048"></p><p>购买好服务器之后，进行服务器的搭建</p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>首先配置自己的安全组策略：添加常用端口，如3306,6379,443,80等，然后修改自己的实例名称：</p><p>进入控制台，选择左侧的安全组</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200619091307.png" srcset="/img/loading.gif" alt=""></p><p>点击界面右侧的配置规则</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200619090425.png" srcset="/img/loading.gif" alt="image-20200619090420490"></p><p>选择手动添加，添加常用端口</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200619090251.png" srcset="/img/loading.gif" alt="image-20200619090241653"></p><pre><code class="hljs bash"><span class="hljs-comment">#查看自己的实例名称</span>hostname<span class="hljs-comment">#修改名称为XX</span>hostnamectl <span class="hljs-built_in">set</span>-hostname XX</code></pre><p>重启服务器，修改名称成功</p><p>查看服务器公网IP地址，使用Xshell连接服务器，输入公网IP地址。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200619090517.png" srcset="/img/loading.gif" alt="image-20200619090513223"></p><p>输入密码后，看到welcome to Alibaba，代表成功进入服务器界面：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200619091807.png" srcset="/img/loading.gif" alt=""></p><p>如果需要将本地文件传到服务器，建议安装一个Xftp。直接拖动即可安装</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200619091959.png" srcset="/img/loading.gif" alt="image-20200619091955787"></p><h2 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h2><p>linux系统下一切皆文件，所有文件都挂在在节点根目录/下</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200619094100.png" srcset="/img/loading.gif" alt="image-20200619094057537"></p><p>目录解释：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200619094617.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200619094642.png" srcset="/img/loading.gif" alt="image-20200619094638755"></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code class="hljs bash">getconf LONG_BIT <span class="hljs-comment">#查看自己的linux是多少位</span>synch <span class="hljs-comment">#同步数据，linux没有报错，就是成功！！！</span>shutdown <span class="hljs-comment">#关机</span>reboot <span class="hljs-comment">#重启</span>ls <span class="hljs-comment">#查看当前目录下文件</span><span class="hljs-built_in">pwd</span> <span class="hljs-comment">#显示当前用户所在的目录</span>mkdir <span class="hljs-comment">#创建目录 -p递归创建文件夹</span>cp <span class="hljs-built_in">source</span> distin <span class="hljs-comment">#拷贝文件，从原位置到目的位置</span>rm <span class="hljs-comment">#移出目录 -f强制删除  -r递归删除目录  rm -rf /删除系统中所有文件</span>mv <span class="hljs-comment">#移动文件夹或者重命名文件  </span>ls -ll<span class="hljs-comment">#查看权限， r-4 w-2 x-1:777表示所有用户可读可写可执行   owner/group/other三者权限</span><span class="hljs-comment">#文件命令</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2020/06/16/SpringBoot/"/>
    <url>/2020/06/16/SpringBoot/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p> 微服务：一种架构风格，即开发应用时，要求这个应用必须由一系列小服务组合而成，可以通过HTTP/RPC的方式通信。</p><p>架构演变：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200616200529.png" srcset="/img/loading.gif" alt="image-20200616200524709"></p><p>微服务</p><p>每一个功能元素块都是一个可替换、可独立升级的软件代码</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200616200710.png" srcset="/img/loading.gif" alt="image-20200616200707622"></p><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>启动器:springboot的启动场景。</p><p>比如spring-boot-starter-web就会自动导入web环境所有的依赖，springboot会将所有的功能场景都变成启动器，需要什么功能，找到对应的启动器即可</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200617100253.png" srcset="/img/loading.gif" alt="image-20200617100249387"></p><h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-comment">//标注这个类是springboot的应用，导入启动类下的所有资源</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot01HelloworldApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(Springboot01HelloworldApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;<span class="hljs-comment">//启动springboot应用，通过反射加载这个类</span>    &#125;&#125;</code></pre><h3 id="注解-SpringBootApplication"><a href="#注解-SpringBootApplication" class="headerlink" title="注解@SpringBootApplication"></a>注解@SpringBootApplication</h3><p>组成成分</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.TYPE)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-meta">@Inherited</span><span class="hljs-meta">@SpringBootConfiguration</span><span class="hljs-comment">//核心，springboot的配置</span><span class="hljs-meta">@EnableAutoConfiguration</span><span class="hljs-comment">//核心。自动配置</span><span class="hljs-meta">@ComponentScan</span>(excludeFilters = &#123; <span class="hljs-meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>),//扫描包</span><span class="hljs-class">@<span class="hljs-title">Filter</span>(<span class="hljs-title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>) &#125;)</span></code></pre><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>组成成分</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.TYPE)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-meta">@Configuration</span><span class="hljs-comment">//代表它是一个spring配置类</span></code></pre><h5 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h5><p>组成成分</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-meta">@Component</span></code></pre><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.TYPE)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-meta">@Inherited</span><span class="hljs-meta">@AutoConfigurationPackage</span><span class="hljs-comment">//自动配置包</span><span class="hljs-meta">@Import</span>(AutoConfigurationImportSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>)//自动配置导入选择器</span></code></pre><h5 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h5><p>组成成分</p><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.TYPE)<span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-variable">@Documented</span><span class="hljs-variable">@Inherited</span><span class="hljs-variable">@Import</span>(AutoConfigurationPackages.Registrar.class)<span class="hljs-comment">//自动配置包</span></code></pre><h5 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)"></a>@Import(AutoConfigurationImportSelector.class)</h5><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoConfigurationPackages</span></span></code></pre><p>结论：springboot的所有自动配置都是在启动的时候扫描并加载：/META-INF/spring.factories的所有自动配置类都在这里面，但是不一定生效，要判断条件是否成立，只要导入对应starter（启动器），才会生效。核心注解：<code>ConditionalOnXX</code></p><h2 id="Sptingboot配置"><a href="#Sptingboot配置" class="headerlink" title="Sptingboot配置"></a>Sptingboot配置</h2><h3 id="yml"><a href="#yml" class="headerlink" title="yml"></a>yml</h3><p>实体类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.guo.pojo;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-meta">@Component</span><span class="hljs-comment">//声明组件</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"person"</span>)<span class="hljs-comment">//将配置文件中配置的每一个属性都映射到这个组件中</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> Boolean happy;    <span class="hljs-keyword">private</span> Date birth;    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; maps;    <span class="hljs-keyword">private</span> List&lt;Object&gt; list;    <span class="hljs-keyword">private</span> Dog dog;<span class="hljs-comment">//省略有参构造、无参构造、tostring、gettter和setter方法</span>&#125;<span class="hljs-comment">//dog</span><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"旺财"</span>)    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"3"</span>)    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;&#125;</code></pre><p>yml配置</p><pre><code class="hljs yml"><span class="hljs-attr">person:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">gt</span>  <span class="hljs-attr">age:</span> <span class="hljs-number">3</span>  <span class="hljs-attr">happy:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">bitrh:</span> <span class="hljs-number">2020</span><span class="hljs-string">/2/2</span>  <span class="hljs-attr">maps:</span> <span class="hljs-string">&#123;k1:</span> <span class="hljs-string">v1,k2:</span> <span class="hljs-string">v2&#125;</span>  <span class="hljs-attr">list:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">music</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">dog</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">girl</span>  <span class="hljs-attr">dog:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">wa</span>    <span class="hljs-attr">age:</span> <span class="hljs-number">4</span></code></pre><p>测试类</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot02ConfigApplicationTests</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Person person;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Dog dog;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(person);    &#125;&#125;</code></pre><p>输出</p><pre><code class="hljs java">Person&#123;name=<span class="hljs-string">'gt'</span>, age=<span class="hljs-number">3</span>, happy=<span class="hljs-keyword">true</span>, birth=<span class="hljs-keyword">null</span>, maps=&#123;k1=v1, k2=v2&#125;, list=[music, dog, girl], dog=Dog&#123;name=<span class="hljs-string">'wa'</span>, age=<span class="hljs-number">4</span>&#125;&#125;</code></pre><p>yaml优点：</p><p>支持松散绑定</p><blockquote><p>比如类中名字是 last-name，和lastName是一样的，-后面跟着的字母默认是大写的，这就是松散绑定</p></blockquote><h3 id="JSR303校验"><a href="#JSR303校验" class="headerlink" title="JSR303校验"></a>JSR303校验</h3><p>指定数据类型，如果不是指定类型就会报错。</p><h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><p>@ConditionalOnXX</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200617095621.png" srcset="/img/loading.gif" alt="image-20200617095616759"></p><p>@@ConfigurationProperties(prefix = “person”)</p><p>绑定person类下的所有配置，spring会去properties下面找默认值</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSM项目</title>
    <link href="/2020/06/16/SSM%E9%A1%B9%E7%9B%AE/"/>
    <url>/2020/06/16/SSM%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="SSM项目"><a href="#SSM项目" class="headerlink" title="SSM项目"></a>SSM项目</h1><p>资料：<a href="https://mp.weixin.qq.com/s/SDxqGu_il3MUCTcN1EYrng" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SDxqGu_il3MUCTcN1EYrng</a></p>]]></content>
    
    
    <categories>
      
      <category>SSM</category>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/2020/06/15/Mybatis/"/>
    <url>/2020/06/15/Mybatis/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><p>Mybatis是一款持久层框架。持久层负责数据的持久化，即把数据从内存中写入到数据库中。Mybatis简化了传统的JDBC代码，帮助程序员把数据写入到数据库中。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>导入maven依赖</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p>核心配置文件—-目的是连接数据库</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><span class="hljs-meta">  <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><span class="hljs-meta">  <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.jdbc.Driver"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="hljs-symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"org/mybatis/example/BlogMapper.xml"</span>/&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><p>编写mybatis工具类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.guo.utils;<span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-comment">//SqlSessionFactory</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//获取SqlSessionFactory对象</span>            String resource=<span class="hljs-string">"mybatis-config.xml"</span>;            InputStream inputStream = <span class="hljs-keyword">null</span>;            inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getsqlSession</span><span class="hljs-params">()</span></span>&#123;        SqlSession sqlSession=sqlSessionFactory.openSession();        <span class="hljs-keyword">return</span> sqlSession;    &#125;&#125;</code></pre><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>编写实体类pojo</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String pwd;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name, String pwd)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.pwd = pwd;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPwd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> pwd;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPwd</span><span class="hljs-params">(String pwd)</span> </span>&#123;        <span class="hljs-keyword">this</span>.pwd = pwd;    &#125;&#125;</code></pre><p>编写dao接口</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.guo.pojo.User;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserList</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>用Mapper.xml配置接口实现类</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><span class="hljs-meta">        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><span class="hljs-comment">&lt;!--namespace绑定一个对应的dao/mapper接口--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.guo.dao.UserDao"</span>&gt;</span><span class="hljs-comment">&lt;!--    查询语句，id对应方法名字,resultType：返回结果--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserList"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"com.guo.pojo.User"</span>&gt;</span>    select * from mybatis.user  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><p>测试代码</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;    SqlSession sqlSession = MyBatisUtils.getsqlSession();    UserDao mapper = sqlSession.getMapper(UserDao<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    List&lt;User&gt; userList = mapper.getUserList();    <span class="hljs-keyword">for</span> (User user : userList) &#123;        System.out.println(user);    &#125;    sqlSession.close();&#125;</code></pre><p>Mybatis核心接口</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200615204833.png" srcset="/img/loading.gif" alt=""></p><h3 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h3><p>配置文件 </p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><span class="hljs-meta">        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><span class="hljs-comment">&lt;!--namespace绑定一个对应的dao/mapper接口--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.guo.dao.UserMapper"</span>&gt;</span><span class="hljs-comment">&lt;!--    查询语句，id对应方法名字,resultType：返回结果--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserList"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"com.guo.pojo.User"</span>&gt;</span>    select * from mybatis.user  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-comment">&lt;!--    根据id查询用户，parameterType：参数类型--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserById"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"com.guo.pojo.User"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"int"</span>&gt;</span>    select * from mybatis.user where id=#&#123;id&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insertUser"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.guo.pojo.User"</span>&gt;</span>    insert into mybatis.user (id,name,pwd) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateUser"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.guo.pojo.User"</span>&gt;</span>        update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125;   where id=#&#123;id&#125;;    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"deleteUser"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"int"</span>&gt;</span>        delete from mybatis.user where id=#&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><p>查询所有用户</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;    SqlSession sqlSession = MyBatisUtils.getsqlSession();    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    List&lt;User&gt; userList = mapper.getUserList();    <span class="hljs-keyword">for</span> (User user : userList) &#123;        System.out.println(user);    &#125;    sqlSession.close();&#125;</code></pre><p>根据id查询用户</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getUserById</span><span class="hljs-params">()</span></span>&#123;    SqlSession sqlSession = MyBatisUtils.getsqlSession();    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    User userById = mapper.getUserById(<span class="hljs-number">3</span>);    System.out.println(userById);    sqlSession.close();&#125;</code></pre><p>增加一个用户</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertUser</span><span class="hljs-params">()</span></span>&#123;    SqlSession sqlSession = MyBatisUtils.getsqlSession();<span class="hljs-comment">//获取执行sql的对象</span>    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    User user=<span class="hljs-keyword">new</span> User(<span class="hljs-number">5</span>,<span class="hljs-string">"z5"</span>,<span class="hljs-string">"123"</span>);    <span class="hljs-keyword">int</span> i = mapper.insertUser(user);    System.out.println(i);    List&lt;User&gt; userList = mapper.getUserList();    <span class="hljs-keyword">for</span> (User user1 : userList) &#123;        System.out.println(user1);    &#125;    sqlSession.commit();<span class="hljs-comment">//增删改需要提交事务</span>    sqlSession.close();&#125;</code></pre><p>更新一个用户</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">()</span></span>&#123;    SqlSession sqlSession = MyBatisUtils.getsqlSession();    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-keyword">int</span> w6 = mapper.updateUser(<span class="hljs-keyword">new</span> User(<span class="hljs-number">4</span>, <span class="hljs-string">"w6"</span>, <span class="hljs-string">"123"</span>));    System.out.println(w6);    sqlSession.commit();    sqlSession.close();&#125;&#125;</code></pre><p>删除一个用户</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">()</span></span>&#123;    SqlSession sqlSession = MyBatisUtils.getsqlSession();    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-keyword">int</span> i = mapper.deleteUser(<span class="hljs-number">4</span>);    System.out.println(i);    sqlSession.commit();    sqlSession.close();&#125;</code></pre><h3 id="万能Map"><a href="#万能Map" class="headerlink" title="万能Map"></a>万能Map</h3><p>结社，实体类或者数据库中表的字段或者参数过多，就应当考虑使用map</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--使用map以后，可以只写需要变更了字段--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insertUser2"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"map"</span>&gt;</span>    insert into mybatis.user (id,pwd) values(#&#123;id&#125;,#&#123;pwd&#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertUser2</span><span class="hljs-params">()</span></span>&#123;    SqlSession sqlSession = MyBatisUtils.getsqlSession();<span class="hljs-comment">//获取执行sql的对象</span>    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    Map&lt;String,Object&gt; map=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">"id"</span>,<span class="hljs-number">60</span>);    map.put(<span class="hljs-string">"pwd"</span>,<span class="hljs-string">"123"</span>);    mapper.insertUser2(map);    sqlSession.commit();<span class="hljs-comment">//增删改需要提交事务</span>    sqlSession.close();&#125;<span class="hljs-comment">//接口定义</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertUser2</span><span class="hljs-params">(Map&lt;String,Object&gt; map)</span></span>;</code></pre><h2 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h2><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200615215337.png" srcset="/img/loading.gif" alt="image-20200615215332987"></p><p>注意：配置文件的熟悉也有严格规范</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200615215657.png" srcset="/img/loading.gif" alt="image-20200615215653270"></p><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。</p><pre><code class="hljs properties"><span class="hljs-meta">&lt;?xml</span> <span class="hljs-string">version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE</span> <span class="hljs-string">configuration</span>        <span class="hljs-attr">PUBLIC</span> <span class="hljs-string">"-//mybatis.org//DTD Config 3.0//EN"</span>        <span class="hljs-meta">"http</span>:<span class="hljs-string">//mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span><span class="hljs-attr">&lt;configuration&gt;</span><span class="hljs-meta">&lt;!--</span>    <span class="hljs-string">引入外部配置文件--&gt;</span>    <span class="hljs-meta">&lt;properties</span> <span class="hljs-string">resource="db.properties"&gt;&lt;/properties&gt;</span>    <span class="hljs-meta">&lt;environments</span> <span class="hljs-string">default="development"&gt;</span>        <span class="hljs-meta">&lt;environment</span> <span class="hljs-string">id="development"&gt;</span>            <span class="hljs-meta">&lt;transactionManager</span> <span class="hljs-string">type="JDBC"/&gt;</span>            <span class="hljs-meta">&lt;dataSource</span> <span class="hljs-string">type="POOLED"&gt;</span>                <span class="hljs-meta">&lt;property</span> <span class="hljs-string">name="driver" value="$&#123;driver&#125;"/&gt;</span>                <span class="hljs-meta">&lt;property</span> <span class="hljs-string">name="url" value="$&#123;url&#125;"/&gt;</span>                <span class="hljs-meta">&lt;property</span> <span class="hljs-string">name="username" value="$&#123;username&#125;"/&gt;</span>                <span class="hljs-meta">&lt;property</span> <span class="hljs-string">name="password" value="$&#123;password&#125;"/&gt;</span>            <span class="hljs-attr">&lt;/dataSource&gt;</span>        <span class="hljs-attr">&lt;/environment&gt;</span>    <span class="hljs-attr">&lt;/environments&gt;</span>    <span class="hljs-attr">&lt;mappers&gt;</span>        <span class="hljs-meta">&lt;mapper</span> <span class="hljs-string">resource="com/guo/dao/UserMapper.xml"/&gt;</span>    <span class="hljs-attr">&lt;/mappers&gt;</span><span class="hljs-attr">&lt;/configuration&gt;</span></code></pre><pre><code class="hljs properties"><span class="hljs-attr">driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai</span><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><span class="hljs-attr">password</span>=<span class="hljs-string">root</span></code></pre><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200615220918.png" srcset="/img/loading.gif" alt="image-20200615220914552"></p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><pre><code class="hljs properties"><span class="hljs-attr">&lt;!--为指定的类起别名--&gt;</span><span class="hljs-attr">&lt;typeAliases&gt;</span><span class="hljs-meta">&lt;typeAlias</span> <span class="hljs-string">type="com.guo.pojo.User" alias="user"/&gt;</span><span class="hljs-attr">&lt;/typeAliases&gt;</span></code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserById"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"User"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"int"</span>&gt;</span>    select * from mybatis.user where id=#&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p>也可以为一个包下的类起一个别名，默认使用Bean首字母小写的非限定类名作为别名。如果有注解@Alias(“XX”)，别名为注解XX</p><pre><code class="hljs properties"><span class="hljs-attr">&lt;typeAliases&gt;</span><span class="hljs-meta">&lt;package</span> <span class="hljs-string">name="com.guo.pojo"/&gt;</span><span class="hljs-attr">&lt;/typeAliases&gt;</span></code></pre><h3 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h3><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200615221732.png" srcset="/img/loading.gif" alt=""></p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>SqlSessionFactoryBuilder</p><blockquote><p>一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）</p></blockquote><p>SqlSessionFactory</p><blockquote><p>类似于数据库的连接池</p><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p></blockquote><p>SqlSession</p><blockquote><p>每一个SqlSession可以连接多个Mapper</p><p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域</p><p>用完之后，立刻关闭</p></blockquote><h3 id="结果集映射"><a href="#结果集映射" class="headerlink" title="结果集映射"></a>结果集映射</h3><p>结果集映射解决的问题是属性名和字段名不一致</p><blockquote><p>实体类：id name password</p><p>数据库：id name pwd</p></blockquote><p>查询结果：User{id=3, name=’z3’, password=’null’}</p><p>解决方法：<strong>resultMap</strong>—-&gt;结果集映射</p><blockquote><p><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC <code>ResultSets</code> 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 <code>resultMap</code> 能够代替实现同等功能的数千行代码。ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"User"</span>&gt;</span><span class="hljs-comment">&lt;!--   column是数据库中的字段，  property是实体类中的属性  type是要映射的对象 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"pwd"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"password"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><span class="hljs-comment">&lt;!--    根据id查询用户，parameterType：参数类型--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserById"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"userMap"</span> &gt;</span>select * from mybatis.user where id=#&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-comment">&lt;!--   查询结果：User&#123;id=3, name='z3', password='123'&#125; --&gt;</span></code></pre><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 日志实现：</p><blockquote><p>SLF4J | <strong>LOG4J</strong> | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | <strong>STDOUT_LOGGING</strong> | NO_LOGGING</p></blockquote><h3 id="STDOUT-LOGGING"><a href="#STDOUT-LOGGING" class="headerlink" title="STDOUT_LOGGING"></a><strong>STDOUT_LOGGING</strong></h3><p>使用<strong>STDOUT_LOGGING</strong> —-&gt;标准日志工厂实现</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"logImpl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"STDOUT_LOGGING"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span></code></pre><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200616091203.png" srcset="/img/loading.gif" alt="image-20200616091158941"></p><h3 id="LOG4J"><a href="#LOG4J" class="headerlink" title="LOG4J"></a><strong>LOG4J</strong></h3><p>使用<strong>LOG4J</strong> 需要先导包</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>log4j配置文件</p><pre><code class="hljs properties"><span class="hljs-comment">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">DEBUG,console,file</span><span class="hljs-comment">#控制台输出的相关设置</span><span class="hljs-meta">log4j.appender.console</span> = <span class="hljs-string">org.apache.log4j.ConsoleAppender</span><span class="hljs-meta">log4j.appender.console.Target</span> = <span class="hljs-string">System.out</span><span class="hljs-meta">log4j.appender.console.Threshold</span>=<span class="hljs-string">DEBUG</span><span class="hljs-meta">log4j.appender.console.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="hljs-string">[%c]-%m%n</span><span class="hljs-comment">#文件输出的相关设置</span><span class="hljs-meta">log4j.appender.file</span> = <span class="hljs-string">org.apache.log4j.RollingFileAppender</span><span class="hljs-meta">log4j.appender.file.File</span>=<span class="hljs-string">./log/guo.log</span><span class="hljs-meta">log4j.appender.file.MaxFileSize</span>=<span class="hljs-string">10mb</span><span class="hljs-meta">log4j.appender.file.Threshold</span>=<span class="hljs-string">DEBUG</span><span class="hljs-meta">log4j.appender.file.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.file.layout.ConversionPattern</span>=<span class="hljs-string">[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span><span class="hljs-comment">#日志输出级别</span><span class="hljs-meta">log4j.logger.org.mybatis</span>=<span class="hljs-string">DEBUG</span><span class="hljs-meta">log4j.logger.java.sql</span>=<span class="hljs-string">DEBUG</span><span class="hljs-meta">log4j.logger.java.sql.Statement</span>=<span class="hljs-string">DEBUG</span><span class="hljs-meta">log4j.logger.java.sql.ResultSet</span>=<span class="hljs-string">DEBUG</span><span class="hljs-meta">log4j.logger.java.sql.PreparedStatement</span>=<span class="hljs-string">DEBUG</span></code></pre><p>配置log4j为日志实现</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"logImpl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"LOG4J"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span></code></pre><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200616092307.png" srcset="/img/loading.gif" alt="image-20200616092303514"></p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200616092357.png" srcset="/img/loading.gif" alt="image-20200616092352946"></p><p>使用步骤</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> Logger logger=Logger.getLogger(UserMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLog4j</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    logger.info(<span class="hljs-string">"info:进入log4j方法"</span>);<span class="hljs-comment">//日志级别</span>    logger.debug(<span class="hljs-string">"debug:进入log4j方法"</span>);    logger.error(<span class="hljs-string">"error:进入log4j方法"</span>);&#125;</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>分页目的是减少数据处理量</p><p>sql分页：</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">2</span> <span class="hljs-comment"># 从第一个开始查找，长度为2</span></code></pre><p>使用mybatis：接口、mapper.xml、测试</p><pre><code class="hljs java"><span class="hljs-comment">//接口</span>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserByLimit</span><span class="hljs-params">(Map&lt;String,Integer&gt; map)</span></span>;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"User"</span>&gt;</span>    <span class="hljs-comment">&lt;!--   column是数据库中的字段，  property是实体类中的属性   --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"pwd"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"password"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserByLimit"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"map"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"userMap"</span>&gt;</span>    select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p>测试</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getUserByLimit</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    SqlSession sqlSession = MyBatisUtils.getsqlSession();    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">//mapper相当于一个接口，有了这个接口就可以调用接口中的方法</span>    HashMap&lt;String,Integer&gt; map=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">"startIndex"</span>,<span class="hljs-number">0</span>);    map.put(<span class="hljs-string">"pageSize"</span>,<span class="hljs-number">2</span>);    List&lt;User&gt; userByLimit = mapper.getUserByLimit(map);    <span class="hljs-keyword">for</span> (User user : userByLimit) &#123;        System.out.println(user);    &#125;    sqlSession.close();&#125;</code></pre><h2 id="使用注解开发CRUD"><a href="#使用注解开发CRUD" class="headerlink" title="使用注解开发CRUD"></a>使用注解开发CRUD</h2><p>面向接口编程：目的是<strong>解耦</strong>，上层需用管具体的实现，大家都遵守共同的标准。</p><p>需用在mybatis-config.xml中绑定接口</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.guo.dao.UserMapper"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre><p>简单的可以用注解，复杂的注解就力不从心了。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from user"</span>)    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//方法中有多个参数时，参数前需要加@Param注解，引用类型不需要加@Param注解</span>    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from user where id=#&#123;id&#125;"</span>)    <span class="hljs-function">User <span class="hljs-title">getUserById</span><span class="hljs-params">(@Param(<span class="hljs-string">"id"</span>)</span> <span class="hljs-keyword">int</span> id)</span>;    <span class="hljs-meta">@Insert</span>(<span class="hljs-string">"insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)"</span>)    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertUser</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-meta">@Update</span>(<span class="hljs-string">"update user set name=#&#123;name&#125;,pwd=#&#123;password&#125; where id=#&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-meta">@Delete</span>(<span class="hljs-string">"delete from user where id=#&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(<span class="hljs-keyword">int</span> user)</span></span>;&#125;</code></pre><h2 id="mybatis执行流程"><a href="#mybatis执行流程" class="headerlink" title="mybatis执行流程"></a>mybatis执行流程</h2><p>1：通过resources配置文件获取全局配置文件</p><p>2：实例化构造器：SqlSessionFactoryBuilder</p><p>3：解析配置文件流</p><p>4：实例化SqlSessionFactory</p><p>5：事务管理</p><p>6：创建executor执行器</p><p>7：创建SqlSession</p><p>8：实现CRUD，如果CRUD出现问题，就回滚到5</p><p>9：提交事务</p><h2 id="Lombook"><a href="#Lombook" class="headerlink" title="Lombook"></a>Lombook</h2><p>lombook导入以后可以不用再写getter、setter和构造方法</p><p>导入maven依赖</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>注解</p><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><span class="hljs-meta">@Setter</span><span class="hljs-meta">@Data</span>----&gt;最常用：无参构造、set和get方法、toString()、hashcode()、equals()方法<span class="hljs-meta">@ToString</span><span class="hljs-meta">@AllArgsConstructor</span>----&gt;有参构造，只加这个，就没有无参构造方法了<span class="hljs-meta">@NoArgsConstructor</span>----&gt;无参构造</code></pre><h2 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h2><p>学生表和老师表的关系：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200616145135.png" srcset="/img/loading.gif" alt="image-20200616145132002"></p><p>sql语句</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.id, s.name, t.name <span class="hljs-keyword">FROM</span> student s,teacher t <span class="hljs-keyword">WHERE</span> s.tid=t.id</code></pre><p>查询结果：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200616145157.png" srcset="/img/loading.gif" alt="image-20200616145154515"></p><p>如何在mybatis实现这一行sql语句：<strong>子查询</strong></p><h3 id="按照查询嵌套处理"><a href="#按照查询嵌套处理" class="headerlink" title="按照查询嵌套处理"></a>按照查询嵌套处理</h3><pre><code class="hljs java"><span class="hljs-comment">//学生类和老师类</span><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Teacher teacher;&#125;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;&#125;<span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentMapper</span> </span>&#123;    List&lt;Student &gt; getStudent();&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TeacherMapper</span> </span>&#123;    <span class="hljs-function">Teacher <span class="hljs-title">getTeacher</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;&#125;</code></pre><p>mapper配置文件</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><span class="hljs-meta">        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.guo.dao.StudentMapper"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getStudent"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"StudentTeacher"</span>&gt;</span>    select * from student    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"StudentTeacher"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Student"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"name"</span>/&gt;</span><span class="hljs-comment">&lt;!--       复杂的属性需要单独处理，对象：association，集合：collection --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"teacher"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"tid"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"Teacher"</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"getTeacher"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getTeacher"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"Teacher"</span>&gt;</span>        select * from teacher where id= #&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><p>测试</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">test</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    SqlSession sqlSession = MyBatisUtils.getsqlSession();    StudentMapper mapper = sqlSession.getMapper(StudentMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    List&lt;Student&gt; student = mapper.getStudent();    <span class="hljs-keyword">for</span> (Student s : student) &#123;        System.out.println(s);    &#125;    sqlSession.close();&#125;</code></pre><p>结果：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200616143125.png" srcset="/img/loading.gif" alt="image-20200616143120940"></p><h3 id="按照结果嵌套处理"><a href="#按照结果嵌套处理" class="headerlink" title="按照结果嵌套处理"></a>按照结果嵌套处理</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getStudent2"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"StudentTeacher2"</span>&gt;</span>    select s.id sid,s.name sname,t.name tname    from student s, teacher t    where t.id=s.tid<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"StudentTeacher2"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Student"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sid"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sname"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"teacher"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"Teacher"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"tname"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></code></pre><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><p>一个老师对应多个学生，查询一个老师下的多个学生</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.name sname,s.id <span class="hljs-keyword">sid</span>, t.id tid, t.name tname <span class="hljs-keyword">FROM</span> student s, teacher t <span class="hljs-keyword">WHERE</span> s.tid=t.id <span class="hljs-keyword">and</span> t.id=<span class="hljs-comment">#&#123;tid&#125;</span></code></pre><p>查询老师时：学生为空</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200616144953.png" srcset="/img/loading.gif" alt="image-20200616144949282"></p><pre><code class="hljs java"><span class="hljs-comment">//mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TeacherMapper</span> </span>&#123;   <span class="hljs-function">Teacher <span class="hljs-title">getTeacher</span><span class="hljs-params">(@Param(<span class="hljs-string">"tid"</span>)</span> <span class="hljs-keyword">int</span> id)</span>;&#125;<span class="hljs-comment">//类</span><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> List&lt;Student&gt; students;&#125;</code></pre><h3 id="按照结果嵌套处理-1"><a href="#按照结果嵌套处理-1" class="headerlink" title="按照结果嵌套处理"></a>按照结果嵌套处理</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getTeacher"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"TeacherStudent"</span>&gt;</span>    SELECT s.name sname,s.id sid, t.id tid, t.name tname    FROM student s, teacher t    WHERE s.tid=t.id and t.id=#&#123;tid&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"TeacherStudent"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Teacher"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"tid"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"tname"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"students"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"Student"</span>&gt;</span><span class="hljs-comment">&lt;!--集合中的泛型类型用ofType获取--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sid"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sname"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"tid"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"tid"</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></code></pre><p>结果</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200616150507.png" srcset="/img/loading.gif" alt="image-20200616150504219"></p><h3 id="按照查询嵌套处理-1"><a href="#按照查询嵌套处理-1" class="headerlink" title="按照查询嵌套处理"></a>按照查询嵌套处理</h3><p>类比于sql中的子查询</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><span class="hljs-meta">        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.guo.dao.TeacherMapper"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getTeacher2"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"TeacherStudent2"</span>&gt;</span>    select * from mybatis.teacher where id=#&#123;tid&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"TeacherStudent2"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Teacher"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"students"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"ArrayList"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"Student"</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"getStudentByTeacherId"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getStudentByTeacherId"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"Student"</span>&gt;</span>        select * from mybatis.student where tid=#&#123;tid&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p><p>choose、when、otherwise、if、trim、where、set、foreach、script和bind</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存是放在内存中的临时数据，将用户<strong>经常查询的数据放在缓存中</strong>，用户去查询数据就不用从磁盘上查询，直接从缓存中查询，解决了高并发系统的性能问题</p><p>好处：减少和数据库的交互次数</p><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>也叫本地缓存：SqlSession</p><p>与数据库同一次会话期间查询到的数据会放到本地缓存中，以后如果需要，直接去缓存中拿。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>二级缓存也叫全局缓存，一级缓存作用域是会话，如果会话关闭了对应缓存就小时了，二级缓存可以让关闭会话后的一级缓存中的数据保存到二级缓存中</p><h2 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h2><p>ExceptionInInitializerError：需要在maven中导入代码，导入后需要刷新maven</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 定义classpath --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>            <span class="hljs-comment">&lt;!-- resources文件 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>                <span class="hljs-comment">&lt;!-- 是否被过滤,如果被过滤则无法使用 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>            <span class="hljs-comment">&lt;!-- java文件夹 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>                <span class="hljs-comment">&lt;!-- 引入映射文件等 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>#{}和${}的区别。#{}可以预防sql注入</p><h3 id="IntelliJ-idea中刷新pom就恢复language-level恢复默认为5"><a href="#IntelliJ-idea中刷新pom就恢复language-level恢复默认为5" class="headerlink" title="IntelliJ idea中刷新pom就恢复language level恢复默认为5"></a>IntelliJ idea中刷新pom就恢复language level恢复默认为5</h3><p>在pom.xml中加入：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></code></pre><p>用到的SQL语句</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> <span class="hljs-string">`mybatis`</span>;<span class="hljs-keyword">USE</span> <span class="hljs-string">`mybatis`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span>(<span class="hljs-string">`id`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> PRIMARY <span class="hljs-keyword">KEY</span>,<span class="hljs-string">`name`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">`pwd`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`user`</span>(<span class="hljs-string">`id`</span>,<span class="hljs-string">`name`</span>,<span class="hljs-string">`pwd`</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">'z1'</span>,<span class="hljs-string">'123'</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">'q2'</span>,<span class="hljs-string">'456'</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">'z3'</span>,<span class="hljs-string">'123'</span>);<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">USER</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`teacher`</span>(<span class="hljs-string">`id`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">`name`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>))<span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`teacher`</span>(<span class="hljs-string">`id`</span>,<span class="hljs-string">`name`</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">'秦老师'</span>)<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`teacher`</span>(<span class="hljs-string">`id`</span>,<span class="hljs-string">`name`</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>,<span class="hljs-string">'李老师'</span>)<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`student`</span>(<span class="hljs-string">`id`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">`name`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">`tid`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),<span class="hljs-keyword">KEY</span> <span class="hljs-string">`fktid`</span> (<span class="hljs-string">`tid`</span>),<span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-string">`fktid`</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`tid`</span>) <span class="hljs-keyword">REFERENCES</span> <span class="hljs-string">`teacher`</span> (<span class="hljs-string">`id`</span>))<span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> (<span class="hljs-string">`id`</span>,<span class="hljs-string">`name`</span>,<span class="hljs-string">`tid`</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'1'</span>,<span class="hljs-string">'x2'</span>,<span class="hljs-string">'1'</span>)<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span>(<span class="hljs-string">`id`</span>,<span class="hljs-string">`name`</span>,<span class="hljs-string">`tid`</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'2'</span>,<span class="hljs-string">'xh'</span>,<span class="hljs-string">'1'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span>(<span class="hljs-string">`id`</span>,<span class="hljs-string">`name`</span>,<span class="hljs-string">`tid`</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'3'</span>,<span class="hljs-string">'xz'</span>,<span class="hljs-string">'1'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span>(<span class="hljs-string">`id`</span>,<span class="hljs-string">`name`</span>,<span class="hljs-string">`tid`</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'4'</span>,<span class="hljs-string">'xs'</span>,<span class="hljs-string">'1'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span>(<span class="hljs-string">`id`</span>,<span class="hljs-string">`name`</span>,<span class="hljs-string">`tid`</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'5'</span>,<span class="hljs-string">'xr'</span>,<span class="hljs-string">'1'</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>SSM</category>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式</title>
    <link href="/2020/06/15/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/15/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式，<strong>行为型模式</strong>关注的是<strong>对象之间的通讯</strong>，观察者模式就是<strong>观察者和被观察者</strong>之间的通讯</p><p>举个例子：老师在办公室改作业，学生晚自习在教室玩手机、说话、打闹等，在这个过程中，学生要不断观察老师来没来，学生就是观察者，老师就是被观察者。如果老师改完作业来自习室，状态发生了变更，就需要通知每一个学生，让他们停止玩耍，好好学习。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>一个观察者模式包含有两大类：主题和观察者</p><p>主题：主题是观察者观测的对象。主题又可以分成抽象主题和具体主题</p><blockquote><p>抽象主题：把所有对观察者对象的引用保存在一个集合里面，抽象主题提供一个借口，可以增加和删除观察对象。</p><p>​    比如上面例子，学生一直不学习玩耍，老师就可以让学生出去，别影响其他人</p><p>具体主题：该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知</p><p>​    比如：老师来到教室门口，就需要通知学生学习</p></blockquote><blockquote><p>特征：</p><p>持有监听的观察者的引用</p><p>支持增加和删除观察者</p><p>主题状态改变，通知观察者</p></blockquote><p>观察者：不断监听主题，当主题发生变化时，进行相应处理操作。观察者又可以分成抽象观察者和具体观察者</p><blockquote><p>抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。这就是我们所有学生的抽象。</p><p>具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。每一个具体的学生</p></blockquote><p>以学生和老师为例</p><pre><code class="hljs java"><span class="hljs-comment">//抽象主题</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Teacher</span> </span>&#123;    <span class="hljs-comment">//让学生出去</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(Student student)</span></span>;    <span class="hljs-comment">//让学生进来</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteStudent</span><span class="hljs-params">(Student student)</span></span>;    <span class="hljs-comment">//通知学生老师来了</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyStudent</span><span class="hljs-params">(String msg)</span></span>;&#125;<span class="hljs-comment">//具体主题</span><span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteTeacher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Teacher</span></span>&#123;    <span class="hljs-keyword">private</span> List&lt;Student&gt; list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(Student student)</span> </span>&#123;        list.add(student);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteStudent</span><span class="hljs-params">(Student student)</span> </span>&#123;        list.remove(student);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyStudent</span><span class="hljs-params">(String msg)</span> </span>&#123;        <span class="hljs-keyword">for</span> (Student s:list)            s.update(msg);    &#125;&#125;<span class="hljs-comment">//抽象观察者---学生</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(String msg)</span></span>;&#125;<span class="hljs-comment">//具体观察者---学生</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStudent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Student</span></span>&#123;    String stuName;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteStudent</span><span class="hljs-params">(String stuName)</span> </span>&#123;        <span class="hljs-keyword">this</span>.stuName = stuName;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(String msg)</span> </span>&#123;        System.out.println(stuName+<span class="hljs-string">"知道"</span>+msg+<span class="hljs-string">"老师来了"</span>);    &#125;&#125;<span class="hljs-comment">//测试</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Student s1=<span class="hljs-keyword">new</span> ConcreteStudent(<span class="hljs-string">"z3"</span>);<span class="hljs-comment">//生成学生</span>        Student s2=<span class="hljs-keyword">new</span> ConcreteStudent(<span class="hljs-string">"l4"</span>);        Student s3=<span class="hljs-keyword">new</span> ConcreteStudent(<span class="hljs-string">"w5"</span>);        Teacher t=<span class="hljs-keyword">new</span> ConcreteTeacher();        t.addStudent(s1);<span class="hljs-comment">//添加学生到老师管理的列表中</span>        t.addStudent(s2);        t.addStudent(s3);        t.notifyStudent(<span class="hljs-string">"老师"</span>);<span class="hljs-comment">//老师状态变更，需要通知学生老师来了</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>行为型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/2020/06/15/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/15/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略末班把算法实现和算法使用分离开，让它们之间可以相互替换。策略模式让算法的变换，不会影响到用户。举个例子：某商场促销，有的物品打五折，有的打七折。打几折是算法的实现，不同的物品使用不同的算法，对于收银员来说，他不需要在意具体打几折，只需要输入物品号，程序就可以给出促销后的价格。</p><p>代码如下</p><pre><code class="hljs java"><span class="hljs-comment">//策略的抽象接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Strategy</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//具体策略----A</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Strategy</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"策略A"</span>);    &#125;&#125;<span class="hljs-comment">//具体策略----B</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Strategy</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"策略B"</span>);    &#125;&#125;<span class="hljs-comment">//使用一个context来维护上下文</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;    Strategy strategy;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span><span class="hljs-params">(Strategy strategy)</span> </span>&#123;<span class="hljs-comment">//根据传入的策略来决定调用的策略</span>        <span class="hljs-keyword">this</span>.strategy = strategy;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        strategy.algorithm();    &#125;&#125;<span class="hljs-comment">//测试</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Context contextA=<span class="hljs-keyword">new</span> Context(<span class="hljs-keyword">new</span> ConcreteStrategyA());<span class="hljs-comment">//传入策略A，可以传入不同的策略</span>    contextA.function();    Context contextB=<span class="hljs-keyword">new</span> Context(<span class="hljs-keyword">new</span> ConcreteStrategyB());<span class="hljs-comment">//传入策略B</span>    contextB.function();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>行为型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式</title>
    <link href="/2020/06/15/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/15/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p><strong>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法在一起工作的两个类能够在一起工作</strong></p><p>模式要素：目标接口、适配器、原接口</p><p>举个例子：电脑只有一个USB接口，需要使用适配器把网线转换成USB接口，这样才可以让电脑上网。如下图</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200615100125.png" srcset="/img/loading.gif" alt="image-20200615100116263"></p> <pre><code class="hljs java"><span class="hljs-comment">//目标是把网线接口转成USB接口</span><span class="hljs-comment">//原接口就是网线：</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetLine</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">"连接网线上网"</span>);    &#125;&#125;<span class="hljs-comment">//接口转换器的抽象实现</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">NetToUsb</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//转换器的实现类适配器，一个连接网线，一个连接电脑</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NetLine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">NetToUsb</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.function();    &#125;&#125;<span class="hljs-comment">//上网</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">net</span><span class="hljs-params">(NetToUsb adapter)</span></span><span class="hljs-function">    </span>&#123;        adapter.handle();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Computer computer=<span class="hljs-keyword">new</span> Computer();        Adapter adapter=<span class="hljs-keyword">new</span> Adapter();        computer.net(adapter);    &#125;&#125;</code></pre><p>优化：少继承，多组合</p><pre><code class="hljs java"><span class="hljs-comment">//使用组合</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdapterImpl</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">Adapter</span></span>&#123;    NetLine netLine;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AdapterImpl</span><span class="hljs-params">(NetLine netLine)</span> </span>&#123;        <span class="hljs-keyword">this</span>.netLine = netLine;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;        netLine.function();    &#125;&#125;<span class="hljs-comment">//测试</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Computer computer=<span class="hljs-keyword">new</span> Computer();    NetLine netLine=<span class="hljs-keyword">new</span> NetLine();<span class="hljs-comment">//网线</span>    AdapterImpl adapter=<span class="hljs-keyword">new</span> AdapterImpl(netLine);<span class="hljs-comment">//传入网线</span>    computer.net(adapter);&#125;</code></pre><p>代码来自@狂神</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>结构型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora图床</title>
    <link href="/2020/06/14/Typora%E5%9B%BE%E5%BA%8A/"/>
    <url>/2020/06/14/Typora%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="使用PicGO-Gitee搭建Typora图床"><a href="#使用PicGO-Gitee搭建Typora图床" class="headerlink" title="使用PicGO+Gitee搭建Typora图床"></a>使用PicGO+Gitee搭建Typora图床</h1><h2 id="码云"><a href="#码云" class="headerlink" title="码云"></a>码云</h2><p>首先在码云里面新建一个仓库，用来存储图片。步骤如下：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200526161531.png" srcset="/img/loading.gif" alt="image-20200526161529013"></p><p>获取你的token，后面要用：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200526162407.png" srcset="/img/loading.gif" alt="image-20200526162403325"></p><p>点击生成新令牌</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200526162438.png" srcset="/img/loading.gif" alt="image-20200526162436032"></p><p>进入私人令牌页面，选择projects这个选项，最后点击提交。私人令牌描述那里随便写，如图床、博客图片等都可以。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200526162554.png" srcset="/img/loading.gif" alt="image-20200526162550942"></p><h2 id="Typora配置"><a href="#Typora配置" class="headerlink" title="Typora配置"></a>Typora配置</h2><p>打开typora的偏好设置，配置PicGo：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200526163202.png" srcset="/img/loading.gif" alt=""></p><p>2执行完后去执行3。找到安装路径。下图标出的就是安装路径</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200526163010.png" srcset="/img/loading.gif" alt="image-20200526163008740"></p><p>打开cmd进入安装路径，并执行安装插件</p><blockquote><p>cd C:\Users\jaymie\AppData\Roaming\Typora\picgo\win64<br>.\picgo.exe install smms-user<br>.\picgo.exe install gitee-uploader<br>.\picgo.exe install github-plus</p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200526163114.png" srcset="/img/loading.gif" alt="image-20200526163111906"></p><p>再去执行4</p><p>配置文件设置如下：</p><pre><code class="hljs xml">&#123;  "picBed": &#123;    "uploader": "gitee", //    "gitee": &#123;      "repo": "", // 用户名/仓库名      "token": "",// 写你的token      "path": ", // 路径如：img/"      "customUrl": "", //      "branch": "" //    &#125;  &#125;,  "picgoPlugins": &#123;    "picgo-plugin-gitee-uploader": true,    "picgo-plugin-super-prefix": true,    "picgo-plugin-github-plus": true  &#125;,  "picgo-plugin-super-prefix": &#123;    "fileFormat": "YYYYMMDDHHmmss"  &#125;,  "picgo-plugin-gitee-uploader": &#123;    "lastSync": "2020-05-26 04:19:31"  &#125;&#125;</code></pre><p>保存设置，然后再执行3，当出现下图的成功上传图片并获得新的URL时，设置成功</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200526163407.png" srcset="/img/loading.gif" alt="image-20200526163404906"></p><p>以后复制图片到Typora会出现下面的<strong>上传图片</strong>，就可以上传图片到你的码云仓库中去了。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614170057763.png" srcset="/img/loading.gif" alt="image-20200614170057763"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode438-找到字符串中所有字母异位词</title>
    <link href="/2020/06/14/LeetCode438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <url>/2020/06/14/LeetCode438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode438-找到字符串中所有字母异位词"><a href="#LeetCode438-找到字符串中所有字母异位词" class="headerlink" title="LeetCode438-找到字符串中所有字母异位词"></a>LeetCode438-找到字符串中所有字母异位词</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入:</span><span class="hljs-meta">&gt;</span><span class="bash">s: <span class="hljs-string">"abab"</span> p: <span class="hljs-string">"ab"</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出:</span><span class="hljs-meta">&gt;</span><span class="bash">[0, 1, 2]</span></code></pre><p><strong>说明：</strong></p><ul><li>字母异位词指字母相同，但排列不同的字符串。</li><li>不考虑答案输出的顺序</li></ul></blockquote><p>注意：相同字母也是异位词，如”ab”也是”ab”的异位词</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>维护一个字符串P长度的滑动窗口，不断移动判断即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(String s, String p)</span> </span>&#123;        <span class="hljs-keyword">int</span> sLen=s.length(),pLen=p.length();        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;        HashMap&lt;Character,Integer&gt; target=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">//目标元素</span>        HashMap&lt;Character,Integer&gt; window=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">//滑动窗口</span>        List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">char</span> f=p.charAt(<span class="hljs-number">0</span>);        <span class="hljs-keyword">int</span> valid=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(Character c:p.toCharArray()) target.put(c,target.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<span class="hljs-comment">//把p中字符都放入到target中</span>        <span class="hljs-keyword">while</span>(right&lt;sLen)        &#123;            <span class="hljs-keyword">char</span> c=s.charAt(right);            right++;            <span class="hljs-keyword">if</span>(target.containsKey(c))<span class="hljs-comment">//判断这个字符在p中是否出现过</span>            &#123;                window.put(c,window.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<span class="hljs-comment">//如果出现过，就放到滑动窗口中</span>                <span class="hljs-keyword">if</span>(target.get(c).equals(window.get(c))) valid++;<span class="hljs-comment">//如果每一个字符在滑动窗口中出现的次数和target中出现的次数相等，就让valid++，这说明了窗口中放入了valid个有效字符</span>            &#125;            <span class="hljs-keyword">if</span>(right-left==pLen)<span class="hljs-comment">//如果窗口大小等于P的长度，那么判断一下，这个窗口中的字符是不是P的异位词</span>            &#123;                <span class="hljs-keyword">char</span> d=s.charAt(left);                <span class="hljs-keyword">if</span>(valid==target.size()) <span class="hljs-comment">//如果valid==target.size()，说明了P中所有字母都放入到window中</span>                &#123;                    list.add(left);                &#125;                <span class="hljs-comment">//无论该窗口中元素是不是P的异位词，下面都需要开始向右移动滑动窗口</span>                <span class="hljs-keyword">if</span>(target.containsKey(d))<span class="hljs-comment">//如果字符d包含在target中</span>                &#123;                    <span class="hljs-keyword">if</span>(target.get(d).equals(window.get(d))) valid--;<span class="hljs-comment">//如果这个字符在target中出现过的次数和window中出现的次数相等，那么向右移动后，window中就少了一个符合要求的字符，valid需要减一</span>                    window.put(d,window.get(d)-<span class="hljs-number">1</span>);<span class="hljs-comment">//窗口向右移动，所以需要把该字符从窗口中移出</span>                &#125;                left++;<span class="hljs-comment">//向右移动</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> list;<span class="hljs-comment">//返回结果集</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>滑动窗口</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode3-无重复字符的最长子串</title>
    <link href="/2020/06/14/LeetCode3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/06/14/LeetCode3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode3-无重复字符的最长子串"><a href="#LeetCode3-无重复字符的最长子串" class="headerlink" title="LeetCode3-无重复字符的最长子串"></a>LeetCode3-无重复字符的最长子串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: <span class="hljs-string">"abcabcbb"</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出: 3 </span><span class="hljs-meta">&gt;</span><span class="bash">解释: 因为无重复字符的最长子串是 <span class="hljs-string">"abc"</span>，所以其长度为 3。</span></code></pre></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>典型的滑动窗口，维护一个滑动窗口[left,right)，同时用一个HashMap记录字符串中字符出现的次数，如果发现有重复字符出现，就移动窗口，直到窗口中没有重复字符为止</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> len=s.length();              <span class="hljs-comment">//if(len==0) return 0;</span>        HashMap&lt;Character,Integer&gt; window=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">//滑动窗口</span>        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> start=<span class="hljs-number">0</span>,end=<span class="hljs-number">0</span>,maxLen=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(right&lt;len)        &#123;            <span class="hljs-keyword">char</span> c=s.charAt(right);            right++;            window.put(c,window.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);            <span class="hljs-keyword">while</span>(window.get(c)&gt;<span class="hljs-number">1</span>)<span class="hljs-comment">//如果窗口中出现了重复元素，就让窗口向右移动</span>            &#123;                <span class="hljs-keyword">char</span> p=s.charAt(left);                left++;                window.put(p,window.get(p)-<span class="hljs-number">1</span>);<span class="hljs-comment">//每移动一次滑动窗口，就移出一个字符</span>            &#125;            <span class="hljs-keyword">if</span>(right-left&gt;maxLen)<span class="hljs-comment">//记录窗口的最大长度</span>                maxLen=right-left;                    &#125;        <span class="hljs-keyword">return</span> maxLen;<span class="hljs-comment">//返回窗口长度值</span>            &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>滑动窗口</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode567-字符串的排列</title>
    <link href="/2020/06/14/LeetCode567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2020/06/14/LeetCode567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode567-字符串的排列"><a href="#LeetCode567-字符串的排列" class="headerlink" title="LeetCode567-字符串的排列"></a>LeetCode567-字符串的排列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定两个字符串 <strong>s1</strong> 和 <strong>s2</strong>，写一个函数来判断 <strong>s2</strong> 是否包含 <strong>s1</strong> 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><pre><code class="hljs armasm">&gt;输入: <span class="hljs-built_in">s1</span> = <span class="hljs-string">"ab"</span> <span class="hljs-built_in">s2</span> = <span class="hljs-string">"eidbaooo"</span>&gt;输出: True&gt;解释: <span class="hljs-built_in">s2</span> 包含 <span class="hljs-built_in">s1</span> 的排列之一 (<span class="hljs-string">"ba"</span>).&gt;输入: <span class="hljs-built_in">s1</span>= <span class="hljs-string">"ab"</span> <span class="hljs-built_in">s2</span> = <span class="hljs-string">"eidboaoo"</span>&gt;输出: False</code></pre></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>维护一个长度为字符串s1长度的滑动窗口，用滑动窗口不断扫描字符串s2，如果窗口内的元素都是s1的元素，说明s2包含字符串s1的一种排列</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;        <span class="hljs-keyword">int</span> sLen1=s1.length(),sLen2=s2.length();        HashMap&lt;Character,Integer&gt; target=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();        HashMap&lt;Character,Integer&gt; window=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span>(Character c:s1.toCharArray()) target.put(c,target.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> valid=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(right&lt;sLen2)<span class="hljs-comment">//这里改成for还是会报错，为啥？？</span>        &#123;            <span class="hljs-keyword">char</span> c=s2.charAt(right);            right++;            <span class="hljs-keyword">if</span>(target.containsKey(c))            &#123;                window.put(c,window.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);                <span class="hljs-keyword">if</span>(target.get(c).equals(window.get(c))) valid++;            &#125;            <span class="hljs-keyword">if</span>(right-left==sLen1)<span class="hljs-comment">//维护长度为字符串s1长度的一个滑动窗口</span>            &#123;                <span class="hljs-keyword">char</span> d=s2.charAt(left);                left++;                <span class="hljs-keyword">if</span>(valid==target.size()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//如果这个窗口内的元素恰好都是s1的元素，说明在字符串s2上找到了s1的一种排列</span>                <span class="hljs-keyword">if</span>(target.containsKey(d))                &#123;                    <span class="hljs-keyword">if</span>(target.get(d).equals(window.get(d))) valid--;                    window.put(d,window.get(d)-<span class="hljs-number">1</span>);                &#125;                                    &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><blockquote><p>while(right&lt;sLen2)改成for循环会报错，为啥呢？</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>滑动窗口</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2020/06/13/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/13/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。代理模式一般由四个角色构成：抽象角色、真实角色、代理角色、客户，而且代理分为静态代理和动态代理</p><p>静态代理代理的是<strong>一个业务</strong>，动态代理可以代理<strong>一类业务</strong></p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>假如有一个需求是，给每一个方法都实现一个打印日志功能，你怎么做？</p><p>最暴力：直接修改每一个方法，缺点方法太大，改不过来，容易出错，违法开闭原则</p><p>简单点：为每一个类写一个代理类，让代理类和目标类都实现相同的接口，在创建代理对象时，通过构造器塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法，并在调用前后打印日志。这样以后，就不需要调用目标类生成对象，直接生成代理对象便完成了添加打印日志的功能。</p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//接口实现类---学生</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"name is Student"</span>);    &#125;&#125;<span class="hljs-comment">//接口实现类---老师</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"name is Teacher"</span>);    &#125;&#125;<span class="hljs-comment">//学生代理类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentPerson</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">private</span> Student student;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StudentPerson</span><span class="hljs-params">(Student student)</span> </span>&#123;        <span class="hljs-keyword">this</span>.student = student;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"学生类的代理类打印日志功能"</span>);        student.name();    &#125;&#125;<span class="hljs-comment">//老师代理类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeacherProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">private</span> Teacher teacher;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TeacherProxy</span><span class="hljs-params">(Teacher teacher)</span> </span>&#123;        <span class="hljs-keyword">this</span>.teacher = teacher;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"老师类的代理类实现日志功能"</span>);        teacher.name();    &#125;&#125;</code></pre><p>好处：公共业务交给代理角色，真实角色只需要做自己独有业务即可</p><p>缺点：程序员要<strong>手动</strong>为每一个目标类编写对应的代理类，代码量翻倍。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>静态代理需要程序员自己写代理类，使用new关键字创建对应的代理对象，根据代理对象调用代理方法</p><p>创建对象过程：加载、连接、初始化。（下面回顾一下创建过程，可以跳过）</p><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p><strong>类加载全过程：加载、验证、准备、解析和初始化</strong></p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载阶段，JVM需要做三件事情</p><blockquote><p>通过类的全限定名获取定义此类的二进制字节流</p><p>将这个字节流代表的静态存储结构转化为方法区的运行时数据结构</p><p>内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p></blockquote><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>连接阶段又可以分成：验证、准备和解析三个阶段</p><blockquote><p>验证：确保Class文件额字节流中包含的信息符合约束要求，保证这些信息被当做代码运行后<strong>不会危害JVM的安全</strong></p><p>​    验证又可以分成：文件格式验证、元数据验证、字节码验证和符号引用验证</p><p>准备：准备阶段是为类<strong>中定义的变量分配内存</strong>并设置<strong>类变量初始值</strong>的阶段，<strong>理论上</strong>这些变量使用的内存都应该在<strong>方法区</strong>中进行分配，但是方法区只是一个逻辑概念，JDK7之前，HotSpot使用永久代来实现方法区，JDK8之后，类变量则随着Class对象一起放到Java堆中。</p><p>​    注意：这里为类变量分配初始值，是分配的各个类型的默认值，如0、null等，不是程序员写到程序中的初始值</p><p>解析：将JVM常量池中的符号引用替换为直接引用。</p><p>​        符号引用：符号引用以一组符号来描述引用的目标，可以是任何形式的字面量，只要可以无歧义的定位到目标即可</p><p>​        直接引用：直接引用是可以执行目标的指针、相对偏移量或者是一个能间接定位到目标的句柄</p></blockquote><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的初始化是类加载过程的最后一步。准备阶段，变量已经赋过一次系统要求的初始零值，初始化阶段，则会根据程序员在代码中编写的代码进行相应的初始化</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>对于任意一个类，必须由加载它的类加载器和这个类本身一起确定它在JVM中的唯一性，每一个类加载器，都有一个独立的类名称空间。</p><p>有两种类加载器，一种是启动类加载器（C++实现），一种是其他类加载器（Java实现）。后者全都继承抽象类java,lang.ClassLoader。关系如下图</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200615085250.png" srcset="/img/loading.gif" alt="image-20200615085244972"></p><p>类加载器之间的层次关系被称为双亲委派模型</p><blockquote><p>双亲委派模型：一个类加载器收到类加载请求时，不会自己去尝试加载这个类，而是把这个请求委派给父加载器去完成，每一个层次都是如此，最终会传到启动类加载器，如果负加载器无法完成这个加载请求，自家在其才会尝试自己去加载。</p><p>优点：保证类的全局唯一性，维护了Java程序的稳定运行</p></blockquote><h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3><p>动态代理的目标是不写代理类，而是直接得到代理Class对象，然后根据它来创建代理实例。Class对象包含了一个类的所有信息，比如构造器、方法和成员变量等。而为了获得这些信息，<strong>因为接口拥有目标对象的类信息</strong>，我们需要<strong>让代理类和目标类实现同一组接口，确保代理对象的内部结构和目标对象一致</strong>。</p><p>JDK提供了java.lang.reflect.<strong>InvocationHandler</strong>接口和 java.lang.reflect.<strong>Proxy</strong>类。</p><p>Proxy有个静态方法：<strong>getProxyClass</strong>(ClassLoader, interfaces)，只要你给它传入<strong>类加载器和一组接口，它就给你返回代理Class对象</strong>。getProxyClass()这个方法，会从你传入的接口Class中，“拷贝”类结构信息到一个新的Class对象中，新的Class对象带有构造器，是可以创建对象的。一旦我们明确接口，完全可以<strong>通过接口的Class对象，创建一个代理Class，通过代理Class即可创建代理对象</strong>。</p><p>但一般不用<strong>getProxyClass</strong>方法，而是用Proxy类的另一个静态方法：<strong>Proxy.newProxyInstance()</strong>，直接返回代理实例。</p><p>根据代理Class的构造器创建对象时，需要传入InvocationHandler。每次调用代理对象的方法，最终都会调用InvocationHandler的invoke()方法：</p><p>动态代理分成基于接口的动态代理（JDK）和基于类的动态代理（CGLib）</p><pre><code class="hljs java"><span class="hljs-comment">//基于接口的动态代理</span><span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Rent</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">home</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//实现类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Host</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Rent</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">home</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"出租房子"</span>);    &#125;&#125;<span class="hljs-comment">//这个类用来生成代理对象</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<span class="hljs-comment">//实现InvocationHandler接口，创建自己的调用处理器</span>    <span class="hljs-keyword">public</span> Object object;<span class="hljs-comment">//传入接口类型</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> object;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setObject</span><span class="hljs-params">(Object object)</span> </span>&#123;        <span class="hljs-keyword">this</span>.object = object;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//创建代理类对象</span>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<span class="hljs-keyword">this</span>.getClass().getClassLoader(),object.getClass().getInterfaces(),<span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        <span class="hljs-comment">//调用方法前做一些处理工作</span>        Object invoke = method.invoke(object, args);        <span class="hljs-comment">//调用方法后做一些处理工作</span>        <span class="hljs-keyword">return</span> invoke;    &#125;&#125;<span class="hljs-comment">//测试</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Host host=<span class="hljs-keyword">new</span> Host();        ProxyClass proxyClass=<span class="hljs-keyword">new</span> ProxyClass();<span class="hljs-comment">//生成代理类</span>        proxyClass.setObject(host);<span class="hljs-comment">//传入要代理的接口</span>        Rent proxy = (Rent) proxyClass.getProxy();<span class="hljs-comment">//</span>        proxy.home();    &#125;&#125;</code></pre><h3 id="基于类的动态代理（待续）"><a href="#基于类的动态代理（待续）" class="headerlink" title="基于类的动态代理（待续）"></a>基于类的动态代理（待续）</h3><p>JDK动态代理的话，他有一个限制，就是它只能为接口创建代理实例，对于没有通过接口定义业务方法的类，需要通过CGLib来创建代理实例</p><h4 id="Enhancer"><a href="#Enhancer" class="headerlink" title="Enhancer"></a>Enhancer</h4><p>Enhancer可能是CGLIB中最常用的一个类，类似于JDK的proxy</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>结构型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建造者模式</title>
    <link href="/2020/06/13/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/13/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式是对象的创建模式，它分离了产品的<strong>内部表现</strong>和产品的<strong>生产过程</strong>，使得一个建造过程可以生产具有不同的内部变现的产品对象。使用建造者模式可以使得用户不需要知道产品的每一个零件的生产过程，零件的生产顺序，以及零件的组装。</p><h2 id="产品的内部表现"><a href="#产品的内部表现" class="headerlink" title="产品的内部表现"></a>产品的内部表现</h2><p>一个产品Product，可能有不同的零件，这些零件叫做产品的内部表现。比如要做饭，要先买菜、洗菜、炒菜等</p><h2 id="零件的生产顺序"><a href="#零件的生产顺序" class="headerlink" title="零件的生产顺序"></a>零件的生产顺序</h2><p>产品之间零件的生产顺序也很重要，类似于做饭的顺序，不可能先炒菜，再买菜。必须按照一定的顺序生产零件，才可以得到有意义的产品。建造者模式就是按照正确顺序实现了零件的生产，返回给用户一个合格的对象</p><p>建造者模式结构组成：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200613103809.png" srcset="/img/loading.gif" alt="image-20200613103805729"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs java"><span class="hljs-comment">//抽象建造者</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Build</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildA</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildB</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildC</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildD</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> Product <span class="hljs-title">getProduct</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//产品</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;    <span class="hljs-comment">//一个产品由A,B,C,D四部分组成</span>    <span class="hljs-keyword">private</span> String productA;    <span class="hljs-keyword">private</span> String productB;    <span class="hljs-keyword">private</span> String productC;    <span class="hljs-keyword">private</span> String productD;    &#125;&#125;<span class="hljs-comment">//创建产品的类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Build</span></span>&#123;    <span class="hljs-keyword">private</span> Product product;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">( )</span> </span>&#123;        product=<span class="hljs-keyword">new</span> Product();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildA</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"AAA"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildB</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"BBB"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildC</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"CCC"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildD</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"DDD"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">Product <span class="hljs-title">getProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> product;    &#125;&#125;<span class="hljs-comment">//指挥者决定建造顺序</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">build</span><span class="hljs-params">(Build build)</span></span>&#123;            build.buildA();            build.buildB();            build.buildC();            build.buildD();            <span class="hljs-keyword">return</span> build.getProduct();    &#125;&#125;<span class="hljs-comment">//主线程测试</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//构建指挥</span>        Director director=<span class="hljs-keyword">new</span> Director();        <span class="hljs-comment">//通过指挥者来建造产品</span>        Product build = director.build(<span class="hljs-keyword">new</span> Worker());        <span class="hljs-comment">//打印产品</span>        build.toString();    &#125;&#125;</code></pre><p>导演类Director在Builder模式中具有重要的意义，复制指导建造者以何种顺序来构建产品，并且返回最终产品。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创建型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式</title>
    <link href="/2020/06/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型模式：顾名思义以某个对象为原型，复制一个新的对象。创建复制对象的时候，可以提高效率</p><p>原型模式主要用于对象的复制，其中原型类也就是被复制的类需要具备两个条件：1实现Cloneable接口，2重写Object的clone方法。</p><p>代码如下</p><pre><code class="hljs java"><span class="hljs-comment">//原型类型</span><span class="hljs-keyword">package</span> day01.test;<span class="hljs-keyword">import</span> javax.sql.DataSource;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;    <span class="hljs-keyword">public</span> Date date;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(Date date, String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.date = date;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Person&#123;"</span> +                <span class="hljs-string">"date="</span> + date +                <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +                <span class="hljs-string">'&#125;'</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getDate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> date;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDate</span><span class="hljs-params">(Date date)</span> </span>&#123;        <span class="hljs-keyword">this</span>.date = date;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;<span class="hljs-comment">//主线程</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;    Date date=<span class="hljs-keyword">new</span> Date();    Person p1=<span class="hljs-keyword">new</span> Person(date,<span class="hljs-string">"zs"</span>);    Person clone = (Person) p1.clone();    System.out.println(p1.toString());    System.out.println(clone.toString());    System.out.println(<span class="hljs-string">"================"</span>);    date.setTime(<span class="hljs-number">123</span>);<span class="hljs-comment">//修改date</span>    System.out.println(p1.toString());    System.out.println(clone.toString());&#125;</code></pre><p>上面的代码以原型p1为模板，克隆了一个原型对象，但是这种克隆只是浅克隆，如果我们修改原型对象的引用类型数据，那么克隆对象中的引用类型也会随之改动</p><h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><p>浅克隆是只克隆按值传递的数据，比如基本数据类型、String类型，而不会克隆它所引用的对象，对修改原对象中的引用类型数据，克隆对象中的数据也会随之修改，如下图所示：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200613100516.png" srcset="/img/loading.gif" alt="image-20200613100510733"></p><h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><p>深克隆是除了克隆基本数据类型和String类型的值外，还会克隆引用类型的数据，重新在堆中开辟一段空间，用来放置引用对象，并且用新的引用指向该对象</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200613100751.png" srcset="/img/loading.gif" alt="image-20200613100747462"></p><p>深克隆代码如下</p><pre><code class="hljs java"><span class="hljs-comment">//只需要修改clone方法的代码即可</span><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;        Person person = (Person)<span class="hljs-keyword">super</span>.clone();<span class="hljs-comment">//得到克隆对象，将其转成person类型</span>        Date clone =(Date) <span class="hljs-keyword">this</span>.date.clone();<span class="hljs-comment">//得到原型对象中的引用对象</span>        person.date=clone;<span class="hljs-comment">//修改原型对象中的引用对象</span>        <span class="hljs-keyword">return</span> person;<span class="hljs-comment">//返回克隆对象</span>    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创建型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode76-最小覆盖子串</title>
    <link href="/2020/06/12/LeetCode76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/06/12/LeetCode76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode76-最小覆盖子串"><a href="#LeetCode76-最小覆盖子串" class="headerlink" title="LeetCode76 最小覆盖子串"></a>LeetCode76 最小覆盖子串</h1><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p><p>这是一道典型的滑动窗口，大致思路是使用两个指针left和right，先滑动right，使得[left,right)区间内的元素包含T中所有元素，此时再滑动left，缩小区间，当缩小到区间[left,right)缺少T中的一个字符时，滑动right，以此类推，直到right到达终点字符串S的末尾。记录中间的区间最小值的开头和结尾，最后返回即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<span class="hljs-comment">//左右指针</span>        <span class="hljs-keyword">int</span> start=<span class="hljs-number">0</span>,end=<span class="hljs-number">0</span>;<span class="hljs-comment">//区间开始位置和结尾位置</span>        <span class="hljs-keyword">int</span> sLen=s.length(),tLen=t.length();<span class="hljs-comment">//字符串长度</span>        <span class="hljs-keyword">int</span> minLen=Integer.MAX_VALUE;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;        HashMap&lt;Character,Integer&gt; target=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">//记录目标字符串中字符的出现次数</span>        HashMap&lt;Character,Integer&gt; window=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">//滑动窗口</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c:t.toCharArray())        &#123;            <span class="hljs-keyword">if</span>(target.containsKey(c)) target.put(c,target.get(c)+<span class="hljs-number">1</span>);            <span class="hljs-keyword">else</span> target.put(c,<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">while</span>(right&lt;sLen)        &#123;            <span class="hljs-keyword">char</span> c=s.charAt(right);            right++;<span class="hljs-comment">//滑动左指针</span>            <span class="hljs-keyword">if</span>(target.containsKey(c))            &#123;                window.put(c,window.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);                <span class="hljs-keyword">if</span>(window.get(c).equals(target.get(c))) res++;<span class="hljs-comment">//这里不可以使用==，因为是引用类型，比较的是地址，-128~127还可以用，超过就会new一个新对象出来</span>            &#125;            <span class="hljs-keyword">while</span>(res==target.size())<span class="hljs-comment">//满足要求，滑动右指针，缩小窗口</span>            &#123;                <span class="hljs-keyword">if</span>(right-left&lt;minLen)                &#123;                    start=left;                    end=right;                    minLen=end-start;                &#125;                <span class="hljs-keyword">char</span> d=s.charAt(left);                left++;<span class="hljs-comment">//移动右指针</span>                <span class="hljs-keyword">if</span>(target.containsKey(d))                &#123;                    <span class="hljs-keyword">if</span>(target.get(d).equals(window.get(d))) res--;<span class="hljs-comment">//移出元素，导致目标窗口不符合要求</span>                    window.put(d,window.get(d)-<span class="hljs-number">1</span>);                &#125;                            &#125;        &#125;        <span class="hljs-keyword">return</span> minLen==Integer.MAX_VALUE?<span class="hljs-string">""</span>:s.substring(start,end);    &#125;&#125;</code></pre><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p><code>window.get(c).equals(target.get(c))</code>改成 <code>window.get(c)==target.get(c)</code>会报错，原因是map取出来的是Integer类型，Integer第二次创建的时候不会使用new关键字，而是使用已经缓存的对象。 如果数值在-128~127位之间会有缓存，那么两个对象地址相同，此时使用 == 比较结果正确， 如果数值超出范围，就会创建新的对象，分配的地址不同，此时再用 == 比较就会出错。</p><p><code>while(right&lt;sLen){right++}</code>改成<code>for(right=0;right&lt;sLen;right++){}</code>也会报错，原因目前不清楚</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>滑动窗口</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode215-TopK</title>
    <link href="/2020/06/12/LeetCode215-TopK/"/>
    <url>/2020/06/12/LeetCode215-TopK/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode215-TopK"><a href="#LeetCode215-TopK" class="headerlink" title="LeetCode215 TopK"></a>LeetCode215 TopK</h1><p>给定数组，求数组中第K大的元素，最简单的方法是暴力求解，升序排好序后求第K个元素即可，这种解法代码如下：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;            <span class="hljs-keyword">int</span> len=nums.length;            Arrays.sort(nums);            <span class="hljs-keyword">return</span> nums[len-k];    &#125;&#125;</code></pre><p>但是面试官肯定不想你给出这种解法，如果数据量很大，无法一次存到内存中，暴力解法就用不上了</p><p>这种情况需要用堆来排序，建立一个大根堆，堆顶元素是最大值，这样只需要维护K次大根堆，那么就得到了第K大的元素，代码如下</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> len=nums.length;        heapSort(nums,len,k);        <span class="hljs-keyword">return</span> nums[len-k];    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) heapify(nums,size,i);<span class="hljs-comment">//先从最后一个非叶子节点开始调整</span>        <span class="hljs-comment">//上面那个for循环结束就代表着此时堆顶元素就是最大值了</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)        &#123;            swap(nums,<span class="hljs-number">0</span>,i);<span class="hljs-comment">//交换堆顶元素</span>            k--;<span class="hljs-comment">//k--，代表着交换了一次，求的是第K大元素，所以交换K次</span>            <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果k==0，说明交换了k次</span>            heapify(nums,i,<span class="hljs-number">0</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> i)</span><span class="hljs-comment">//维护结点i，使得结点i为合法位置</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> largest=i;        <span class="hljs-keyword">int</span> left=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> right=i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(left&lt;size &amp;&amp; nums[left]&gt;nums[largest] )largest=left;        <span class="hljs-keyword">if</span>(right &lt;size &amp;&amp; nums[right] &gt;nums[largest]) largest=right;        <span class="hljs-keyword">if</span>(i!=largest)        &#123;            swap(nums, i, largest);            heapify(nums,size,largest);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> temp=nums[i];        nums[i]=nums[j];        nums[j]=temp;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>高频面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/2020/06/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式解决的问题是：<strong>创建对象的过程比较复杂，希望对外隐藏这些细节</strong>。比如创建线程池对象、连接池对象等</p><p>工厂模式又分成：简单工厂、静态工厂、抽象工厂模式</p><p><strong>简单工厂模式：</strong>又叫静态工厂模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例</p><p><strong>工厂模式：</strong>实例化对象不适用new，用工厂方法代替</p><p><strong>抽象工厂模式：</strong>抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式</p><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>代码如下</p><pre><code class="hljs java"><span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//实现类---ProductA</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"ProductA"</span>);    &#125;&#125;<span class="hljs-comment">//实现类---ProductB</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"ProductB"</span>);    &#125;&#125;<span class="hljs-comment">//静态工厂</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Product <span class="hljs-title">getPerson</span><span class="hljs-params">(String product)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(product.equals(<span class="hljs-string">"ProductA"</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductA();    <span class="hljs-keyword">if</span>(product.equals(<span class="hljs-string">"ProductB"</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductB();    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-comment">//主线程</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Product p1=StaticFactory.getProduct(<span class="hljs-string">"ProductA"</span>);    Product p2=StaticFactory.getProduct(<span class="hljs-string">"ProductB"</span>);    p1.name();    p2.name();&#125;</code></pre><p>弊端：假如需要新增加一个新产品ProductC，那么就需要修改StaticFactory的原代码，违反了开闭原则</p><p>解决方法：工厂方法模式</p><h2 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂方法模式是在不修改已有类的前提下，通过增加新的工厂来扩展功能</p><p>代码如下</p><pre><code class="hljs java"><span class="hljs-comment">//工厂接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//工厂实现类A</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductA();    &#125;&#125;<span class="hljs-comment">//工厂实现类B</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductB();    &#125;&#125;<span class="hljs-comment">//主程序</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Factory factory1=<span class="hljs-keyword">new</span> FactoryA();    Factory factory2=<span class="hljs-keyword">new</span> FactoryB();    factory1.createProduct().name();    factory2.createProduct().name();&#125;</code></pre><p>如果我们想拓展新的产品，那么只需要添加一个工厂即可，比如想添加产品productC，代码如下</p><pre><code class="hljs java"><span class="hljs-comment">//产品类C</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductC</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"ProductC"</span>);    &#125;&#125;<span class="hljs-comment">//工厂C</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryC</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductC();    &#125;&#125;<span class="hljs-comment">//主线程</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Factory factory1=<span class="hljs-keyword">new</span> FactoryA();    Factory factory2=<span class="hljs-keyword">new</span> FactoryB();    Factory factory3=<span class="hljs-keyword">new</span> FactoryB();<span class="hljs-comment">//构建一个工厂C，用来生产产品C</span>    factory1.createProduct().name();    factory2.createProduct().name();    factory3.createProduct().name();<span class="hljs-comment">//生产产品C</span>&#125;</code></pre><p>上面的两种模式都只有一个产品接口，如果产品接口多了起来，需要很多工厂类，代码量会翻倍，所以需要引入抽象工厂模式。</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>抽象工厂可以认为是有多个接口的工厂方法，比如product中有接口A、接口B、接口C等。类比到手机产品，有充电接口、耳机接口、电池接口等</p><p>代码如下</p><pre><code class="hljs java"><span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OtherProduct</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">look</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//Product接口的实现类见上文</span><span class="hljs-comment">//OtherProduct接口的实现类A</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherProductA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OtherProduct</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">look</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"lookA"</span>);    &#125;&#125;<span class="hljs-comment">//OtherProduct接口的实现类B</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherProductB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OtherProduct</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">look</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"OtherProductB"</span>);    &#125;&#125;<span class="hljs-comment">//OtherProduct接口的实现类C</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherProductC</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OtherProduct</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">look</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"OtherProductC"</span>);    &#125;&#125;<span class="hljs-comment">//工厂接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> OtherProduct <span class="hljs-title">createOtherProduct</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//工厂接口实现类A</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> OtherProduct <span class="hljs-title">createOtherProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OtherProductA();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductA();    &#125;&#125;<span class="hljs-comment">//工厂接口实现类B</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductB();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> OtherProduct <span class="hljs-title">createOtherProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OtherProductB();    &#125;&#125;<span class="hljs-comment">//工厂接口实现类C</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryC</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductC();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> OtherProduct <span class="hljs-title">createOtherProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OtherProductC();    &#125;&#125;<span class="hljs-comment">//主线程</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Factory factory1=<span class="hljs-keyword">new</span> FactoryA();    Factory factory2=<span class="hljs-keyword">new</span> FactoryB();    Factory factory3=<span class="hljs-keyword">new</span> FactoryC();    factory1.createProduct().name();    factory1.createOtherProduct().look();    factory2.createProduct().name();    factory2.createOtherProduct().look();    factory3.createProduct().name();    factory3.createOtherProduct().look();&#125;</code></pre><p>总结：工厂设计模式的出现是为了封装复杂的创建过程，只提供给调用者实现，其中简单工厂和工厂模式可以认为是只有一个接口的抽象工厂</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创建型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2020/06/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式指的是一个类只有一个实例，单例分为饿汉式单例和懒汉式单例</p><p>懒汉式单例：只有再用实例的时候，才去创建这个类的实例</p><p>饿汉式单例：初始化的时候就创建好实例，不管你用不用</p><h2 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//私有构造函数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton=<span class="hljs-keyword">new</span> Singleton();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> singleton;    &#125;&#125;</code></pre><h2 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h2><p>懒汉式单例时面试高频考点，因为多线程下下面这种代码不是线程安全的，面试官会让你不断优化</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//私有构造函数，这样外界就无法通过构造函数来初始化单例</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(singleton==<span class="hljs-keyword">null</span>) singleton=<span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">//当使用这个单例时，发现没有初始化才开始初始化，所以是懒汉式</span>        <span class="hljs-keyword">return</span> singleton;    &#125;&#125;</code></pre><p>上面代码<code>if(singleton==null) singleton=new Singleton();</code>,当有两个线程A和B同时进入到<code>if</code>判断，那么<code>new Singleton()</code>，就会执行两次，所以需要双重检测锁模式的懒汉式单例</p><h3 id="DCL懒汉式单例"><a href="#DCL懒汉式单例" class="headerlink" title="DCL懒汉式单例"></a>DCL懒汉式单例</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//私有构造函数，这样外界就无法通过构造函数来初始化单例</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(singleton==<span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//第一次检测</span>            <span class="hljs-keyword">synchronized</span> (Singleton<span class="hljs-class">.<span class="hljs-keyword">class</span>)//加一把锁</span><span class="hljs-class">            </span>&#123;                <span class="hljs-keyword">if</span>(singleton==<span class="hljs-keyword">null</span>)<span class="hljs-comment">//第二次检测，目的是防止当两个线程同时进入到第一次if判断时，singleton此时为空，当第一个线程执行完代码释放锁后</span>                &#123;<span class="hljs-comment">//第二个线程进入，此时singleton因为已经被第一个线程实例化了，就进不来第二个if判断</span>                    singleton=<span class="hljs-keyword">new</span> Singleton();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> singleton;    &#125;&#125;</code></pre><p>但是上面代码还存在一个问题：<code>singleton=new Singleton();</code>不是原子性操作，它可以分成三步，第一步分配空间，第二步执行构造器方法，初始化对象，第三步将引用指向内存空间，但是JVM编译器会进行<strong>指令重排</strong>，执行顺序可能是132。假如线程A执行到了<code>singleton=new Singleton();</code>，当这一行代码执行顺序是132，先分配空间，再将引用指向内存空间，刚执行完这一步，线程B进来了，因为此时已经把引用指向了内存空间，所以<code>if(singleton==null)</code>判断为false，直接返回<code>singleton</code>，但实际上此时singleton所指向的内存空间还没有初始化，实际还未空，所以线程B返回的<code>singleton</code>实际为<code>null</code></p><h3 id="加Volatile的DCL"><a href="#加Volatile的DCL" class="headerlink" title="加Volatile的DCL"></a>加Volatile的DCL</h3><p>优化：加一个<code>volatile</code>关键字，<code>volatile</code>关键字有两个作用：一个是禁止指令重排、一个是保持变量的内存可见性。所以加了volatile关键字，禁止了JVM的指令重排，也就维护了线程安全</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//私有构造函数，这样外界就无法通过构造函数来初始化单例</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<span class="hljs-comment">//volatile禁止指令重排</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(singleton==<span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//第一次检测</span>            <span class="hljs-keyword">synchronized</span> (Singleton<span class="hljs-class">.<span class="hljs-keyword">class</span>)//加一把锁</span><span class="hljs-class">            </span>&#123;                <span class="hljs-keyword">if</span>(singleton==<span class="hljs-keyword">null</span>)<span class="hljs-comment">//第二次检测，目的是防止当两个线程同时进入到第一次if判断时，singleton此时为空，当第一个线程执行完代码释放锁后</span>                &#123;<span class="hljs-comment">//第二个线程进入，此时singleton因为已经被第一个线程实例化了，就进不来第二个if判断</span>                    singleton=<span class="hljs-keyword">new</span> Singleton();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> singleton;    &#125;&#125;</code></pre><p>但是上面代码还是有问题，我们可以通过反射获取构造器，修改构造器访问权限，然后再使用构造器的<code>newInstance()</code>方法来创建实例，代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Constructor&lt;Singleton&gt; constructor = Singleton<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getDeclaredConstructor</span>(<span class="hljs-title">null</span>)</span>;        constructor.setAccessible(<span class="hljs-keyword">true</span>);        Singleton singleton = constructor.newInstance();        Singleton singleton1=constructor.newInstance();        System.out.println(singleton.hashCode());<span class="hljs-comment">//打印出来hashcode，发现两个对象的hashcode不同，所以不是一个对象</span>        System.out.println(singleton1.hashCode());    &#125;</code></pre><p>解决方法：枚举，关键字<code>enum</code>可以使得JVM阻止反射获取枚举类的私有构造方法</p><h3 id="使用枚举的单例"><a href="#使用枚举的单例" class="headerlink" title="使用枚举的单例"></a>使用枚举的单例</h3><pre><code class="hljs java"><span class="hljs-keyword">enum</span> EnumSingleton &#123;    INSTANCE;    <span class="hljs-function"><span class="hljs-keyword">public</span> EnumSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创建型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2020/06/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式基于六大设计原则，分成三类，一共有23种</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>开闭原则：扩展开发，修改关闭</p><p>单一职责：一个类只负责一件事情</p><p>里氏替换原则：子类应该可以完全替代父类。</p><p>依赖倒置原则：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程。</p><p>迪米特法则：又名最少知道原则，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。</p><p>接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法未被客户端实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法</p><p>组合原则：尽量使用对象组合，而不是继承来达到复用的目的。</p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模型提供创建对象的机制，省去new的步骤</p><p>一共有六种：<strong>单例模式(Singleton)、原型模式(prototype)、工厂方法(Factory method)、抽象工厂(Abstract Factory)</strong>和建造者模式(Builder)</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>作用：从程序实现送耦合，扩大类结构，解决更大的问题</p><p>一共有七种：<strong>组合模式(Composite)、适配器模式(Adapter)、装饰者模式(Decorator)、代理模式(Proxy)</strong>、外观模式(Facade)、桥接模式(Bridge)、享元模式(Flyweight)</p><h2 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h2><p>行为模式负责对象间的高效沟通和职责委派。</p><p>一共有十一种：<strong>策略模式(Strategy)、观察者模式(Observer)</strong>、责任链(chain of Responsibilty)、命令(Command)、迭代器(Iterator)、中介者(Mediator)、备忘录(Memento)、状态(State)、模板方法(Template Method)、访问者(Visitor)、解释器模式(Interpreter)</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>大纲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC</title>
    <link href="/2020/06/11/SpringMVC/"/>
    <url>/2020/06/11/SpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC（待续）"><a href="#SpringMVC（待续）" class="headerlink" title="SpringMVC（待续）"></a>SpringMVC（待续）</h1><p>MVC是一种开发模式，将程序分层的一种思想。</p><blockquote><p>M：Model—&gt;业务数据（service、repository、entity）</p><p>V：View—&gt;视图（JSP、HTML、APP客户端）</p><p>C：Controller—&gt;控制（Servlet、Handler、Action）</p><p>这三者关系简单来说是：请求进入Controller，Controller调用业务模型Model，Model再去数据库获取数据，然后返回View层</p></blockquote><p>SpringMVC就是通过DispatcherServlet将一堆组件串联起来的Web框架，SpringMVC的整个运行体系，是由DispatcherServlet、组件和容器这三者共同构成的。DispatcherServlet是逻辑处理的<strong>调度中心</strong>，组件则是被调度的操作对象。而容器在这里所起到的作用，是协助DispatcherServlet更好地对组件进行管理。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200615132013.png" srcset="/img/loading.gif" alt="image-20200615132008381"></p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>DispatcherServlet：前置控制器，将请求分发到不同的处理器，整个流程控制的核心，控制其他组件的执行，进行统一调度，降低组件之间的耦合性。</p><p>Handler：处理器，完成具体的业务逻辑，相当于Servlet</p><p>HandlerMapping：处理器映射器，DispatcherServlet接受到请求后，调用HandlerMapping将不同的请求映射到不同的Handler</p><p>HandlerInterceptor：处理器拦截器，主要功能是负责拦截一些请求和操作</p><p>HandlerExecutionChain：处理器执行链，包括两部分：Handler和HandlerInterceptor</p><p>HandlerAdapter：处理器适配器，handler执行业务方法之前，需要进行一系列操作，包括表单数据的验证、数据类型的转换、将表单数据封装到JavaBean等，使得开发者只需要将注意力集中到业务逻辑的处理上。DispatcherServlet通过HandlerAdapter执行不同的Handler</p><p>ModelAndView：装载了模型数据和视图信息，作为Handler的处理结果，返回给DispatcherServlet</p><p>ViewResolver：视图解析器，DispatcherServlet通过它将逻辑视图解析为物理视图。逻辑视图不是真实存在的一个视图，逻辑概念，物理视图是真实存在的</p><h3 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h3><p>客户端发起请求，DispatcherServlet接受请求</p><p>HandlerMapping根据不同的请求映射到不同的Handler上，返回一个HandlerExecutionChain给DispatcherServlet</p><p>DispatcherServlet调用HandlerAdapter执行handler，handler执行完毕后返回一个ModelAndView</p><p>DispatcherServlet拿到结果后解析ModelAndView，解析由ViewResolver负责解析，把逻辑视图解析成物理视图。解析结果返回给DispatcherServlet</p><p>DispatcherServlet根据View进行视图渲染，将模型数据填充到视图View中</p><p>DispatcherServlet将渲染后的结果响应再返回给客户端</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200613165102.png" srcset="/img/loading.gif" alt="image-20200613165056813"></p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200615141505.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200615141313.png" srcset="/img/loading.gif" alt="image-20200615141309525"></p><h2 id="DispatcherServlet：前置控制器"><a href="#DispatcherServlet：前置控制器" class="headerlink" title="DispatcherServlet：前置控制器"></a>DispatcherServlet：前置控制器</h2><p>结构图：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200615132420.png" srcset="/img/loading.gif" alt="image-20200615132416258"></p><p>DispatcherServlet对于容器<strong>WebApplicationContext</strong>的初始化是在FrameworkServlet中完成的，在默认情况下，这个初始化过程是由web.xml中的入口程序配置所驱动的</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Processes application requests --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/**<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据Spring的设计原则，所有纳入WebApplicationContext中管理的对象，都被映射为XML中的一个&lt;bean&gt;节点，通过对于&lt;bean&gt;节点的一个完整描述，我们可以有效地将整个应用程序中所有的对象都纳入到一个统一的容器中进行管理--&gt;</span></code></pre><p>在默认情况下，web.xml配置节点中<code>&lt;servlet-name&gt;</code>的值就是建立起核心分发器DispatcherServlet与核心配置文件之间联系的桥梁。DispatcherServlet在初始化时会加载位置在/WEB-INF/[servlet-name]-servlet.xml的配置文件作为SpringMVC的核心配置。</p><p>SpringMVC核心配置文件中所有的bean定义，就是SpringMVC的组件定义，也是DispatcherServlet在初始化容器（WebApplicationContext）时，所要进行初始化的组件。</p><p>概括一下WebApplicationContext初始化的两个逻辑层次：</p><ul><li><strong>DispatcherServlet负责对容器（WebApplicationContext）进行初始化。</strong></li><li><strong>容器（WebApplicationContext）将读取SpringMVC的核心配置文件进行组件的实例化。</strong></li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>@RequestMapping</p><p>作用：映射URL到控制器类（实现了Controller的类，就是一个控制类）或一个特定的处理程序方法。可以用于类或者方法上。用于类上表示所有响应请求的方法都是以该地址作为父路径</p><pre><code class="hljs java"><span class="hljs-comment">//浏览器地址栏输入：http://localhost:8080/c3/t1访问该方法</span><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/c3"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/t1"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span></span>&#123;        model.addAttribute(<span class="hljs-string">"msg"</span>,<span class="hljs-string">"Hello ,annotation"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;    &#125;&#125;</code></pre><p>接受请求参数以及参数回显：</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/c2"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span><span class="hljs-params">(User user)</span></span><span class="hljs-function"></span>&#123;    System.out.println(user);    <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;&#125;<span class="hljs-comment">//http://localhost:8080/c2?name=qsq&amp;id=12&amp;age=6</span></code></pre><p>参数</p><blockquote><p>value：直到URL请求的实际地址，是@RequestMapping的默认值</p><p>method：指定请求的类型（GET/POST/PUT/DELETE），表示该方法只可以被指定请求来访问，不加的话get和post都可以</p><p>params：表示指定请求中必须含有某些参数，否则无法访问</p></blockquote><p>SpringMVC支持restful风格，使用方式</p><blockquote><p>@RequestMapping(“/xx/{xx}/{xx}”)，而且必须在形参列表加注解@PathVariable(“xx”)，传统方式是参数名和形参名一样即可</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//http://localhost:8080/c3/t1/1/2。。。浏览器输入</span><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/c3"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/t1/&#123;a&#125;/&#123;b&#125;"</span>,method = RequestMethod.POST)<span class="hljs-comment">//浏览器按回车，会出现405，请求方式不支持，必须是GET请求才可以</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@PathVariable <span class="hljs-keyword">int</span> a,@PathVariable <span class="hljs-keyword">int</span> b, Model model)</span></span>&#123;        <span class="hljs-keyword">int</span> res=a+b;        model.addAttribute(<span class="hljs-string">"msg"</span>,<span class="hljs-string">"计算结果为"</span>+res);        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;    &#125;&#125;<span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/c3"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@PostMapping</span>(value = <span class="hljs-string">"/t1/&#123;a&#125;/&#123;b&#125;"</span>)<span class="hljs-comment">//这里就限制了请求的方式</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@PathVariable <span class="hljs-keyword">int</span> a,@PathVariable <span class="hljs-keyword">int</span> b, Model model)</span></span>&#123;        <span class="hljs-keyword">int</span> res=a+b;        model.addAttribute(<span class="hljs-string">"msg"</span>,<span class="hljs-string">"计算结果为"</span>+res);        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;    &#125;&#125;</code></pre><p>@Controller</p><p>作用：将该类交给IOC容器来管理（结合springmvc.xml的自动扫描配置使用），成为一个控制器，可以接受客户端请求</p><p>被这个注解的类中所有方法，如果返回值是String类型，并且由具体页面可以跳转，那么就会被视图解析器解析</p><p>@RestController</p><p>作用：该控制器会直接将业务方法的返回值响应给客户端，不进行视图解析</p><p>@RequestParam</p><p>作用：在形参列表中添加该注解，可以完成请求参数与业务方法形参的映射</p><p>@ResponseBody</p><p>作用：直接返回该类型值给客户端，如果不加，SpringMVC会将该方法传递给DispatcherServlet，再由DispatcherServlet调用ViewResolver对返回值进行解析，映射到JSP资源</p><p>数据绑定：直接获取客户端HTTP请求中的参数，将参数映射到业务方法的形参中，该工作由HandleAdapter完成</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>常用依赖</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>       <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></blockquote><p>spring配置文件</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">"http://www.springframework.org/schema/p"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><span class="hljs-comment">&lt;!--处理器映射器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span>/&gt;</span><span class="hljs-comment">&lt;!--处理器适配器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span>/&gt;</span><span class="hljs-comment">&lt;!--视图解析器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"InternalResourceViewResolver"</span>&gt;</span><span class="hljs-comment">&lt;!--       前缀--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/jsp/"</span>/&gt;</span><span class="hljs-comment">&lt;!--        后缀--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><p>注解版配置文件</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">"http://www.springframework.org/schema/mvc"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/context/spring-context.xsd</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/mvc</span></span><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span><span class="hljs-comment">&lt;!--     自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.guo.controller"</span>/&gt;</span><span class="hljs-comment">&lt;!--    让SpringMVC不再处理静态资源，css/js/html--&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><span class="hljs-comment">&lt;!--     支持mvc注解驱动，在spring中采用@RequestMapping注解来完成映射关系，要想使@RequestMaping生效，必须向上下文</span><span class="hljs-comment">    注册DefaultAnnotaionHandlerMapping和一个AnnotationMethodHandlerAdapter实例</span><span class="hljs-comment">    这两个实例方法分别再类级别和方法级别处理，而annotation-driven配置帮助我们自动完成上述两个实例的注入--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><span class="hljs-comment">&lt;!--    视图解析器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span></span><span class="hljs-tag">    <span class="hljs-attr">id</span>=<span class="hljs-string">"internalResourceViewResolver"</span>&gt;</span><span class="hljs-comment">&lt;!--        前缀--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/jsp/"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>/&gt;</span><span class="hljs-comment">&lt;!--    后缀--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><p>web.xml配置文件</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">"4.0"</span>&gt;</span><span class="hljs-comment">&lt;!--    配置DispatcherServlet--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-comment">&lt;!--    绑定spring配置文件--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span></code></pre><p>导入Json</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.68<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Spring：<a href="https://docs.spring.io/spring/docs/4.3.24.RELEASE/spring-framework-reference/html/mvc.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/4.3.24.RELEASE/spring-framework-reference/html/mvc.html</a></p>]]></content>
    
    
    <categories>
      
      <category>SSM</category>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2020/06/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/06/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h1><p>各个算法的时间和空间复杂度如下图所示：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200611124222.png" srcset="/img/loading.gif" alt="image-20200611124218763"></p><p>选择排序：最稳定的排序算法，无论什么情况时间复杂度否是O(n^2)</p><p>插入排序：采用in-place内部排序，空间复杂度为O(1)</p><p>归并排序：稳定的排序算法，分治思想的典型应用，先使子序列有序，再将两个子序列合并成有序序列</p><p>快速排序：不稳定</p><p>堆排序：利用数据结构堆设计的排序算法</p><p>计数排序：稳定排序算法，不是基于比较的排序算法，将数组转换成键值对的形式存储在额外的数组空间</p><p>桶排序：稳定，桶的划分很重要</p><p>基数排序：稳定，按照数字位上的数排序。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基数排序</title>
    <link href="/2020/06/11/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/11/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>基数排序是桶排序的升级版把数组中每一个数字，都分成不同位，先比较数字不同位的大小，先按照个位大小排序，再按照十位大小排序….一直到最高位，最高位的排序结果就是最终的排序结果，具体见下图，图片来自@sky。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200611122731.png" srcset="/img/loading.gif" alt="image-20200611122725122"></p><p>Java代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buicketSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> maxExp=getExp(nums);    <span class="hljs-keyword">int</span> len=nums.length;    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) lists.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<span class="hljs-comment">//因为是十进制，所以有0~9，十个桶</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=maxExp;i++)    &#123;        <span class="hljs-comment">//1234,假如想得到百位的2，应该是1234%1000=234,234/100=2，所以应该先取模，再相除，最终就知道了值</span>        <span class="hljs-keyword">double</span> exp1=Math.pow(<span class="hljs-number">10</span>, i);        <span class="hljs-keyword">double</span> exp2=Math.pow(<span class="hljs-number">10</span>,i-<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)<span class="hljs-comment">//先按照位添加到指定数组中</span>        &#123;            <span class="hljs-keyword">int</span> index=(<span class="hljs-keyword">int</span>)(nums[j]%exp1/exp2);<span class="hljs-comment">//算出这数字nums[j]的某一位的值，来决定添加到哪一个桶上</span>            lists.get(index).add(nums[j]);<span class="hljs-comment">//添加到指定桶</span>        &#125;        <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<span class="hljs-comment">//下标，按照位排好序的结果要写回原数组</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">10</span>;j++)<span class="hljs-comment">//遍历list中的每一个数组，将其写回到原数组中去</span>        &#123;            <span class="hljs-keyword">while</span> (lists.get(j).size()&gt;<span class="hljs-number">0</span>)            &#123;                ArrayList&lt;Integer&gt; temp=lists.get(j);                nums[k++]=temp.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//把按照某一位排序的结果写回到数组</span>                temp.remove(<span class="hljs-number">0</span>);            &#125;        &#125;    &#125;&#125;</code></pre><p>用处：主要用于处理数字较多的情况，比如手机号排序。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桶排序</title>
    <link href="/2020/06/11/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/11/%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>桶排序是一种计数排序的升级版，如果把每一个数都看成是一个桶的话，那么桶排序就是计数排序，简单来说就是生成若干个桶，每一个桶存放指定范围内的数据，如数组范围是0<del>100，有十个桶，每一个桶的范围分别是0</del>10,10~20，….等，通过把数据分到桶中，再对桶中数据进行排序，然后再依次从桶中取出数据，即为最终排好序的数据。桶排序需要尽量保证元素分散均匀，否则当所有数据集中在同一个桶中时，桶排序失效</p><p>注：桶之间也是有序的，即后一个桶的最小值是大于前一个桶的最大值的。</p><p>Java代码如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buicketSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> min=nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> max=nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> len=nums.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">if</span>(min&gt;nums[i]) min=nums[i];        <span class="hljs-keyword">if</span> (max&lt;nums[i]) max=nums[i];    &#125;    <span class="hljs-keyword">int</span> buicketNum=(max-min)/len+<span class="hljs-number">1</span>;<span class="hljs-comment">//确定桶的个数</span>    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; buicket=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;buicketNum;i++)    &#123;        buicket.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)        buicket.get((i-min)/len).add(nums[i]);<span class="hljs-comment">//按照元素的值来放到指定的桶内</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;buicketNum;i++)        Collections.sort(buicket.get(i));<span class="hljs-comment">//每一个桶内的排序方式任意</span>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;buicketNum;i++)<span class="hljs-comment">//遍历桶，后一个桶内的最小值是大于前一个桶内的最大值的。</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;buicket.get(i).size();i++)            nums[index++]= buicket.get(i).get(j);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计数排序</title>
    <link href="/2020/06/11/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/11/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序是通过数组中元素出现的次数来计数的，先找到数组中的最大值max，然后建立一个长度为max+1的数组count，对原数组nums中的数字出现的次数遍历，最后再遍历count数组，如果count[i]值不为空，说明nums中有这个值，输出回原数组nums，遍历完count数组，即得到了nums数组排序后的结果</p><p>代码如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录数组最大值</span>    <span class="hljs-keyword">int</span> len=nums.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">if</span>(res&lt;nums[i]) res=nums[i];<span class="hljs-comment">//找到数组最大值</span>    &#125;    <span class="hljs-keyword">int</span>[] count=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res+<span class="hljs-number">1</span>];<span class="hljs-comment">//建立长度为res+1的计数数组</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) count[nums[i]]++;<span class="hljs-comment">//计算nums[i]出现的次数</span>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;res;i++)<span class="hljs-comment">//遍历count数组</span>    &#123;        <span class="hljs-keyword">while</span> (count[i]&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//如果数组大于0，说明nums数组中有i这个值</span>        &#123;            nums[k++]=i;<span class="hljs-comment">//将这个值写会到数组中</span>            count[i]--;<span class="hljs-comment">//i这个值出现次数-1</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(i&gt;=nums.length) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> temp=nums[i];    nums[i]=nums[j];    nums[j]=temp;&#125;</code></pre><p>优化：</p><p>容易发现count数组小于下标nums中最小值的空间都被浪费了，是不可能存在值的，所以可以建立一个长度为Max-min+1数组</p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> max=nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> min=nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> len=nums.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">if</span>(max&lt;nums[i]) max=nums[i];        <span class="hljs-keyword">if</span>(min&gt;nums[i]) min=nums[i];    &#125;    <span class="hljs-keyword">int</span>[] count=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max-min+<span class="hljs-number">1</span>];<span class="hljs-comment">//优化空间</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) count[nums[i]-min]++;<span class="hljs-comment">//优化代码</span>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;max-min+<span class="hljs-number">1</span>;i++)    &#123;        <span class="hljs-keyword">while</span> (count[i]&gt;<span class="hljs-number">0</span>)        &#123;            nums[k++]=i+min;<span class="hljs-comment">//优化代码</span>            count[i]--;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(i&gt;=nums.length) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> temp=nums[i];    nums[i]=nums[j];    nums[j]=temp;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序</title>
    <link href="/2020/06/11/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/11/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆是一颗完全二叉树，即除了最后一层，其余每一层的左右结点都被填满，且最后一层叶子节点从左到右依次填充</p><p>大根堆：根节点的值大于左右结点的值(不要求左右节点的相对大小，即左节点一定要大于右节点或者右节点一定要大于左节点)</p><p>小根堆：根节点的值小于左右结点的值</p><p>下面讲解大根堆的堆排序</p><p>堆排序是通过维护一个大根堆，来使得堆顶元素总是为最大值，交换堆顶元素和最后一个结点元素，这样最大值就跑到了数组最后，然后继续维护剩余元素为一个大根堆，再交换堆顶元素和倒数第二个元素，以此类推，这样不断交换最大值，最终实现了排序。</p><p>注意：数组下标在堆中的对应关系：因为堆是一颗完全二叉树，所以下标为i的根节点，左节点的下标为<code>i*2+1</code>，右节点下标为<code>i*2+2</code></p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heap, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> i)</span><span class="hljs-comment">//维护下标为i的结点，使得该节点值大于左右子节点的值</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> max_index=i;<span class="hljs-comment">//下标为i的结点</span>    <span class="hljs-keyword">int</span> left=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//i结点的左节点</span>    <span class="hljs-keyword">int</span> right=i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;<span class="hljs-comment">//i节点的右节点</span>    <span class="hljs-keyword">if</span>(left&lt;size &amp;&amp; heap[left]&gt;heap[max_index]) max_index=left;<span class="hljs-comment">//记录最大值的下标</span>    <span class="hljs-keyword">if</span>(right &lt;size &amp;&amp; heap[right]&gt;heap[max_index]) max_index=right;    <span class="hljs-keyword">if</span>(max_index!=i)<span class="hljs-comment">//如果下标i的值小于左右节点中的最大值</span>    &#123;        swap(heap,max_index,i);<span class="hljs-comment">//交换堆顶元素和左右节点中的最大值</span>        heapify(heap,size,max_index);<span class="hljs-comment">//下标为i的结点被交换下来，继续维护这个结点，使得这个结点为大根堆</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heap, <span class="hljs-keyword">int</span> size)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        heapify(heap,size,i);<span class="hljs-comment">//维护每一个非叶子节点</span>    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        swap(heap,<span class="hljs-number">0</span>,i);<span class="hljs-comment">//上面已经建好一个大根堆，所以堆顶元素为最大值，把最大值放到数组最后面</span>        heapify(heap,i,<span class="hljs-number">0</span>);<span class="hljs-comment">//继续维护，数组此时长度减一</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(i&gt;=nums.length) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> temp=nums[i];    nums[i]=nums[j];    nums[j]=temp;&#125;</code></pre><p>小根堆代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heap, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> i)</span><span class="hljs-comment">//维护下标为i的结点，使得该节点值小于左右子节点的值</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> min_index=i;    <span class="hljs-keyword">int</span> left=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> right=i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span>(left&lt;size &amp;&amp; heap[left]&lt;heap[min_index]) min_index=left;<span class="hljs-comment">//只需要heap[left]&gt;heap[min_index]改成heap[left]&lt;heap[min_index]即可</span>    <span class="hljs-keyword">if</span>(right &lt;size &amp;&amp; heap[right]&lt;heap[min_index]) min_index=right;<span class="hljs-comment">//同上</span>    <span class="hljs-keyword">if</span>(max_index!=i)    &#123;        swap(heap,min_index,i);        heapify(heap,size,min_index);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heap, <span class="hljs-keyword">int</span> size)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        heapify(heap,size,i);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        swap(heap,<span class="hljs-number">0</span>,i);        heapify(heap,i,<span class="hljs-number">0</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(i&gt;=nums.length) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> temp=nums[i];    nums[i]=nums[j];    nums[j]=temp;&#125;</code></pre><p>参考资料：</p><p>图解排序算法：<a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p><p>排序算法总结：<a href="https://www.acwing.com/blog/content/2064/" target="_blank" rel="noopener">https://www.acwing.com/blog/content/2064/</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2020/06/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序先把数组分成两半，每一半再递归进行平分，当只有一个元素时，递归结束。然后两两比较值，合并数组，进行排序。</p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">//找到数组中点</span>    merge_sort(q,l,mid);<span class="hljs-comment">//递归左半部分</span>    merge_sort(q,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//递归右半部分</span>    <span class="hljs-keyword">int</span> i=l,j=mid+<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(i &lt;=mid &amp;&amp; j&lt;=r)<span class="hljs-comment">//递归结束后，开始左右两部分的值，进行排序</span>    &#123;        <span class="hljs-keyword">if</span>(q[i]&lt;q[j]) temp[k++]=q[i++];<span class="hljs-comment">//temp数组用来继续排序结果</span>        <span class="hljs-keyword">else</span> temp[k++]=q[j++];    &#125;    <span class="hljs-keyword">while</span>(i&lt;=mid) temp[k++]=q[i++];<span class="hljs-comment">//如果左半部分还有值</span>    <span class="hljs-keyword">while</span>(j&lt;=r) temp[k++]=q[j++];<span class="hljs-comment">//如果右半部分还有值</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> w=l,k=<span class="hljs-number">0</span>;w&lt;=r;w++,k++) q[w]=temp[k];<span class="hljs-comment">//将temp记录的排好序后的元素写回到原数组</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2020/06/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快排是从数组中选一个锚点privot，把数组按照锚点分成小于锚点的值和大于锚点的值两部分，然后再递归求解这两部分</p><p>下面这种解法来自@Diamondz </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//if(i&gt;=nums.length) return;</span>    <span class="hljs-keyword">int</span> temp=nums[i];    nums[i]=nums[j];    nums[j]=temp;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(left&gt;=right) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果区间长度为1，则返回</span>    <span class="hljs-keyword">int</span> privot=nums[left];<span class="hljs-comment">//选定锚点</span>    <span class="hljs-keyword">int</span> j=left;<span class="hljs-comment">//j表示锚点值privot在数组中排第几</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left+<span class="hljs-number">1</span>;i&lt;=right;i++)    &#123;        <span class="hljs-keyword">if</span>(nums[i]&lt;privot)<span class="hljs-comment">//如果有值小于privot</span>        &#123;            j++;<span class="hljs-comment">//那么就让privot的排名上升一位</span>            swap(nums,j,i);<span class="hljs-comment">//交换的目的：把小于privot的值都放到左边</span>        &#125;    &#125;    <span class="hljs-comment">//遍历完区间[left,right]后可以得到，privot在数组中排序为j,所以交换锚点的位置，从left到j</span>    swap(nums,left,j);<span class="hljs-comment">//遍历完毕后，把锚点和j位置交换一下，j位置表示锚点privot在这个数组中的排序</span>    quickSort(nums,left,j-<span class="hljs-number">1</span>);    quickSort(nums,j+<span class="hljs-number">1</span>,right);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序</title>
    <link href="/2020/06/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>把第一个元素看成是一个有序序列，然后后面的元素看成是无序序列，从这个无序序列中依次取出元素，<strong>选择</strong>应该插到前面有序序列的哪个位置</p><p><strong>注意</strong>：插入排序，不是一次就直接找到了位置，插入，而是要一个一个比较值，交换值，最后才可以找到正确位置。</p><p><strong>思路</strong>：对于无序序列的值A，在有序序列中找到一个比他的大的值就和他交换，最后停留的位置就是值A此时在有序序列中的位置。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">choseSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=nums.length;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> index=-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)<span class="hljs-comment">//无序数组的下标</span>        &#123;            res=nums[i];            index=i;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--)<span class="hljs-comment">//从后往前扫描有序数组</span>            &#123;                <span class="hljs-keyword">if</span>(nums[i]&lt;nums[j])<span class="hljs-comment">//如果无序数组的值，小于有序数组的值，说明就找到了插入位置</span>                &#123;                    swap(nums,i,j);                &#125;                <span class="hljs-keyword">else</span><span class="hljs-comment">//如果无序数组的值，大于有序数组，说明此时已经到了正确位置</span>                    <span class="hljs-keyword">break</span>;            &#125;        &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">     </span>&#123;         <span class="hljs-keyword">int</span> temp=nums[i];         nums[i]=nums[j];         nums[j]=temp;     &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/2020/06/10/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/10/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序就是选择最大值，放到最后/最前面。</p><p>在未排序的序列中找打最大值，然后将其放到最后</p><p>再从剩余的未排序序列中找到次大值，放到倒数第二个位置</p><p>依次类推，直到结束</p><p>Java代码如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=nums.length;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> index=-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len-<span class="hljs-number">1</span>;i++)<span class="hljs-comment">//剩余未排序数组的长度</span>        &#123;            res=nums[<span class="hljs-number">0</span>];            index=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len-i;j++)<span class="hljs-comment">//在剩余未排序序列中，选出剩余未排序序列的最大值</span>            &#123;                <span class="hljs-keyword">if</span>(nums[j]&gt;res)                &#123;                    res=nums[j];                    index=j;                &#125;            &#125;            swap(nums,index,len-<span class="hljs-number">1</span>-i);        &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">     </span>&#123;         <span class="hljs-keyword">int</span> temp=nums[i];         nums[i]=nums[j];         nums[j]=temp;     &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/2020/06/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序：给定数组nums，比较元素nums[i]和nums[i+1],如果nums[i+1] &lt; nums[i]就交换两者，从第一个元素开始，两两比较，这样一轮下来，最后一个元素一定是最大值，第二轮再从第一个元素开始，倒数第二个元素截止，第二轮结束后，倒数第二个元素一定是这一轮中的最大值，这样不断的把最大值选出来，放到最后的排序算法就是冒泡排序</p><p>java代码如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=nums.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;len--)<span class="hljs-comment">//剩余未排序数组的长度</span>        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len-<span class="hljs-number">1</span>-i;j++)<span class="hljs-comment">//可以进行比较的数组下标范围</span>            &#123;                <span class="hljs-keyword">if</span>(nums[j+<span class="hljs-number">1</span>]&lt;nums[j])                    swap(nums,j,j+<span class="hljs-number">1</span>);            &#125;        &#125;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">     </span>&#123;         <span class="hljs-keyword">int</span> temp=nums[i];         nums[i]=nums[j];         nums[j]=temp;     &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode114-二叉树展开为链表</title>
    <link href="/2020/06/10/LeetCode114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/06/10/LeetCode114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode114-二叉树展开为链表"><a href="#LeetCode114-二叉树展开为链表" class="headerlink" title="LeetCode114-二叉树展开为链表"></a>LeetCode114-二叉树展开为链表</h1><p>思路：二叉树转成链表，这个链表要求把左节点放到根节点后面，右节点的前面，转换过程先把右子树转成链表，再转左子树。</p><p>对于每一个节点的转换，需要记录上一次操作返回的根节点，因为当前结点的下一个结点就是上次的根节点。</p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    TreeNode prev=<span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        flatten(root.right);        flatten(root.left);        root.right=prev;        root.left=<span class="hljs-keyword">null</span>;        prev=root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode617-合并二叉树</title>
    <link href="/2020/06/10/LeetCode617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/06/10/LeetCode617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode617-合并二叉树"><a href="#LeetCode617-合并二叉树" class="headerlink" title="LeetCode617 合并二叉树"></a>LeetCode617 合并二叉树</h1><p>思路：给定两颗二叉树A和B，在A的基础上合并成一颗新树，遍历A的每一个节点。如果A和B的节点都为空，就返回空，如果A，B只有一个不为空，返回不会空的那个结点，如果两者都不为空，返回两个节点之和</p><p>代码</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode t1, TreeNode t2)</span> </span>&#123;                <span class="hljs-keyword">if</span>(t1==<span class="hljs-keyword">null</span> &amp;&amp; t2==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t1==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> t2;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t2==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> t1;        t1.val+=t2.val;        t1.left=mergeTrees(t1.left,t2.left);        t1.right=mergeTrees(t1.right,t2.right);        <span class="hljs-keyword">return</span> t1;    &#125;   &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode104-求二叉树的最大高度</title>
    <link href="/2020/06/10/LeetCode104-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/"/>
    <url>/2020/06/10/LeetCode104-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode104-求二叉树的最大高度"><a href="#LeetCode104-求二叉树的最大高度" class="headerlink" title="LeetCode104 求二叉树的最大高度"></a>LeetCode104 求二叉树的最大高度</h1><p>思路：二叉树的最大高度=max（左子树的最大高度，右子树的最大高度）+1，所以递归求解</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> dfs(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>)        &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> left=dfs(node.left);        <span class="hljs-keyword">int</span> right=dfs(node.right);        <span class="hljs-keyword">return</span> Math.max(left,right)+<span class="hljs-number">1</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode226-翻转二叉树</title>
    <link href="/2020/06/10/LeetCode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/06/10/LeetCode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode226-翻转二叉树"><a href="#LeetCode226-翻转二叉树" class="headerlink" title="LeetCode226 翻转二叉树"></a>LeetCode226 翻转二叉树</h1><p>思路：把节点放到队列，先把右子树放到节点，再把左子树放到节点，然后再生成二叉树</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        Queue&lt;TreeNode&gt; queue=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.offer(root);<span class="hljs-comment">//把根节点压入队列</span>        <span class="hljs-keyword">while</span>(!queue.isEmpty())        &#123;            TreeNode node=queue.poll();<span class="hljs-comment">//弹出队列的队首元素</span>            <span class="hljs-keyword">if</span>(node!=<span class="hljs-keyword">null</span>)<span class="hljs-comment">//依次遍历每一个节点</span>            &#123;                TreeNode left=node.left;<span class="hljs-comment">//记录节点的左节点</span>                TreeNode right=node.right;<span class="hljs-comment">//记录节点的右节点</span>                queue.offer(right);<span class="hljs-comment">//先压入右节点</span>                queue.offer(left);<span class="hljs-comment">//再压入左节点</span>                node.left=right;<span class="hljs-comment">//把节点的左右指向交换</span>                node.right=left;            &#125;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode654-最大二叉树</title>
    <link href="/2020/06/10/LeetCode654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/06/10/LeetCode654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode654-最大二叉树"><a href="#LeetCode654-最大二叉树" class="headerlink" title="LeetCode654 最大二叉树"></a>LeetCode654 最大二叉树</h1><p>题目：</p><pre><code class="hljs java">给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：二叉树的根是数组中的最大元素。左子树是通过数组中最大值左边部分构造出的最大二叉树。右子树是通过数组中最大值右边部分构造出的最大二叉树。通过给定的数组构建最大二叉树，并且输出这个树的根节点。</code></pre><p>思路：分治递归，先找到数组中元素的最大值，然后分成左右两部分，左边是左子树，右边是右子树，对于每一个子树，再进行分治递归</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">return</span> dfs(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>);            &#125;    <span class="hljs-function">TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(end&lt;start) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> index=start;        <span class="hljs-keyword">int</span> maxValue=nums[index];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start+<span class="hljs-number">1</span>;i&lt;=end;i++)        &#123;            <span class="hljs-keyword">if</span>(nums[i]&gt;maxValue)            &#123;                index=i;                maxValue=nums[index];            &#125;        &#125;        TreeNode node=<span class="hljs-keyword">new</span> TreeNode(nums[index]);        node.left=dfs(nums,start,index-<span class="hljs-number">1</span>);        node.right=dfs(nums,index+<span class="hljs-number">1</span>,end);        <span class="hljs-keyword">return</span> node;    &#125;        &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode101-判断二叉树是否对称</title>
    <link href="/2020/06/10/LeetCode101-%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0/"/>
    <url>/2020/06/10/LeetCode101-%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode101-判断二叉树是否对称"><a href="#LeetCode101-判断二叉树是否对称" class="headerlink" title="LeetCode101 判断二叉树是否对称"></a>LeetCode101 判断二叉树是否对称</h1><p>思路：二叉树对称指的是，要求每一个节点Node的左右子树要对称，而且左右子树的左右子树也要对称，即</p><pre><code class="hljs java">Node.left=Node.right;left.left=right.left;left.right=right.left;具体看下图</code></pre><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200610120726.png" srcset="/img/loading.gif" alt="image-20200610120720720"></p><p>递归求解每一个节点，如果有一个节点不满足上述条件，即返回true，这个二叉树不是对称二叉树</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> dfs(root.left,root.right);    &#125;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode left, TreeNode right)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(left==<span class="hljs-keyword">null</span> &amp;&amp; right==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(left ==<span class="hljs-keyword">null</span> || right ==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(left.val!=right.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> dfs(left.left,right.right) &amp;&amp; dfs(left.right,right.left);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode102-二叉树层序遍历</title>
    <link href="/2020/06/10/LeetCode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/06/10/LeetCode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-二叉树层序遍历"><a href="#LeetCode-二叉树层序遍历" class="headerlink" title="LeetCode 二叉树层序遍历"></a>LeetCode 二叉树层序遍历</h1><p>思路：用队列实现，把每一个节点都放到队列中去，遍历队列中每一个节点，把每一个节点的左右子树都加入到队列，然后再把这个结点出队，依次遍历直到队列为空</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; res=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;        Queue&lt;TreeNode&gt; queue=<span class="hljs-keyword">new</span> LinkedList();        queue.offer(root);        <span class="hljs-keyword">while</span>(!queue.isEmpty())        &#123;            <span class="hljs-keyword">int</span> size=queue.size();            List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)            &#123;                TreeNode node=queue.poll();                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-keyword">null</span>) queue.offer(node.left);                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-keyword">null</span>) queue.offer(node.right);                list.add(node.val);            &#125;            res.add(<span class="hljs-number">0</span>,list);        &#125;                <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode144-二叉树前序遍历</title>
    <link href="/2020/06/10/LeetCode144-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/06/10/LeetCode144-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode144-二叉树前序遍历"><a href="#LeetCode144-二叉树前序遍历" class="headerlink" title="LeetCode144 二叉树前序遍历"></a>LeetCode144 二叉树前序遍历</h1><h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><p>递归遍历有模板，简单套用即可</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; list;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        dfs(root);        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        list.add(node.val);        dfs(node.left);        dfs(node.right);    &#125;&#125;</code></pre><h2 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h2><p>前序遍历是：根左右，所以使用栈来实现，先放入右节点，再放入左节点，这样可以保证根节点的右节点是在左节点遍历完之后才会遍历</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        Stack&lt;TreeNode&gt; stack=<span class="hljs-keyword">new</span> Stack&lt;&gt;();<span class="hljs-comment">//使用栈的先进后出的特性</span>        List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> list;        stack.push(root);        <span class="hljs-keyword">while</span>(!stack.empty())        &#123;            TreeNode temp=stack.pop();            list.add(temp.val);            <span class="hljs-keyword">if</span>(temp.right!=<span class="hljs-keyword">null</span>) stack.push(temp.right);<span class="hljs-comment">//先放入右节点</span>            <span class="hljs-keyword">if</span>(temp.left!=<span class="hljs-keyword">null</span>) stack.push(temp.left);<span class="hljs-comment">//再放入左节点</span>        &#125;        <span class="hljs-keyword">return</span> list;        &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode94-二叉树中序遍历</title>
    <link href="/2020/06/10/LeetCode94-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/06/10/LeetCode94-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode94-二叉树中序遍历"><a href="#LeetCode94-二叉树中序遍历" class="headerlink" title="LeetCode94 二叉树中序遍历"></a>LeetCode94 二叉树中序遍历</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; list;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        dfs(root);        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        dfs(node.left);        list.add(node.val);        dfs(node.right);    &#125;        &#125;</code></pre><h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><p>中序遍历顺序是左根右，用栈辅助实现</p><p>先判断结点是否为空，不为空，说明是根节点，然后压入栈，然后向左节点移动，如果为空，说明左节点为空，那么弹出栈顶元素，此时栈顶元素一定是该节点的根节点，添加根节点值，然后左子树遍历结束，遍历右子树。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> list;        Stack&lt;TreeNode&gt; stack=<span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">while</span>(!stack.empty() || root!=<span class="hljs-keyword">null</span>) <span class="hljs-comment">//如果栈不为空，或者结点不为空，条件就为true</span>        &#123;            <span class="hljs-keyword">if</span>(root!=<span class="hljs-keyword">null</span>)            &#123;                stack.push(root);                root=root.left;            &#125;            <span class="hljs-keyword">else</span>            &#123;                root=stack.pop();                list.add(root.val);                root=root.right;            &#125;        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode145-二叉树后序遍历</title>
    <link href="/2020/06/10/LeetCode145-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/06/10/LeetCode145-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode145-二叉树后续遍历"><a href="#LeetCode145-二叉树后续遍历" class="headerlink" title="LeetCode145 二叉树后续遍历"></a>LeetCode145 二叉树后续遍历</h1><p>后续遍历的顺序是：左节点–&gt;右节点–&gt;根节点，根节点最后一个遍历，套用一下模板即可</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; list;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        dfs(root);        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        dfs(node.left);        dfs(node.right);        list.add(node.val);    &#125;&#125;</code></pre><h2 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h2><p>思路有点巧妙，利用了栈+LinkedList的addFirst函数</p><p>使用栈按照根左右的顺序依次放入结点，先放入根节点，再放入左节点和右节点，每次pop出的元素，都插入到list的队首，实现了后序遍历。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        Stack&lt;TreeNode&gt; stack=<span class="hljs-keyword">new</span> Stack&lt;&gt;();<span class="hljs-comment">//使用栈的先进后出的特性</span>        LinkedList&lt;Integer&gt; list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> list;        stack.push(root);        <span class="hljs-keyword">while</span>(!stack.empty())        &#123;            TreeNode temp=stack.pop();<span class="hljs-comment">//弹出栈顶元素</span>            list.addFirst(temp.val);<span class="hljs-comment">//向list头插入元素</span>            <span class="hljs-keyword">if</span>(temp.left!=<span class="hljs-keyword">null</span>) stack.push(temp.left);<span class="hljs-comment">//插入左节点</span>            <span class="hljs-keyword">if</span>(temp.right!=<span class="hljs-keyword">null</span>) stack.push(temp.right);<span class="hljs-comment">//插入右节点</span>        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树遍历模板</title>
    <link href="/2020/06/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/"/>
    <url>/2020/06/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树遍历模板"><a href="#二叉树遍历模板" class="headerlink" title="二叉树遍历模板"></a>二叉树遍历模板</h1><p>模板来源于@labuladong</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-comment">// 前序遍历</span>    traverse(root.left)    <span class="hljs-comment">// 中序遍历</span>    traverse(root.right)    <span class="hljs-comment">// 后序遍历</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode106-从中序和后序遍历序列中构建二叉树</title>
    <link href="/2020/06/10/LeetCode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/06/10/LeetCode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode106-从中序和后序遍历序列中构建二叉树"><a href="#LeetCode106-从中序和后序遍历序列中构建二叉树" class="headerlink" title="LeetCode106 从中序和后序遍历序列中构建二叉树"></a>LeetCode106 从中序和后序遍历序列中构建二叉树</h1><p>先从后序遍历中得到根节点，得到根节点在中序遍历中的位置index，中序遍历序列中index左边的就是左子树，右边的就是右子树，然后递归求解左右子树即可<br><strong>难点</strong>：如何计算下一次后序遍历左子树根节点的位置（后序遍历根节点的下标-中序遍历根节点右边的子节点数量=下一次迭代的后序遍历根节点位置）<br>中序+后序构建二叉树：难点是计算左子树的位置。因为后序根节点的位置-1就是右子树的位置<br>中序+先序构建二叉树：难点是计算右子树的位置，因为先序根节点的位置+1就是左子树的位置。<br>当然这两种情况都要判断边界</p><p>java代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;        HashMap&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">int</span> length=postorder.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)        &#123;            map.put(inorder[i],i);        &#125;        <span class="hljs-keyword">return</span> help(inorder,postorder,<span class="hljs-number">0</span>,length-<span class="hljs-number">1</span>,length-<span class="hljs-number">1</span>,map);    &#125;    <span class="hljs-function">TreeNode <span class="hljs-title">help</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder, <span class="hljs-keyword">int</span> inStart, <span class="hljs-keyword">int</span> inEnd, <span class="hljs-keyword">int</span> postEnd, HashMap&lt;Integer,Integer&gt; map)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(postEnd&lt;<span class="hljs-number">0</span> || inStart&gt;inEnd) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> index=map.get(postorder[postEnd]);        TreeNode node=<span class="hljs-keyword">new</span> TreeNode(postorder[postEnd]);        node.left=help(inorder,postorder,inStart,index-<span class="hljs-number">1</span>,postEnd-(inEnd-index)-<span class="hljs-number">1</span>,map);        node.right=help(inorder,postorder,index+<span class="hljs-number">1</span>,inEnd,postEnd-<span class="hljs-number">1</span>,map);        <span class="hljs-keyword">return</span> node;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode105-从前序和中序遍历序列中构建二叉树</title>
    <link href="/2020/06/10/LeetCode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/06/10/LeetCode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode105-从前序和中序遍历中构建二叉树"><a href="#LeetCode105-从前序和中序遍历中构建二叉树" class="headerlink" title="LeetCode105 从前序和中序遍历中构建二叉树"></a>LeetCode105 从前序和中序遍历中构建二叉树</h1><p>前序遍历的顺序是：根结点–&gt;左节点–&gt;右节点</p><p>中序遍历的顺序是：左节点–&gt;根节点–&gt;右节点</p><p>后序遍历的顺序是：左节点–&gt;右节点–&gt;根节点</p><p>构建二叉树的核心是先确定根节点，题目给了前序遍历和中序遍历，想到前序遍历的第一个节点是根节点，所以可以从前序遍历中确认根节点root，然后去中序遍历中找到根节点的位置index，那么在中序遍历index左边的就是左子树，右边的就是右子树，然后再递归求解左右子树，便可成功构建二叉树</p><p>Java代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;        HashMap&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">int</span> length=postorder.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)        &#123;            map.put(inorder[i],i);        &#125;        <span class="hljs-keyword">return</span> help(inorder,postorder,<span class="hljs-number">0</span>,length-<span class="hljs-number">1</span>,length-<span class="hljs-number">1</span>,map);    &#125;    <span class="hljs-function">TreeNode <span class="hljs-title">help</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder, <span class="hljs-keyword">int</span> inStart, <span class="hljs-keyword">int</span> inEnd, <span class="hljs-keyword">int</span> postEnd, HashMap&lt;Integer,Integer&gt; map)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(postEnd&lt;<span class="hljs-number">0</span> || inStart&gt;inEnd) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> index=map.get(postorder[postEnd]);        TreeNode node=<span class="hljs-keyword">new</span> TreeNode(postorder[postEnd]);        node.left=help(inorder,postorder,inStart,index-<span class="hljs-number">1</span>,postEnd-(inEnd-index)-<span class="hljs-number">1</span>,map);        node.right=help(inorder,postorder,index+<span class="hljs-number">1</span>,inEnd,postEnd-<span class="hljs-number">1</span>,map);        <span class="hljs-keyword">return</span> node;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习-1</title>
    <link href="/2020/06/10/Spring%E5%AD%A6%E4%B9%A0-1/"/>
    <url>/2020/06/10/Spring%E5%AD%A6%E4%B9%A0-1/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring学习心得-01"><a href="#Spring学习心得-01" class="headerlink" title="Spring学习心得-01"></a>Spring学习心得-01</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>Spring的核心是IOC和AOP，IOC（Inversion of Control）中文是控制反转。</p><p>了解IOC前要先知道<strong>依赖倒置原则</strong>（Dependency Inversion Principle），即</p><blockquote><p>高层模块不应该依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象</p></blockquote><p>举例来形容一下什么是依赖倒置原则：假设我们要盖楼，先设计好房间，在设计好楼层，再设计好大楼结构。这里的依赖关系是：大楼依赖楼层、楼层依赖房间。假如业主对房间不满意，我们需要修改房间，那就需要修改楼层，修改完楼层，大楼结构也就需要修改。</p><p>那假如反一下呢？</p><p>我先设计好大楼结构，再去设计楼层，然后去设计房间。如果业主对房间不满意，那我只需要修改房间就可以。这样一来，依赖关系就倒置过来了：房间依赖楼层，楼层依赖大楼。这就是依赖倒置原则，把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。</p><p>IOC就是采用了依赖注入（<strong>Dependency Injection</strong>）来实现了依赖倒置原则。</p><p><strong>依赖注入</strong></p><blockquote><p>组件之间依赖关系由<strong>容器在运行期决定,</strong>即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台</p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200610103441.png" srcset="/img/loading.gif" alt="image-20200603115013451"></p><blockquote><p><strong>谁依赖于谁：</strong>当然是应用程序依赖于IoC容器，依赖是指容器负责创建Bean并管理Bean的生命周期；（当类与类之间有使用关系时就属于依赖关系）</p><p><strong>为什么需要依赖：</strong>应用程序需要IoC容器来提供对象需要的外部资源；</p><p><strong>谁注入谁：</strong>容器负责注入Bean的依赖资源，依赖资源可以是Bean、外部文件、常量数据等，在Java中都反映为对象，并且由容器负责组装Bean之间的依赖关系；</p><p><strong>此处的依赖是指**</strong>Bean<strong>**之间的依赖关系</strong>，<strong>可以认为是传统类与类之间的“关联”、“聚合”、“组合”关系</strong>。</p><p>为什么要应用依赖注入？</p><p> <strong>动态替换Bean</strong>依赖对象，程序更灵活：替换Bean依赖对象，无需修改源文件：应用依赖注入后，由于可以采用配置文件方式实现，从而能随时动态的替换Bean的依赖对象，无需修改java源文件；</p><p><strong>更好实践面向接口编程，代码更清晰：</strong>在Bean中只需指定依赖对象的接口，接口定义依赖对象完成的功能，通过容器注入依赖实现；</p><p><strong>更好实践优先使用对象组合，而不是类继承：</strong>因为IoC容器采用注入依赖，也就是<strong>组合对象</strong>，从而更好的实践对象组合。</p><p> 对象组合：Bean的功能由几个依赖Bean功能组合而成，组合具有动态性，可以方便的替换掉依赖Bean，从而改变Bean功能，而且增加了代码的复用性，降低了耦合性</p><p>来自参考资料1</p></blockquote><p>所以IOC就是不需要程序员自己去创建和维护对象，把创建对象的权利交给Spring，由Spring来管理维护对象。</p><p>控制反转这个词再细说一下：</p><p>控制：传统的Java开发都是程序员自己去new对象，程序员控制对象的创建，而IOC是由IOC容器去创建对象，由IOC控制对象的创建，IOC控制了外部资源的获取。</p><p>反转：一般的开发是程序员自己去获取依赖对象，而IOC是由容器来查找并注入依赖对象，对象只是被动的接受依赖对象</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603143635.png" srcset="/img/loading.gif" alt=""></p><p>IOC出现后：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603143654.png" srcset="/img/loading.gif" alt="image-20200603143649919"></p><blockquote><p><strong>谁控制谁，控制什么：</strong>传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</p><p><strong>为何是反转，哪些方面反转了：</strong>有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。（来自参考资料1）</p></blockquote><p>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603113111.jpg" srcset="/img/loading.gif" alt="img"></p><h4 id="依赖资源注入方式"><a href="#依赖资源注入方式" class="headerlink" title="依赖资源注入方式"></a>依赖资源注入方式</h4><p>依赖：bean对象的创建依赖于容器</p><p>注入：bean对象中的所有属性，由容器来注入</p><p>xml文件的基本约束代码</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">&gt;</span>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;xsi:schemaLocation="http://www.springframework.org/schema/beans  https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>   <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>  <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-comment">&lt;!-- more bean definitions go here --&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></blockquote><h5 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h5><p>容器实例化Bean时注入那些依赖，通过在在Bean定义中指定构造器参数进行注入依赖，构造器参数就是依赖。</p><p>注入方式：构造器方式、静态工厂、实例工厂</p><p>构造器注入(代码来自参考资料1)：</p><blockquote><p>1 根据参数索引注入</p><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello"</span> /&gt;</span>&gt;索引下标从0开始</code></pre><p>2 根据参数类型注入</p><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"java.lang.String"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello"</span> /&gt;</span>&gt;参数类型必须是全限定类名</code></pre><p>3 根据参数名称注入</p><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"15"</span> /&gt;</span>&gt;name表示需要匹配的参数名字</code></pre><p>使用方式：生成IOC容器，调用容器的getBean(下标/参数类型/参数名称,字节码)</p></blockquote><p>静态工厂注入</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byIndex"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定类名"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byType"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定类名"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"java.lang.String"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"2"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byName"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定类名"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"index"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>实例工厂注入</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"instanceFactory"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定类名"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byIndex"</span>  <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"instanceFactory"</span>  <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byType"</span>  <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"instanceFactory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"java.lang.String"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"2"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byName"</span>  <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"instanceFactory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"index"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注：静态工厂方式和实例工厂方式区别是实例工厂需要创建实例，然后通过实例调用方法返回bean</p><h5 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h5><p>setter注入，是通过在通过构造器、静态工厂或实例工厂实例好Bean后，通过调用Bean类的setter方法进行注入依赖，原类中要有getter()和setter()方法</p><p>setter注入方式</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"XX"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"要注入的值"</span>&gt;</span> 使用property标签，setXX(),name那里填写XX。如setName,那里就写Name&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"XX"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanid"</span>&gt;</span>：注入引用类型</code></pre><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.javass.spring.chapter3.HelloImpl4"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"index"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注入常量</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello"</span>/&gt;</span></code></pre></blockquote><p>JavaBean本质就是一个POJO类，该类有以下限制：</p><blockquote><p><strong>有公共的无参构造器</strong></p><p><strong>属性为private访问级别</strong></p><p><strong>有getter和setter方法</strong></p></blockquote><h5 id="注入集合、数组和Map"><a href="#注入集合、数组和Map" class="headerlink" title="注入集合、数组和Map"></a>注入集合、数组和Map</h5><p>注入集合（List，Set）</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--注入List，使用list标签--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"listBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定名"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据名称来决定注入类中哪个list--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">list</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">"java.lang.String"</span>&gt;</span>  <span class="hljs-comment">&lt;!--value-type是list集合内的元素类型，默认是String，格式是全限定名--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--注入set，使用set标签--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"setBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定名"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据名称来决定注入类中哪个set--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">"java.lang.String"</span>&gt;</span>  <span class="hljs-comment">&lt;!--value-type是set集合内的元素类型，默认是String，格式是全限定名--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注入数组</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--使用array标签--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"arrayBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定名"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据名称来决定注入类中哪个array--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">array</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">"java.lang.String"</span>&gt;</span>  <span class="hljs-comment">&lt;!--value-type是set集合内的元素类型，默认是String，格式是全限定名--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注入Map</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--使用map标签--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"arrayBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定名"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据名称来决定注入类中哪个Map--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">key-type</span>=<span class="hljs-string">"全限定名"</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">"全限定名"</span>&gt;</span><span class="hljs-comment">&lt;!--默认是String类型--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">""</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">""</span>/&gt;</span><span class="hljs-comment">&lt;!--key和value是你想注入的键值对--&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注入Properties</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--使用props标签，注入java.util.Properties类型数据，键和值必须都是Srring类型数据--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"arrayBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定名"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据名称来决定注入中哪个Properties--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">props</span> <span class="hljs-attr">key-type</span>=<span class="hljs-string">"全限定名"</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">"全限定名"</span>&gt;</span><span class="hljs-comment">&lt;!--String类型--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">""</span>&gt;</span>"value值"<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注入空值</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">""</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre></blockquote><p>注入其他Bean</p><blockquote><p>构造器注入</p><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--使用constructor-arg标签的ref属性来引用其他Bean--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">""</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanid"</span>/&gt;</span>&gt;<span class="hljs-comment">&lt;!--使用constructor-arg标签的子&lt;ref&gt;标签来引用其他Bean--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">""</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"beanid"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span></code></pre><p><strong>setter</strong>注入</p><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--第一种方式--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanid"</span>/&gt;</span>&gt;<span class="hljs-comment">&lt;!--第二种方式--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"beanid"</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre></blockquote><h5 id="P命名空间注入"><a href="#P命名空间注入" class="headerlink" title="P命名空间注入"></a><strong>P命名空间注入</strong></h5><blockquote><p>P就是propertity的缩写</p><p>P命名空间对应所有的属性注入</p><p>添加配置文件约束代码：xmlns:p=”<a href="http://www.springframework.org/schema/p&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/p&quot;</a></p><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"p-namespace"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.ExampleBean"</span></span><span class="hljs-tag">  <span class="hljs-attr">p:email</span>=<span class="hljs-string">"someone@somewhere.com"</span>/&gt;</span></code></pre></blockquote><h5 id="C命名空间注入"><a href="#C命名空间注入" class="headerlink" title="C命名空间注入"></a><strong>C命名空间注入</strong></h5><blockquote><p>c：就是constrctor-arg的缩写</p><p>c命名空间对应构造器注入</p><p>添加约束代码：xmlns:c=”<a href="http://www.springframework.org/schema/c&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/c&quot;</a></p><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--原来是这样实现构造器注入--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingOne"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"thingTwo"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanTwo"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"thingThree"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanThree"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"email"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"something@somewhere.com"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-comment">&lt;!--c命名空间出来以后是这样实现的--&gt;</span>&gt;<span class="hljs-comment">&lt;!-- c-namespace declaration with argument names --&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingOne"</span> <span class="hljs-attr">c:thingTwo-ref</span>=<span class="hljs-string">"beanTwo"</span></span><span class="hljs-tag">  <span class="hljs-attr">c:thingThree-ref</span>=<span class="hljs-string">"beanThree"</span> <span class="hljs-attr">c:email</span>=<span class="hljs-string">"something@somewhere.com"</span>/&gt;</span></code></pre></blockquote><p>内部Bean</p><blockquote><p>内部Bean就是在<property>或<constructor-arg>内通过<bean>标签定义的Bean，该Bean不管是否指定id或name，该Bean都会有唯一的匿名标识符，而且不能指定别名，该内部Bean对其他外部Bean不可见</p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603113111.jpg" srcset="/img/loading.gif" alt="img"></p><h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><blockquote><p>Spring提供“singleton”和“prototype”两种基本作用域，另外提供“request”、“session”、“global session”三种web作用域；</p></blockquote><p><strong>singleton</strong>（默认）</p><blockquote><p>指“singleton”作用域的Bean只会在每个Spring IoC容器中存在一个实例，而且其完整生命周期完全由Spring容器管理。对于所有获取该Bean的操作Spring容器将只返回同一个Bean。</p><p>Spring是注册表单例设计模式的实现，消除了编程式单例，而且对代码是非入侵式。</p><p>Spring不仅会缓存单例对象，Bean定义也是会缓存的，对于惰性初始化的对象是在首次使用时根据Bean定义创建并存放于单例缓存池。</p><p>注册表单例设计模式：先将需要单例的实例通过唯一键注册到注册表，然后通过键来获取单例</p><p>注意：Spring中单例模式指的是这种类型的bean在同一个容器中只存在一个共享实例，而GoF的单例模式指的是一个类加载器中只存在一个这种类型的实例</p></blockquote><p><strong>prototype</strong></p><blockquote><p>原型，指每次向Spring容器请求获取Bean都返回一个全新的Bean，相对于“singleton”来说就是不缓存Bean，每次都是一个根据Bean定义创建的全新Bean。</p><p>Spring不会缓存原型对象，而是根据Bean定义每次请求返回一个全新的Bean：</p><p>Spring中的原型和GoF中介绍的原型含义是不一样的：</p><p>GoF通过用原型实例指定创建对象的种类，而Spring容器用Bean定义指定创建对象的种类；</p><p>GoF通过拷贝这些原型创建新的对象，而Spring容器根据Bean定义创建新对象。</p><p>其相同地方都是根据某些东西创建新东西，而且GoF原型必须显示实现克隆操作，属于侵入式，而Spring容器只需配置即可，属于非侵入式。</p></blockquote><p><strong>Web应用中的作用域</strong></p><blockquote><p>在Web应用中，我们可能需要将数据存储到request、session、global session。因此Spring提供了三种Web作用域：request、session、globalSession。</p><p><strong>request</strong>作用域：表示每个请求需要容器创建一个全新Bean</p><p><strong>session</strong>作用域：表示每个会话需要容器创建一个全新Bean</p><p><strong>globalSession</strong>：类似于session作用域，只是其用于portlet环境的web应用</p></blockquote><h4 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h4><p>之前在xml中Bean的配置都是手动装配，</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cat"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>   <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">""</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"cat"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>自动装配</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">"byName"</span>&gt;</span><span class="hljs-comment">&lt;!--byName会自动查找，和自己对象set方法后面对应的bean，弊端是名字相同会报错--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">"byType"</span>&gt;</span><span class="hljs-comment">&lt;!--byName会自动查找，和自己对象属性类型相同的bean，弊端类型相同会报错--&gt;</span></code></pre><p>byName需要保证所有bean的id唯一，并且需要保证和注入的set属性的方法值相同</p><p>byType是需要保证所有bean的类型唯一，并且需要保证和注入的set属性的类型相同</p></blockquote><h4 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h4><p>使用注解需要加入一些支持</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">&gt;</span>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;xmlns:context="http://www.springframework.org/schema/context"&gt;xsi:schemaLocation="http://www.springframework.org/schema/beans  https://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  https://www.springframework.org/schema/context/spring-context.xsd"&gt;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></blockquote><p>使用了注解@Autowired：原来xml文件可以写成</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"XX"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">""</span>&gt;</span></code></pre><p>在java对应的类中加入注解@Autowired</p><p>@Autowired：可以直接在属性、set方法上使用。</p><p>使用@Autowired，可以不写set方法，@Autowired是通过byType来实现的，所以需要你这个属性在IOC容器中存在</p><p>@Autowired注解，默认是true，意思是不允许为null，如果修改为@Autowired(required=false)，意思是可以为null</p><p>如果有多个Bean对象时，Autowired通过byType都无法找到应该装配哪一个，需要搭配@Qualifier注解一起使用</p></blockquote><p>@Resource注解</p><blockquote><p>@Autowired是通过byType实现的</p><p>@Resource是通过byName/byType实现的，默认是byName，如果找不到就通过byType实现。</p><p>@Resource比@Autowired更强大</p></blockquote><p>@component注解：组件组件，搭配@V alue使用</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"XX.XX"</span>&gt;</span><span class="hljs-comment">&lt;!--意思是会扫描XX.XX包下的所有组件--&gt;</span></code></pre><p>衍生注解：@Repository，@Service，@Controller，都是组件的意思</p><p>加上这些注解就表示这个类要被spring托管了，是Spring的一个组件了</p><p>这四个注解功能都是一样的，意思都是将某个类注册到Spring容器中，然后装配</p></blockquote><p><strong>xml用来管理bean，注解负责完成属性的注入</strong></p><h4 id="使用Java配置注解开发"><a href="#使用Java配置注解开发" class="headerlink" title="使用Java配置注解开发"></a>使用Java配置注解开发</h4><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200609183446.png" srcset="/img/loading.gif" alt="image-20200609183441950"></p><blockquote><p>@Configuration：表示这个类是一个配置类</p><p>注意如果使用了配置类，那么只能通过AnnotationConfig上下文获取IOC容器</p><pre><code class="hljs java">&gt;ApplicationContext context=<span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(xx<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&gt;User getUser=(User)context.getBean(<span class="hljs-string">"getUser"</span>);&gt;sout(getUser.getName);</code></pre></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603113111.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP：Aspect Oriented Programming，面向切面编程，核心原理是使用动态代理模式在方法执行前后或者出现异常时添加相关逻辑</p><p>AOP一般被用来解决一些系统交叉业务的织入，比如日志啦、事务。</p><p>比如我想在方法1、2、3中添加一个打印日志功能，那我就需要去修改方法1、2、3中的代码，添加日志功能。但这违法了设计原则中开闭原则（扩展开发，修改关闭）。</p><p>那怎么办？简单点，写一个子类，在子类中重写这三个方法，那假如方法要是多呢？都一个个重写？</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603120706.png" srcset="/img/loading.gif" alt="image-20200603120703141"></p><p>那能不能让这些方法在执行前（或者执行后）统一调用一个代码呢？如下图</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603121316.png" srcset="/img/loading.gif" alt=""></p><p>我们原来是在方法内部添加打印日志功能，AOP是在执行方法前添加日志功能（交叉业务），原因是AOP的底层是使用了动态代理技术，动态代理调用了原方法，AOP只不过是在在原方法的基础上新创建了一个方法，然后在新方法的内部添加功能，添加的功能代码也称之为增强代码。如下图</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603121649.png" srcset="/img/loading.gif" alt="image-20200603121645266"></p><p>AOP通过动态代理实现的，动态代理是在<strong>运行期间</strong>，生成一个代理对象</p><blockquote><p>静态代理是用户自己写代理对象，比如继承一个类，重写这个类中的方法</p><p>动态代理是在程序运行期，生成一个代理对象</p></blockquote><p>Spring AOP的动态代理，有分成两种：基于接口的动态代理和基于类的动态代理</p><p>基于接口的动态代理：如果要代理的对象，继承了某个接口，那么Spring AOP就会使用JDK Proxy创建代理对象</p><p>基于类的动态代理：如果要代理的对象没有继承接口，那么Spring AOP就会使用Cglib，生成一个被代理对象的子类，作为代理</p><h4 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h4><p>Advice（通知/增强）：就是你想要新增加的功能，比如打印日志。<strong>“干什么”</strong></p><p>Aspect（切面）：切面是通知和切点的结合。<strong>”在哪干和干什么集合“</strong></p><p>Joint point（连接点）：Spring允许使用Advice的地方，比如方法的前后，抛出异常，都可以是连接点。<strong>”在哪干“</strong></p><p>Pointcut（切点）：不是类中所有的方法都需要新增加一些功能，把需要新增加功能的方法集合起来就是切点，可以理解为连接点的集合。<strong>“在哪干的集合”</strong></p><p>introduction（引入）：允许我们向现有的类添加新方法属性，就是把切面用到了目标类中。“<strong>干什么</strong>”</p><p>Target（目标对象）：引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。“<strong>对谁干</strong>”</p><p>Weaving（织入）：把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时进行织入</p><h4 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h4><blockquote><ul><li><strong>前置通知（Before Advice</strong>）:在切入点选择的连接点处的方法之前执行的通知，该通知不影响正常程序执行流程（除非该通知抛出异常，该异常将中断当前方法链的执行而返回）。</li><li><strong>后置通知（After Advice</strong>）:在切入点选择的连接点处的方法之后执行的通知，包括如下类型的后置通知：</li><li><strong>后置返回通知（After returning Advice</strong>）:在切入点选择的连接点处的方法正常执行完毕时执行的通知，必须是连接点处的方法没抛出任何异常正常返回时才调用后置通知。</li><li><strong>后置异常通知（After throwing Advice）</strong>: 在切入点选择的连接点处的方法抛出异常返回时执行的通知，必须是连接点处的方法抛出任何异常返回时才调用异常通知。</li><li><strong>后置最终通知（After finally Advice</strong>）: 在切入点选择的连接点处的方法返回时执行的通知，不管抛没抛出异常都执行，类似于Java中的finally块。</li><li><strong>环绕通知（Around Advices**</strong>）：环绕着在切入点选择的连接点处的方法所执行的通知，环绕通知可以在方法调用之前和之后自定义任何行为，并且可以决定是否执行连接点处的方法、替换返回值、抛出异常等等。</li></ul></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603185338.JPG" srcset="/img/loading.gif" alt="img"></p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>Spring中使用到的设计模式</p><h5 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h5><p>BeanFactory</p><h5 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h5><p>FactoryBean接口</p><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>getSingleton</p><h5 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h5><p>SpringMVC中的适配器HandlerAdatper</p><h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><p>Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator</p><h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><p>AOP底层，就是动态代理模式的实现</p><h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><p>spring的事件驱动模型使用的是 观察者模式 ，Spring中Observer模式常用的地方是listener的实现</p><h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><p>Spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了 Resource 接口来访问底层资源。</p><h5 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h5><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>Spring IOC</p><p><a href="https://www.iteye.com/category/206533?page=2" target="_blank" rel="noopener">https://www.iteye.com/category/206533?page=2</a> （这个系列都是精华）</p><p>Spring AOP术语理解：<a href="https://blog.csdn.net/changudeng1992/article/details/80625134" target="_blank" rel="noopener">https://blog.csdn.net/changudeng1992/article/details/80625134</a></p>]]></content>
    
    
    <categories>
      
      <category>SSM</category>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
