<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>观察者模式</title>
    <link href="/2020/06/15/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/15/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式，<strong>行为型模式</strong>关注的是<strong>对象之间的通讯</strong>，观察者模式就是<strong>观察者和被观察者</strong>之间的通讯</p><p>举个例子：老师在办公室改作业，学生晚自习在教室玩手机、说话、打闹等，在这个过程中，学生要不断观察老师来没来，学生就是观察者，老师就是被观察者。如果老师改完作业来自习室，状态发生了变更，就需要通知每一个学生，让他们停止玩耍，好好学习。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>一个观察者模式包含有两大类：主题和观察者</p><p>主题：主题是观察者观测的对象。主题又可以分成抽象主题和具体主题</p><blockquote><p>抽象主题：把所有对观察者对象的引用保存在一个集合里面，抽象主题提供一个借口，可以增加和删除观察对象。</p><p>​    比如上面例子，学生一直不学习玩耍，老师就可以让学生出去，别影响其他人</p><p>具体主题：该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知</p><p>​    比如：老师来到教室门口，就需要通知学生学习</p></blockquote><blockquote><p>特征：</p><p>持有监听的观察者的引用</p><p>支持增加和删除观察者</p><p>主题状态改变，通知观察者</p></blockquote><p>观察者：不断监听主题，当主题发生变化时，进行相应处理操作。观察者又可以分成抽象观察者和具体观察者</p><blockquote><p>抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。这就是我们所有学生的抽象。</p><p>具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。每一个具体的学生</p></blockquote><p>以学生和老师为例</p><pre><code class="hljs java"><span class="hljs-comment">//抽象主题</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Teacher</span> </span>&#123;    <span class="hljs-comment">//让学生出去</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(Student student)</span></span>;    <span class="hljs-comment">//让学生进来</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteStudent</span><span class="hljs-params">(Student student)</span></span>;    <span class="hljs-comment">//通知学生老师来了</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyStudent</span><span class="hljs-params">(String msg)</span></span>;&#125;<span class="hljs-comment">//具体主题</span><span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteTeacher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Teacher</span></span>&#123;    <span class="hljs-keyword">private</span> List&lt;Student&gt; list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(Student student)</span> </span>&#123;        list.add(student);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteStudent</span><span class="hljs-params">(Student student)</span> </span>&#123;        list.remove(student);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyStudent</span><span class="hljs-params">(String msg)</span> </span>&#123;        <span class="hljs-keyword">for</span> (Student s:list)            s.update(msg);    &#125;&#125;<span class="hljs-comment">//抽象观察者---学生</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(String msg)</span></span>;&#125;<span class="hljs-comment">//具体观察者---学生</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStudent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Student</span></span>&#123;    String stuName;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteStudent</span><span class="hljs-params">(String stuName)</span> </span>&#123;        <span class="hljs-keyword">this</span>.stuName = stuName;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(String msg)</span> </span>&#123;        System.out.println(stuName+<span class="hljs-string">"知道"</span>+msg+<span class="hljs-string">"老师来了"</span>);    &#125;&#125;<span class="hljs-comment">//测试</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Student s1=<span class="hljs-keyword">new</span> ConcreteStudent(<span class="hljs-string">"z3"</span>);<span class="hljs-comment">//生成学生</span>        Student s2=<span class="hljs-keyword">new</span> ConcreteStudent(<span class="hljs-string">"l4"</span>);        Student s3=<span class="hljs-keyword">new</span> ConcreteStudent(<span class="hljs-string">"w5"</span>);        Teacher t=<span class="hljs-keyword">new</span> ConcreteTeacher();        t.addStudent(s1);<span class="hljs-comment">//添加学生到老师管理的列表中</span>        t.addStudent(s2);        t.addStudent(s3);        t.notifyStudent(<span class="hljs-string">"老师"</span>);<span class="hljs-comment">//老师状态变更，需要通知学生老师来了</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>行为型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/2020/06/15/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/15/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略末班把算法实现和算法使用分离开，让它们之间可以相互替换。策略模式让算法的变换，不会影响到用户。举个例子：某商场促销，有的物品打五折，有的打七折。打几折是算法的实现，不同的物品使用不同的算法，对于收银员来说，他不需要在意具体打几折，只需要输入物品号，程序就可以给出促销后的价格。</p><p>代码如下</p><pre><code class="hljs java"><span class="hljs-comment">//策略的抽象接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Strategy</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//具体策略----A</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Strategy</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"策略A"</span>);    &#125;&#125;<span class="hljs-comment">//具体策略----B</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Strategy</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"策略B"</span>);    &#125;&#125;<span class="hljs-comment">//使用一个context来维护上下文</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;    Strategy strategy;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span><span class="hljs-params">(Strategy strategy)</span> </span>&#123;<span class="hljs-comment">//根据传入的策略来决定调用的策略</span>        <span class="hljs-keyword">this</span>.strategy = strategy;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        strategy.algorithm();    &#125;&#125;<span class="hljs-comment">//测试</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Context contextA=<span class="hljs-keyword">new</span> Context(<span class="hljs-keyword">new</span> ConcreteStrategyA());<span class="hljs-comment">//传入策略A，可以传入不同的策略</span>    contextA.function();    Context contextB=<span class="hljs-keyword">new</span> Context(<span class="hljs-keyword">new</span> ConcreteStrategyB());<span class="hljs-comment">//传入策略B</span>    contextB.function();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>行为型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式</title>
    <link href="/2020/06/15/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/15/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p><strong>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法在一起工作的两个类能够在一起工作</strong></p><p>模式要素：目标接口、适配器、原接口</p><p>举个例子：电脑只有一个USB接口，需要使用适配器把网线转换成USB接口，这样才可以让电脑上网。如下图</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200615100125.png" srcset="/img/loading.gif" alt="image-20200615100116263"></p> <pre><code class="hljs java"><span class="hljs-comment">//目标是把网线接口转成USB接口</span><span class="hljs-comment">//原接口就是网线：</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetLine</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">"连接网线上网"</span>);    &#125;&#125;<span class="hljs-comment">//接口转换器的抽象实现</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">NetToUsb</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//转换器的实现类适配器，一个连接网线，一个连接电脑</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NetLine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">NetToUsb</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.function();    &#125;&#125;<span class="hljs-comment">//上网</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">net</span><span class="hljs-params">(NetToUsb adapter)</span></span><span class="hljs-function">    </span>&#123;        adapter.handle();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Computer computer=<span class="hljs-keyword">new</span> Computer();        Adapter adapter=<span class="hljs-keyword">new</span> Adapter();        computer.net(adapter);    &#125;&#125;</code></pre><p>优化：少继承，多组合</p><pre><code class="hljs java"><span class="hljs-comment">//使用组合</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdapterImpl</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">Adapter</span></span>&#123;    NetLine netLine;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AdapterImpl</span><span class="hljs-params">(NetLine netLine)</span> </span>&#123;        <span class="hljs-keyword">this</span>.netLine = netLine;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;        netLine.function();    &#125;&#125;<span class="hljs-comment">//测试</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Computer computer=<span class="hljs-keyword">new</span> Computer();    NetLine netLine=<span class="hljs-keyword">new</span> NetLine();<span class="hljs-comment">//网线</span>    AdapterImpl adapter=<span class="hljs-keyword">new</span> AdapterImpl(netLine);<span class="hljs-comment">//传入网线</span>    computer.net(adapter);&#125;</code></pre><p>代码来自@狂神</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>结构型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora图床</title>
    <link href="/2020/06/14/Typora%E5%9B%BE%E5%BA%8A/"/>
    <url>/2020/06/14/Typora%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="使用PicGO-Gitee搭建Typora图床"><a href="#使用PicGO-Gitee搭建Typora图床" class="headerlink" title="使用PicGO+Gitee搭建Typora图床"></a>使用PicGO+Gitee搭建Typora图床</h1><h2 id="码云"><a href="#码云" class="headerlink" title="码云"></a>码云</h2><p>首先在码云里面新建一个仓库，用来存储图片。步骤如下：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200526161531.png" srcset="/img/loading.gif" alt="image-20200526161529013"></p><p>获取你的token，后面要用：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200526162407.png" srcset="/img/loading.gif" alt="image-20200526162403325"></p><p>点击生成新令牌</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200526162438.png" srcset="/img/loading.gif" alt="image-20200526162436032"></p><p>进入私人令牌页面，选择projects这个选项，最后点击提交。私人令牌描述那里随便写，如图床、博客图片等都可以。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200526162554.png" srcset="/img/loading.gif" alt="image-20200526162550942"></p><h2 id="Typora配置"><a href="#Typora配置" class="headerlink" title="Typora配置"></a>Typora配置</h2><p>打开typora的偏好设置，配置PicGo：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200526163202.png" srcset="/img/loading.gif" alt=""></p><p>2执行完后去执行3。找到安装路径。下图标出的就是安装路径</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200526163010.png" srcset="/img/loading.gif" alt="image-20200526163008740"></p><p>打开cmd进入安装路径，并执行安装插件</p><blockquote><p>cd C:\Users\jaymie\AppData\Roaming\Typora\picgo\win64<br>.\picgo.exe install smms-user<br>.\picgo.exe install gitee-uploader<br>.\picgo.exe install github-plus</p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200526163114.png" srcset="/img/loading.gif" alt="image-20200526163111906"></p><p>再去执行4</p><p>配置文件设置如下：</p><pre><code class="hljs xml">&#123;  "picBed": &#123;    "uploader": "gitee", //    "gitee": &#123;      "repo": "", // 用户名/仓库名      "token": "",// 写你的token      "path": ", // 路径如：img/"      "customUrl": "", //      "branch": "" //    &#125;  &#125;,  "picgoPlugins": &#123;    "picgo-plugin-gitee-uploader": true,    "picgo-plugin-super-prefix": true,    "picgo-plugin-github-plus": true  &#125;,  "picgo-plugin-super-prefix": &#123;    "fileFormat": "YYYYMMDDHHmmss"  &#125;,  "picgo-plugin-gitee-uploader": &#123;    "lastSync": "2020-05-26 04:19:31"  &#125;&#125;</code></pre><p>保存设置，然后再执行3，当出现下图的成功上传图片并获得新的URL时，设置成功</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200526163407.png" srcset="/img/loading.gif" alt="image-20200526163404906"></p><p>以后复制图片到Typora会出现下面的<strong>上传图片</strong>，就可以上传图片到你的码云仓库中去了。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614170057763.png" srcset="/img/loading.gif" alt="image-20200614170057763"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode438-找到字符串中所有字母异位词</title>
    <link href="/2020/06/14/LeetCode438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <url>/2020/06/14/LeetCode438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode438-找到字符串中所有字母异位词"><a href="#LeetCode438-找到字符串中所有字母异位词" class="headerlink" title="LeetCode438-找到字符串中所有字母异位词"></a>LeetCode438-找到字符串中所有字母异位词</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入:</span><span class="hljs-meta">&gt;</span><span class="bash">s: <span class="hljs-string">"abab"</span> p: <span class="hljs-string">"ab"</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出:</span><span class="hljs-meta">&gt;</span><span class="bash">[0, 1, 2]</span></code></pre><p><strong>说明：</strong></p><ul><li>字母异位词指字母相同，但排列不同的字符串。</li><li>不考虑答案输出的顺序</li></ul></blockquote><p>注意：相同字母也是异位词，如”ab”也是”ab”的异位词</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>维护一个字符串P长度的滑动窗口，不断移动判断即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(String s, String p)</span> </span>&#123;        <span class="hljs-keyword">int</span> sLen=s.length(),pLen=p.length();        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;        HashMap&lt;Character,Integer&gt; target=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">//目标元素</span>        HashMap&lt;Character,Integer&gt; window=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">//滑动窗口</span>        List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">char</span> f=p.charAt(<span class="hljs-number">0</span>);        <span class="hljs-keyword">int</span> valid=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(Character c:p.toCharArray()) target.put(c,target.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<span class="hljs-comment">//把p中字符都放入到target中</span>        <span class="hljs-keyword">while</span>(right&lt;sLen)        &#123;            <span class="hljs-keyword">char</span> c=s.charAt(right);            right++;            <span class="hljs-keyword">if</span>(target.containsKey(c))<span class="hljs-comment">//判断这个字符在p中是否出现过</span>            &#123;                window.put(c,window.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<span class="hljs-comment">//如果出现过，就放到滑动窗口中</span>                <span class="hljs-keyword">if</span>(target.get(c).equals(window.get(c))) valid++;<span class="hljs-comment">//如果每一个字符在滑动窗口中出现的次数和target中出现的次数相等，就让valid++，这说明了窗口中放入了valid个有效字符</span>            &#125;            <span class="hljs-keyword">if</span>(right-left==pLen)<span class="hljs-comment">//如果窗口大小等于P的长度，那么判断一下，这个窗口中的字符是不是P的异位词</span>            &#123;                <span class="hljs-keyword">char</span> d=s.charAt(left);                <span class="hljs-keyword">if</span>(valid==target.size()) <span class="hljs-comment">//如果valid==target.size()，说明了P中所有字母都放入到window中</span>                &#123;                    list.add(left);                &#125;                <span class="hljs-comment">//无论该窗口中元素是不是P的异位词，下面都需要开始向右移动滑动窗口</span>                <span class="hljs-keyword">if</span>(target.containsKey(d))<span class="hljs-comment">//如果字符d包含在target中</span>                &#123;                    <span class="hljs-keyword">if</span>(target.get(d).equals(window.get(d))) valid--;<span class="hljs-comment">//如果这个字符在target中出现过的次数和window中出现的次数相等，那么向右移动后，window中就少了一个符合要求的字符，valid需要减一</span>                    window.put(d,window.get(d)-<span class="hljs-number">1</span>);<span class="hljs-comment">//窗口向右移动，所以需要把该字符从窗口中移出</span>                &#125;                left++;<span class="hljs-comment">//向右移动</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> list;<span class="hljs-comment">//返回结果集</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>滑动窗口</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode3-无重复字符的最长子串</title>
    <link href="/2020/06/14/LeetCode3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/06/14/LeetCode3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode3-无重复字符的最长子串"><a href="#LeetCode3-无重复字符的最长子串" class="headerlink" title="LeetCode3-无重复字符的最长子串"></a>LeetCode3-无重复字符的最长子串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: <span class="hljs-string">"abcabcbb"</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出: 3 </span><span class="hljs-meta">&gt;</span><span class="bash">解释: 因为无重复字符的最长子串是 <span class="hljs-string">"abc"</span>，所以其长度为 3。</span></code></pre></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>典型的滑动窗口，维护一个滑动窗口[left,right)，同时用一个HashMap记录字符串中字符出现的次数，如果发现有重复字符出现，就移动窗口，直到窗口中没有重复字符为止</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> len=s.length();              <span class="hljs-comment">//if(len==0) return 0;</span>        HashMap&lt;Character,Integer&gt; window=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">//滑动窗口</span>        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> start=<span class="hljs-number">0</span>,end=<span class="hljs-number">0</span>,maxLen=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(right&lt;len)        &#123;            <span class="hljs-keyword">char</span> c=s.charAt(right);            right++;            window.put(c,window.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);            <span class="hljs-keyword">while</span>(window.get(c)&gt;<span class="hljs-number">1</span>)<span class="hljs-comment">//如果窗口中出现了重复元素，就让窗口向右移动</span>            &#123;                <span class="hljs-keyword">char</span> p=s.charAt(left);                left++;                window.put(p,window.get(p)-<span class="hljs-number">1</span>);<span class="hljs-comment">//每移动一次滑动窗口，就移出一个字符</span>            &#125;            <span class="hljs-keyword">if</span>(right-left&gt;maxLen)<span class="hljs-comment">//记录窗口的最大长度</span>                maxLen=right-left;                    &#125;        <span class="hljs-keyword">return</span> maxLen;<span class="hljs-comment">//返回窗口长度值</span>            &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>滑动窗口</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode567-字符串的排列</title>
    <link href="/2020/06/14/LeetCode567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2020/06/14/LeetCode567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode567-字符串的排列"><a href="#LeetCode567-字符串的排列" class="headerlink" title="LeetCode567-字符串的排列"></a>LeetCode567-字符串的排列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定两个字符串 <strong>s1</strong> 和 <strong>s2</strong>，写一个函数来判断 <strong>s2</strong> 是否包含 <strong>s1</strong> 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><pre><code class="hljs armasm">&gt;输入: <span class="hljs-built_in">s1</span> = <span class="hljs-string">"ab"</span> <span class="hljs-built_in">s2</span> = <span class="hljs-string">"eidbaooo"</span>&gt;输出: True&gt;解释: <span class="hljs-built_in">s2</span> 包含 <span class="hljs-built_in">s1</span> 的排列之一 (<span class="hljs-string">"ba"</span>).&gt;输入: <span class="hljs-built_in">s1</span>= <span class="hljs-string">"ab"</span> <span class="hljs-built_in">s2</span> = <span class="hljs-string">"eidboaoo"</span>&gt;输出: False</code></pre></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>维护一个长度为字符串s1长度的滑动窗口，用滑动窗口不断扫描字符串s2，如果窗口内的元素都是s1的元素，说明s2包含字符串s1的一种排列</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;        <span class="hljs-keyword">int</span> sLen1=s1.length(),sLen2=s2.length();        HashMap&lt;Character,Integer&gt; target=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();        HashMap&lt;Character,Integer&gt; window=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span>(Character c:s1.toCharArray()) target.put(c,target.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> valid=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(right&lt;sLen2)<span class="hljs-comment">//这里改成for还是会报错，为啥？？</span>        &#123;            <span class="hljs-keyword">char</span> c=s2.charAt(right);            right++;            <span class="hljs-keyword">if</span>(target.containsKey(c))            &#123;                window.put(c,window.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);                <span class="hljs-keyword">if</span>(target.get(c).equals(window.get(c))) valid++;            &#125;            <span class="hljs-keyword">if</span>(right-left==sLen1)<span class="hljs-comment">//维护长度为字符串s1长度的一个滑动窗口</span>            &#123;                <span class="hljs-keyword">char</span> d=s2.charAt(left);                left++;                <span class="hljs-keyword">if</span>(valid==target.size()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//如果这个窗口内的元素恰好都是s1的元素，说明在字符串s2上找到了s1的一种排列</span>                <span class="hljs-keyword">if</span>(target.containsKey(d))                &#123;                    <span class="hljs-keyword">if</span>(target.get(d).equals(window.get(d))) valid--;                    window.put(d,window.get(d)-<span class="hljs-number">1</span>);                &#125;                                    &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><blockquote><p>while(right&lt;sLen2)改成for循环会报错，为啥呢？</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>滑动窗口</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2020/06/13/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/13/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。代理模式一般由四个角色构成：抽象角色、真实角色、代理角色、客户，而且代理分为静态代理和动态代理</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>假如有一个需求是，给每一个方法都实现一个打印日志功能，你怎么做？</p><p>最暴力：直接修改每一个方法，缺点方法太大，改不过来，容易出错，违法开闭原则</p><p>简单点：为每一个类写一个代理类，让代理类和目标类都实现相同的接口，在创建代理对象时，通过构造器塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法，并在调用前后打印日志。这样以后，就不需要调用目标类生成对象，直接生成代理对象便完成了添加打印日志的功能。</p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//接口实现类---学生</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"name is Student"</span>);    &#125;&#125;<span class="hljs-comment">//接口实现类---老师</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"name is Teacher"</span>);    &#125;&#125;<span class="hljs-comment">//学生代理类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentPerson</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">private</span> Student student;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StudentPerson</span><span class="hljs-params">(Student student)</span> </span>&#123;        <span class="hljs-keyword">this</span>.student = student;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"学生类的代理类打印日志功能"</span>);        student.name();    &#125;&#125;<span class="hljs-comment">//老师代理类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeacherProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">private</span> Teacher teacher;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TeacherProxy</span><span class="hljs-params">(Teacher teacher)</span> </span>&#123;        <span class="hljs-keyword">this</span>.teacher = teacher;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"老师类的代理类实现日志功能"</span>);        teacher.name();    &#125;&#125;</code></pre><p>好处：公共业务交给代理角色，真实角色只需要做自己独有业务即可</p><p>缺点：程序员要<strong>手动</strong>为每一个目标类编写对应的代理类，代码量翻倍。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>静态代理需要程序员自己写代理类，使用new关键字创建对应的代理对象，根据代理对象调用代理方法</p><p>创建对象过程：加载、连接、初始化。（下面回顾一下创建过程，可以跳过）</p><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p><strong>类加载全过程：加载、验证、准备、解析和初始化</strong></p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载阶段，JVM需要做三件事情</p><blockquote><p>通过类的全限定名获取定义此类的二进制字节流</p><p>将这个字节流代表的静态存储结构转化为方法区的运行时数据结构</p><p>内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p></blockquote><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>连接阶段又可以分成：验证、准备和解析三个阶段</p><blockquote><p>验证：确保Class文件额字节流中包含的信息符合约束要求，保证这些信息被当做代码运行后<strong>不会危害JVM的安全</strong></p><p>​    验证又可以分成：文件格式验证、元数据验证、字节码验证和符号引用验证</p><p>准备：准备阶段是为类<strong>中定义的变量分配内存</strong>并设置<strong>类变量初始值</strong>的阶段，<strong>理论上</strong>这些变量使用的内存都应该在<strong>方法区</strong>中进行分配，但是方法区只是一个逻辑概念，JDK7之前，HotSpot使用永久代来实现方法区，JDK8之后，类变量则随着Class对象一起放到Java堆中。</p><p>​    注意：这里为类变量分配初始值，是分配的各个类型的默认值，如0、null等，不是程序员写到程序中的初始值</p><p>解析：将JVM常量池中的符号引用替换为直接引用。</p><p>​        符号引用：符号引用以一组符号来描述引用的目标，可以是任何形式的字面量，只要可以无歧义的定位到目标即可</p><p>​        直接引用：直接引用是可以执行目标的指针、相对偏移量或者是一个能间接定位到目标的句柄</p></blockquote><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的初始化是类加载过程的最后一步。准备阶段，变量已经赋过一次系统要求的初始零值，初始化阶段，则会根据程序员在代码中编写的代码进行相应的初始化</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>对于任意一个类，必须由加载它的类加载器和这个类本身一起确定它在JVM中的唯一性，每一个类加载器，都有一个独立的类名称空间。</p><p>有两种类加载器，一种是启动类加载器（C++实现），一种是其他类加载器（Java实现）。后者全都继承抽象类java,lang.ClassLoader。关系如下图</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200615085250.png" srcset="/img/loading.gif" alt="image-20200615085244972"></p><p>类加载器之间的层次关系被称为双亲委派模型</p><blockquote><p>双亲委派模型：一个类加载器收到类加载请求时，不会自己去尝试加载这个类，而是把这个请求委派给父加载器去完成，每一个层次都是如此，最终会传到启动类加载器，如果负加载器无法完成这个加载请求，自家在其才会尝试自己去加载。</p><p>优点：保证类的全局唯一性，维护了Java程序的稳定运行</p></blockquote><h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3><p>动态代理的目标是不写代理类，而是直接得到代理Class对象，然后根据它来创建代理实例。Class对象包含了一个类的所有信息，比如构造器、方法和成员变量等。而为了获得这些信息，<strong>因为接口拥有目标对象的类信息</strong>，我们需要<strong>让代理类和目标类实现同一组接口，确保代理对象的内部结构和目标对象一致</strong>。</p><p>JDK提供了java.lang.reflect.<strong>InvocationHandler</strong>接口和 java.lang.reflect.<strong>Proxy</strong>类。</p><p>Proxy有个静态方法：<strong>getProxyClass</strong>(ClassLoader, interfaces)，只要你给它传入<strong>类加载器和一组接口，它就给你返回代理Class对象</strong>。getProxyClass()这个方法，会从你传入的接口Class中，“拷贝”类结构信息到一个新的Class对象中，新的Class对象带有构造器，是可以创建对象的。一旦我们明确接口，完全可以<strong>通过接口的Class对象，创建一个代理Class，通过代理Class即可创建代理对象</strong>。</p><p>但一般不用<strong>getProxyClass</strong>方法，而是用Proxy类的另一个静态方法：Proxy.newProxyInstance()，直接返回代理实例。</p><p>根据代理Class的构造器创建对象时，需要传入InvocationHandler。每次调用代理对象的方法，最终都会调用InvocationHandler的invoke()方法：</p><p>动态代理分成基于接口的动态代理（JDK）和基于类的动态代理（CGLib）</p><pre><code class="hljs java"><span class="hljs-comment">//基于接口的动态代理</span><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<span class="hljs-comment">//用来生成代理类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyInvocation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Rent rent;<span class="hljs-comment">//要代理的接口</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Rent <span class="hljs-title">getRent</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> rent;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRent</span><span class="hljs-params">(Rent rent)</span> </span>&#123;        <span class="hljs-keyword">this</span>.rent = rent;    &#125;    <span class="hljs-comment">//生成代理类</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<span class="hljs-keyword">this</span>.getClass().getClassLoader(),rent.getClass().getInterfaces(),<span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-comment">//处理代理实例，并返回结果，这个函数不是显式调用，具体信息目前还不懂</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        Object result = method.invoke(rent, args);        <span class="hljs-keyword">return</span> result;    &#125;&#125;<span class="hljs-comment">//测试</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Host host=<span class="hljs-keyword">new</span> Host();<span class="hljs-comment">//真实角色</span>    ProxyInvocation px=<span class="hljs-keyword">new</span> ProxyInvocation();<span class="hljs-comment">//用来生成代理类</span>    px.setRent(host);<span class="hljs-comment">//传入要代理的接口</span>    Rent proxy =(Rent) px.getProxy();<span class="hljs-comment">//生成代理角色</span>    proxy.rent();&#125;</code></pre><h3 id="基于类的动态代理（待续）"><a href="#基于类的动态代理（待续）" class="headerlink" title="基于类的动态代理（待续）"></a>基于类的动态代理（待续）</h3><p>JDK动态代理的话，他有一个限制，就是它只能为接口创建代理实例，对于没有通过接口定义业务方法的类，需要通过CGLib来创建代理实例</p><h4 id="Enhancer"><a href="#Enhancer" class="headerlink" title="Enhancer"></a>Enhancer</h4><p>Enhancer可能是CGLIB中最常用的一个类，类似于JDK的proxy</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>结构型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建造者模式</title>
    <link href="/2020/06/13/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/13/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式是对象的创建模式，它分离了产品的<strong>内部表现</strong>和产品的<strong>生产过程</strong>，使得一个建造过程可以生产具有不同的内部变现的产品对象。使用建造者模式可以使得用户不需要知道产品的每一个零件的生产过程，零件的生产顺序，以及零件的组装。</p><h2 id="产品的内部表现"><a href="#产品的内部表现" class="headerlink" title="产品的内部表现"></a>产品的内部表现</h2><p>一个产品Product，可能有不同的零件，这些零件叫做产品的内部表现。比如要做饭，要先买菜、洗菜、炒菜等</p><h2 id="零件的生产顺序"><a href="#零件的生产顺序" class="headerlink" title="零件的生产顺序"></a>零件的生产顺序</h2><p>产品之间零件的生产顺序也很重要，类似于做饭的顺序，不可能先炒菜，再买菜。必须按照一定的顺序生产零件，才可以得到有意义的产品。建造者模式就是按照正确顺序实现了零件的生产，返回给用户一个合格的对象</p><p>建造者模式结构组成：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200613103809.png" srcset="/img/loading.gif" alt="image-20200613103805729"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs java"><span class="hljs-comment">//抽象建造者</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Build</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildA</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildB</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildC</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildD</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> Product <span class="hljs-title">getProduct</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//产品</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;    <span class="hljs-comment">//一个产品由A,B,C,D四部分组成</span>    <span class="hljs-keyword">private</span> String productA;    <span class="hljs-keyword">private</span> String productB;    <span class="hljs-keyword">private</span> String productC;    <span class="hljs-keyword">private</span> String productD;    &#125;&#125;<span class="hljs-comment">//创建产品的类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Build</span></span>&#123;    <span class="hljs-keyword">private</span> Product product;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">( )</span> </span>&#123;        product=<span class="hljs-keyword">new</span> Product();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildA</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"AAA"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildB</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"BBB"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildC</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"CCC"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildD</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"DDD"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">Product <span class="hljs-title">getProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> product;    &#125;&#125;<span class="hljs-comment">//指挥者决定建造顺序</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">build</span><span class="hljs-params">(Build build)</span></span>&#123;            build.buildA();            build.buildB();            build.buildC();            build.buildD();            <span class="hljs-keyword">return</span> build.getProduct();    &#125;&#125;<span class="hljs-comment">//主线程测试</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//构建指挥</span>        Director director=<span class="hljs-keyword">new</span> Director();        <span class="hljs-comment">//通过指挥者来建造产品</span>        Product build = director.build(<span class="hljs-keyword">new</span> Worker());        <span class="hljs-comment">//打印产品</span>        build.toString();    &#125;&#125;</code></pre><p>导演类Director在Builder模式中具有重要的意义，复制指导建造者以何种顺序来构建产品，并且返回最终产品。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创建型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式</title>
    <link href="/2020/06/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型模式：顾名思义以某个对象为原型，复制一个新的对象。创建复制对象的时候，可以提高效率</p><p>原型模式主要用于对象的复制，其中原型类也就是被复制的类需要具备两个条件：1实现Cloneable接口，2重写Object的clone方法。</p><p>代码如下</p><pre><code class="hljs java"><span class="hljs-comment">//原型类型</span><span class="hljs-keyword">package</span> day01.test;<span class="hljs-keyword">import</span> javax.sql.DataSource;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;    <span class="hljs-keyword">public</span> Date date;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(Date date, String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.date = date;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Person&#123;"</span> +                <span class="hljs-string">"date="</span> + date +                <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +                <span class="hljs-string">'&#125;'</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getDate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> date;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDate</span><span class="hljs-params">(Date date)</span> </span>&#123;        <span class="hljs-keyword">this</span>.date = date;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;<span class="hljs-comment">//主线程</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;    Date date=<span class="hljs-keyword">new</span> Date();    Person p1=<span class="hljs-keyword">new</span> Person(date,<span class="hljs-string">"zs"</span>);    Person clone = (Person) p1.clone();    System.out.println(p1.toString());    System.out.println(clone.toString());    System.out.println(<span class="hljs-string">"================"</span>);    date.setTime(<span class="hljs-number">123</span>);<span class="hljs-comment">//修改date</span>    System.out.println(p1.toString());    System.out.println(clone.toString());&#125;</code></pre><p>上面的代码以原型p1为模板，克隆了一个原型对象，但是这种克隆只是浅克隆，如果我们修改原型对象的引用类型数据，那么克隆对象中的引用类型也会随之改动</p><h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><p>浅克隆是只克隆按值传递的数据，比如基本数据类型、String类型，而不会克隆它所引用的对象，对修改原对象中的引用类型数据，克隆对象中的数据也会随之修改，如下图所示：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200613100516.png" srcset="/img/loading.gif" alt="image-20200613100510733"></p><h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><p>深克隆是除了克隆基本数据类型和String类型的值外，还会克隆引用类型的数据，重新在堆中开辟一段空间，用来放置引用对象，并且用新的引用指向该对象</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200613100751.png" srcset="/img/loading.gif" alt="image-20200613100747462"></p><p>深克隆代码如下</p><pre><code class="hljs java"><span class="hljs-comment">//只需要修改clone方法的代码即可</span><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;        Person person = (Person)<span class="hljs-keyword">super</span>.clone();<span class="hljs-comment">//得到克隆对象，将其转成person类型</span>        Date clone =(Date) <span class="hljs-keyword">this</span>.date.clone();<span class="hljs-comment">//得到原型对象中的引用对象</span>        person.date=clone;<span class="hljs-comment">//修改原型对象中的引用对象</span>        <span class="hljs-keyword">return</span> person;<span class="hljs-comment">//返回克隆对象</span>    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创建型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode76-最小覆盖子串</title>
    <link href="/2020/06/12/LeetCode76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/06/12/LeetCode76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode76-最小覆盖子串"><a href="#LeetCode76-最小覆盖子串" class="headerlink" title="LeetCode76 最小覆盖子串"></a>LeetCode76 最小覆盖子串</h1><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p><p>这是一道典型的滑动窗口，大致思路是使用两个指针left和right，先滑动right，使得[left,right)区间内的元素包含T中所有元素，此时再滑动left，缩小区间，当缩小到区间[left,right)缺少T中的一个字符时，滑动right，以此类推，直到right到达终点字符串S的末尾。记录中间的区间最小值的开头和结尾，最后返回即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<span class="hljs-comment">//左右指针</span>        <span class="hljs-keyword">int</span> start=<span class="hljs-number">0</span>,end=<span class="hljs-number">0</span>;<span class="hljs-comment">//区间开始位置和结尾位置</span>        <span class="hljs-keyword">int</span> sLen=s.length(),tLen=t.length();<span class="hljs-comment">//字符串长度</span>        <span class="hljs-keyword">int</span> minLen=Integer.MAX_VALUE;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;        HashMap&lt;Character,Integer&gt; target=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">//记录目标字符串中字符的出现次数</span>        HashMap&lt;Character,Integer&gt; window=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">//滑动窗口</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c:t.toCharArray())        &#123;            <span class="hljs-keyword">if</span>(target.containsKey(c)) target.put(c,target.get(c)+<span class="hljs-number">1</span>);            <span class="hljs-keyword">else</span> target.put(c,<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">while</span>(right&lt;sLen)        &#123;            <span class="hljs-keyword">char</span> c=s.charAt(right);            right++;<span class="hljs-comment">//滑动左指针</span>            <span class="hljs-keyword">if</span>(target.containsKey(c))            &#123;                window.put(c,window.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);                <span class="hljs-keyword">if</span>(window.get(c).equals(target.get(c))) res++;<span class="hljs-comment">//这里不可以使用==，因为是引用类型，比较的是地址，-128~127还可以用，超过就会new一个新对象出来</span>            &#125;            <span class="hljs-keyword">while</span>(res==target.size())<span class="hljs-comment">//满足要求，滑动右指针，缩小窗口</span>            &#123;                <span class="hljs-keyword">if</span>(right-left&lt;minLen)                &#123;                    start=left;                    end=right;                    minLen=end-start;                &#125;                <span class="hljs-keyword">char</span> d=s.charAt(left);                left++;<span class="hljs-comment">//移动右指针</span>                <span class="hljs-keyword">if</span>(target.containsKey(d))                &#123;                    <span class="hljs-keyword">if</span>(target.get(d).equals(window.get(d))) res--;<span class="hljs-comment">//移出元素，导致目标窗口不符合要求</span>                    window.put(d,window.get(d)-<span class="hljs-number">1</span>);                &#125;                            &#125;        &#125;        <span class="hljs-keyword">return</span> minLen==Integer.MAX_VALUE?<span class="hljs-string">""</span>:s.substring(start,end);    &#125;&#125;</code></pre><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p><code>window.get(c).equals(target.get(c))</code>改成 <code>window.get(c)==target.get(c)</code>会报错，原因是map取出来的是Integer类型，Integer第二次创建的时候不会使用new关键字，而是使用已经缓存的对象。 如果数值在-128~127位之间会有缓存，那么两个对象地址相同，此时使用 == 比较结果正确， 如果数值超出范围，就会创建新的对象，分配的地址不同，此时再用 == 比较就会出错。</p><p><code>while(right&lt;sLen){right++}</code>改成<code>for(right=0;right&lt;sLen;right++){}</code>也会报错，原因目前不清楚</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>滑动窗口</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode215-TopK</title>
    <link href="/2020/06/12/LeetCode215-TopK/"/>
    <url>/2020/06/12/LeetCode215-TopK/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode215-TopK"><a href="#LeetCode215-TopK" class="headerlink" title="LeetCode215 TopK"></a>LeetCode215 TopK</h1><p>给定数组，求数组中第K大的元素，最简单的方法是暴力求解，升序排好序后求第K个元素即可，这种解法代码如下：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;            <span class="hljs-keyword">int</span> len=nums.length;            Arrays.sort(nums);            <span class="hljs-keyword">return</span> nums[len-k];    &#125;&#125;</code></pre><p>但是面试官肯定不想你给出这种解法，如果数据量很大，无法一次存到内存中，暴力解法就用不上了</p><p>这种情况需要用堆来排序，建立一个大根堆，堆顶元素是最大值，这样只需要维护K次大根堆，那么就得到了第K大的元素，代码如下</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> len=nums.length;        heapSort(nums,len,k);        <span class="hljs-keyword">return</span> nums[len-k];    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) heapify(nums,size,i);<span class="hljs-comment">//先从最后一个非叶子节点开始调整</span>        <span class="hljs-comment">//上面那个for循环结束就代表着此时堆顶元素就是最大值了</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)        &#123;            swap(nums,<span class="hljs-number">0</span>,i);<span class="hljs-comment">//交换堆顶元素</span>            k--;<span class="hljs-comment">//k--，代表着交换了一次，求的是第K大元素，所以交换K次</span>            <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果k==0，说明交换了k次</span>            heapify(nums,i,<span class="hljs-number">0</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> i)</span><span class="hljs-comment">//维护结点i，使得结点i为合法位置</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> largest=i;        <span class="hljs-keyword">int</span> left=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> right=i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(left&lt;size &amp;&amp; nums[left]&gt;nums[largest] )largest=left;        <span class="hljs-keyword">if</span>(right &lt;size &amp;&amp; nums[right] &gt;nums[largest]) largest=right;        <span class="hljs-keyword">if</span>(i!=largest)        &#123;            swap(nums, i, largest);            heapify(nums,size,largest);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> temp=nums[i];        nums[i]=nums[j];        nums[j]=temp;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>高频面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复习路线</title>
    <link href="/2020/06/11/%E5%A4%8D%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <url>/2020/06/11/%E5%A4%8D%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><p>介绍一下反射机制，动态代理的好处和坏处</p><p>BIO/NIO/AIO介绍一下，NIO的实现方式</p><blockquote><p>IO(BIO)是面向流的，NIO是面向缓冲区的<br>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p></blockquote><p>接口和抽象类的区别</p><blockquote><p>1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。<br>2、抽象类要被子类继承，接口要被类实现。<br>3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现<br>4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。<br>5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。<br>6、抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}。<br>7、抽象类里可以没有抽象方法<br>8、如果一个类里有抽象方法，那么这个类只能是抽象类<br>9、抽象方法要被实现，所以不能是静态的，也不能是私有的。<br>10、接口可继承接口，并可多继承接口，但类只能单根继承。</p></blockquote><p>继承和组合的区别</p><blockquote><p>继承：子类继承父类</p><p>组合：has-a</p></blockquote><p>什么是值传递和引用传递，区别以及应用</p><p>JDK8新特性</p><p>深克隆和浅克隆</p><p>介绍一下static关键字，static方法能否被重写</p><p>序列化和反序列化什么时候用，如何对对象实现序列化</p><p>介绍一下HashMap，数据结构，线程安全</p><p>介绍一下ConcurentHashMap，JDK7和JDK8的区别，实现原理</p><p>介绍一下红黑树、B树、B+树，B树的插入过程，它们的应用场景</p><p>邻接表和邻接矩阵的区别，用处</p><p>介绍一下访问权限修饰符</p><blockquote><p>public           所有类可见<br>protected     本包和所有子类都可见（本包中的子类非子类均可访问，不同包中的子类可以访问，不是子类不能访问）<br>default          本包可见（即默认的形式）（本包中的子类非子类均可访问，不同包中的类及子类均不能访问）<br>priavte          本类可见</p></blockquote><p>介绍一下java的异常</p><p>Object类里面有哪些方法？</p><blockquote><pre><code class="hljs aspectj">&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;&gt;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);&#125;&gt;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> <span class="hljs-function">Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span>;&gt;<span class="hljs-keyword">public</span> <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">"@"</span> + Integer.toHexString(hashCode());&#125;&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeoutMillis, <span class="hljs-keyword">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;&#125;&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;wait(<span class="hljs-number">0</span>L);&#125;&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeoutMillis)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span></span>;&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notifyAll</span><span class="hljs-params">()</span></span>;&gt;<span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123; &#125;</code></pre></blockquote><h1 id="JAVA并发"><a href="#JAVA并发" class="headerlink" title="JAVA并发"></a>JAVA并发</h1><p>创建线程的三种方式，Runnable和Callable的区别，线程状态</p><p>wait和sleep的区别，wait和notify的使用场景</p><p>介绍一下volatile关键字，底层实现原理</p><p>介绍一下synchronized关键字以及原理，synchronized锁升级过程</p><p>介绍一下对象头</p><p>介绍一下AQS</p><p>介绍一下你知道的锁，公平锁、非公平锁、偏向锁、轻量级锁、重量级锁、自旋锁、悲观锁和乐观锁的原理</p><p>介绍一下cas操作，它是如何保证内存可见性的，可能出现的问题</p><p>介绍一下线程池，工作原理，重要参数、各种策略，有哪些阻塞队列，如何关闭线程池，创建线程池</p><p>常用的JUC包</p><p>Java内存模型介绍一下，八个指令是八个</p><p>cpu密集型多线程和io密集型多线程的比较。cpu密集型里如何管理多线程？ 用什么样的线程池和阻塞队列</p><p>线程之间的通讯，进程之间的通讯</p><p>io多路复用的原理和实现</p><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>JVM运行时内存区域划分？哪些线程私有？运行时数据区，私有共享都是哪些？堆区内存如何分配？</p><p>对象的生命周期？</p><p>JVM垃圾回收器，cms和g1的特点，两者的区别是什么，比g1更加先进的垃圾回收器有了解么，ZGC原理，能够管理多大的内存，CMS能管理多大的内存，G1呢</p><p>JVM内存模型 类的生命周期 类加载过程  双亲委派机制了解吗  进入老年代过程 什么情况下直接进入老年代</p><p>JVM内存分布（堆栈等，程序计数器+jvm栈+本地方法栈线程不共享，堆和方法区线程共享）</p><p>类加载机制，过程，类加载机制？如何自定义实现类加载器？双亲委派模型、类加载器类别，双亲委派模型本质是解决了什么问题？安全性，有哪几种类加载器？类加载的流程。知道哪些类加载器。类加载器之间的关系？双亲委派模型。为什么使用双亲委派模型？</p><p>垃圾回收算法，常见的垃圾回收器及他们之间区别，垃圾回收发生在哪里，怎么判断对象存活、GC Roots具体有哪些、讲讲对象分配与回收，什么可以作为垃圾回收的对象，垃圾回收算法和流程。</p><p>栈什么情况下会溢出？</p><p>静态变量存放在内存哪个区域？</p><p>怎么查看java虚拟机内存占用？</p><p>如何减少full gc的次数？方法区是否需要gc</p><p>4个引用类型</p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>输入一个url后的过程；浏览器从发送请求的全部过程</p><p>OSI七层和TCP四层协议，OSI七层模型/五层模型，每一层有哪些协议，http，tcp，ip位于哪一层</p><p>TCP三次握手四次分手，tcp四次挥手为什么要四次，为什么TCP是安全的，TCP，UDP的区别</p><p>TCP报文结构，HTTP结构， TCP，UDP，HTTP的报文格式（我懵了）</p><p>设计一个应用层协议（没有答出来</p><p>HTTP协议连接过程，HTTPS连接过程，HTTP的长连接是怎么做的HTTP2和HTTP1区别，HTTP请求过程<br>http的几种方法，HTTP跟HTTPS的区别，https加密过程</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>程序，进程和线程的区别</p><p>什么时候情况下要用多线程？</p><p>进程之间怎么通信的？</p><p>一个手机应用程序里面的进程和线程分别是怎么进行的？</p><p>死锁，怎么解死锁，死锁条件，怎么预防</p><p>进程的状态：阻塞+就绪+执行</p><p>手机内存8g，是32位的，一个进程能申请多少内存？</p><p>线程的应用，举例，线程的阻塞</p><p>主线程和子线程的区别</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>linux中如何查看CPU负载 top</p><p>linux用过嘛（扯到了我训练过深度模型，小哥哥直接来了个场景题）<br>场景题：推荐算法中如何控制广告推送频率（结合强化学习说了一些</p><p>Linux了解不，df dh区别，如何格式化磁盘，磁盘挂载过程，tcp丢包如何排查，docker是用什么实现的</p><p>怎么查找特定后缀名或前缀名的文件</p><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><p>数据库引擎事务隔离级别，串行化如何实现，数据库的隔离级别？四个。你平常使用的是哪个隔离级别。数据库隔离级别以及分别解决了什么问题</p><p>MySQL的存储引擎有哪些？它们之间的区别？你用的mysql存储引擎？为什么选择它？实现原理？</p><p>怎么判断一个SQL语句有没有走索引？紧接着问explain知道哪些字段吗</p><p>mysql存储模型 区别 怎么看用没用索引 怎么判断sql语句好坏</p><p>数据库中索引B+树</p><p>一个手机应用要更改数据库，它的底层是怎么实现的？</p><p>sql查询过程</p><p>MySQL InnoDB存储引擎中的MVCC解决了什么问题，能说下MVCC的实现原理么</p><p>SQL语句经常写吧，那我给你出一道SQL题（分组求和排序）</p><p>你认为什么情况下不应该建立索引</p><p>mysql有几种锁？怎么实现？</p><p>innodb事物的级别</p><p>b 树的结构？与二叉树的区别？与b树的区别？</p><p>写过最复杂的sql，  手写代码： 统计各个科目考试最高分:最复杂的包括了sum、case、left join、group by，追问左连接和内联区别，没答上来</p><p>聚簇索引跟红黑树</p><p>sql :给一个日期范围，统计每天入库的数据总量</p><p>sql语句里like和in关键字</p><p>sql语句，求平均分超过60分的学生学号</p><p>数据库sql怎么优化 </p><p>什么情况不能用索引？</p><p>SELECT column_name(s)<br>FROM table_name<br>WHERE column_name<br>BETWEEN value1 AND value2 什么时候会发生死锁；怎么解决死锁；N个资源怎么办？</p><h1 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h1><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>双重检索单例</p><p>设计模式分为哪三类，各有什么？设计模式，用过哪些设计模式，讲几个，设计模式和原则</p><p>代理模式属于哪一类</p><p>生产者消费者模式,生产消费者的，以及多生产者同步</p><p>描述适配器，写单例</p><p>单例模式，装饰模式，</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>排序算法有哪些，简述冒泡和归并排序，冒泡算法的优化,讲讲归并排序,冒泡的优化知道吗；回答相等不交换，还有flag做已排序标志的优化；直接插入排序，写一下伪代码或者说一下思路,插入排序，时间复杂度</p><p>堆排序原理</p><p>快排,快排是什么思想，快排的优化是啥，为啥这么做；</p><p>字母排序</p><p>100个数中找出想要的数</p><p>一个数组分成2个相等或接近的子数组</p><p>派单的最短路径问题</p><p>很大的数据，内存放不下，如何快速找到中间值</p><p>手撕栈</p><p>链表找环 链表找环入口，不用双指针怎么做</p><p>双向链表实现 ，写了个add()和add(index)的</p><p>求数组的全排列</p><p>中序遍历，递归非递归</p><p>求四个数绝对值的最小值</p><p>黑猫白猫，混在一起，如何把他们区分开？ 黑白灰三种猫混在一起，如何按照黑白灰排好序？ 还有两个小问题忘记了。</p><p>如何用一个int值，表示三种状态？</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/weixin_43495390/article/details/86533482" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43495390/article/details/86533482</a></p>]]></content>
    
    
    <categories>
      
      <category>复习大纲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/2020/06/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式解决的问题是：<strong>创建对象的过程比较复杂，希望对外隐藏这些细节</strong>。比如创建线程池对象、连接池对象等</p><p>工厂模式又分成：简单工厂、静态工厂、抽象工厂模式</p><p><strong>简单工厂模式：</strong>又叫静态工厂模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例</p><p><strong>工厂模式：</strong>实例化对象不适用new，用工厂方法代替</p><p><strong>抽象工厂模式：</strong>抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式</p><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>代码如下</p><pre><code class="hljs java"><span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//实现类---ProductA</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"ProductA"</span>);    &#125;&#125;<span class="hljs-comment">//实现类---ProductB</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"ProductB"</span>);    &#125;&#125;<span class="hljs-comment">//静态工厂</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Product <span class="hljs-title">getPerson</span><span class="hljs-params">(String product)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(product.equals(<span class="hljs-string">"ProductA"</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductA();    <span class="hljs-keyword">if</span>(product.equals(<span class="hljs-string">"ProductB"</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductB();    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-comment">//主线程</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Product p1=StaticFactory.getProduct(<span class="hljs-string">"ProductA"</span>);    Product p2=StaticFactory.getProduct(<span class="hljs-string">"ProductB"</span>);    p1.name();    p2.name();&#125;</code></pre><p>弊端：假如需要新增加一个新产品ProductC，那么就需要修改StaticFactory的原代码，违反了开闭原则</p><p>解决方法：工厂方法模式</p><h2 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂方法模式是在不修改已有类的前提下，通过增加新的工厂来扩展功能</p><p>代码如下</p><pre><code class="hljs java"><span class="hljs-comment">//工厂接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//工厂实现类A</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductA();    &#125;&#125;<span class="hljs-comment">//工厂实现类B</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductB();    &#125;&#125;<span class="hljs-comment">//主程序</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Factory factory1=<span class="hljs-keyword">new</span> FactoryA();    Factory factory2=<span class="hljs-keyword">new</span> FactoryB();    factory1.createProduct().name();    factory2.createProduct().name();&#125;</code></pre><p>如果我们想拓展新的产品，那么只需要添加一个工厂即可，比如想添加产品productC，代码如下</p><pre><code class="hljs java"><span class="hljs-comment">//产品类C</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductC</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"ProductC"</span>);    &#125;&#125;<span class="hljs-comment">//工厂C</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryC</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductC();    &#125;&#125;<span class="hljs-comment">//主线程</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Factory factory1=<span class="hljs-keyword">new</span> FactoryA();    Factory factory2=<span class="hljs-keyword">new</span> FactoryB();    Factory factory3=<span class="hljs-keyword">new</span> FactoryB();<span class="hljs-comment">//构建一个工厂C，用来生产产品C</span>    factory1.createProduct().name();    factory2.createProduct().name();    factory3.createProduct().name();<span class="hljs-comment">//生产产品C</span>&#125;</code></pre><p>上面的两种模式都只有一个产品接口，如果产品接口多了起来，需要很多工厂类，代码量会翻倍，所以需要引入抽象工厂模式。</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>抽象工厂可以认为是有多个接口的工厂方法，比如product中有接口A、接口B、接口C等。类比到手机产品，有充电接口、耳机接口、电池接口等</p><p>代码如下</p><pre><code class="hljs java"><span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OtherProduct</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">look</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//Product接口的实现类见上文</span><span class="hljs-comment">//OtherProduct接口的实现类A</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherProductA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OtherProduct</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">look</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"lookA"</span>);    &#125;&#125;<span class="hljs-comment">//OtherProduct接口的实现类B</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherProductB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OtherProduct</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">look</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"OtherProductB"</span>);    &#125;&#125;<span class="hljs-comment">//OtherProduct接口的实现类C</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherProductC</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OtherProduct</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">look</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"OtherProductC"</span>);    &#125;&#125;<span class="hljs-comment">//工厂接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> OtherProduct <span class="hljs-title">createOtherProduct</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//工厂接口实现类A</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> OtherProduct <span class="hljs-title">createOtherProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OtherProductA();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductA();    &#125;&#125;<span class="hljs-comment">//工厂接口实现类B</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductB();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> OtherProduct <span class="hljs-title">createOtherProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OtherProductB();    &#125;&#125;<span class="hljs-comment">//工厂接口实现类C</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryC</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductC();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> OtherProduct <span class="hljs-title">createOtherProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OtherProductC();    &#125;&#125;<span class="hljs-comment">//主线程</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Factory factory1=<span class="hljs-keyword">new</span> FactoryA();    Factory factory2=<span class="hljs-keyword">new</span> FactoryB();    Factory factory3=<span class="hljs-keyword">new</span> FactoryC();    factory1.createProduct().name();    factory1.createOtherProduct().look();    factory2.createProduct().name();    factory2.createOtherProduct().look();    factory3.createProduct().name();    factory3.createOtherProduct().look();&#125;</code></pre><p>总结：工厂设计模式的出现是为了封装复杂的创建过程，只提供给调用者实现，其中简单工厂和工厂模式可以认为是只有一个接口的抽象工厂</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创建型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2020/06/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式指的是一个类只有一个实例，单例分为饿汉式单例和懒汉式单例</p><p>懒汉式单例：只有再用实例的时候，才去创建这个类的实例</p><p>饿汉式单例：初始化的时候就创建好实例，不管你用不用</p><h2 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//私有构造函数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton=<span class="hljs-keyword">new</span> Singleton();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> singleton;    &#125;&#125;</code></pre><h2 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h2><p>懒汉式单例时面试高频考点，因为多线程下下面这种代码不是线程安全的，面试官会让你不断优化</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//私有构造函数，这样外界就无法通过构造函数来初始化单例</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(singleton==<span class="hljs-keyword">null</span>) singleton=<span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">//当使用这个单例时，发现没有初始化才开始初始化，所以是懒汉式</span>        <span class="hljs-keyword">return</span> singleton;    &#125;&#125;</code></pre><p>上面代码<code>if(singleton==null) singleton=new Singleton();</code>,当有两个线程A和B同时进入到<code>if</code>判断，那么<code>new Singleton()</code>，就会执行两次，所以需要双重检测锁模式的懒汉式单例</p><h3 id="DCL懒汉式单例"><a href="#DCL懒汉式单例" class="headerlink" title="DCL懒汉式单例"></a>DCL懒汉式单例</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//私有构造函数，这样外界就无法通过构造函数来初始化单例</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(singleton==<span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//第一次检测</span>            <span class="hljs-keyword">synchronized</span> (Singleton<span class="hljs-class">.<span class="hljs-keyword">class</span>)//加一把锁</span><span class="hljs-class">            </span>&#123;                <span class="hljs-keyword">if</span>(singleton==<span class="hljs-keyword">null</span>)<span class="hljs-comment">//第二次检测，目的是防止当两个线程同时进入到第一次if判断时，singleton此时为空，当第一个线程执行完代码释放锁后</span>                &#123;<span class="hljs-comment">//第二个线程进入，此时singleton因为已经被第一个线程实例化了，就进不来第二个if判断</span>                    singleton=<span class="hljs-keyword">new</span> Singleton();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> singleton;    &#125;&#125;</code></pre><p>但是上面代码还存在一个问题：<code>singleton=new Singleton();</code>不是原子性操作，它可以分成三步，第一步分配空间，第二步执行构造器方法，初始化对象，第三步将引用指向内存空间，但是JVM编译器会进行<strong>指令重排</strong>，执行顺序可能是132。假如线程A执行到了<code>singleton=new Singleton();</code>，当这一行代码执行顺序是132，先分配空间，再将引用指向内存空间，刚执行完这一步，线程B进来了，因为此时已经把引用指向了内存空间，所以<code>if(singleton==null)</code>判断为false，直接返回<code>singleton</code>，但实际上此时singleton所指向的内存空间还没有初始化，实际还未空，所以线程B返回的<code>singleton</code>实际为<code>null</code></p><h3 id="加Volatile的DCL"><a href="#加Volatile的DCL" class="headerlink" title="加Volatile的DCL"></a>加Volatile的DCL</h3><p>优化：加一个<code>volatile</code>关键字，<code>volatile</code>关键字有两个作用：一个是禁止指令重排、一个是保持变量的内存可见性。所以加了volatile关键字，禁止了JVM的指令重排，也就维护了线程安全</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//私有构造函数，这样外界就无法通过构造函数来初始化单例</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<span class="hljs-comment">//volatile禁止指令重排</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(singleton==<span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//第一次检测</span>            <span class="hljs-keyword">synchronized</span> (Singleton<span class="hljs-class">.<span class="hljs-keyword">class</span>)//加一把锁</span><span class="hljs-class">            </span>&#123;                <span class="hljs-keyword">if</span>(singleton==<span class="hljs-keyword">null</span>)<span class="hljs-comment">//第二次检测，目的是防止当两个线程同时进入到第一次if判断时，singleton此时为空，当第一个线程执行完代码释放锁后</span>                &#123;<span class="hljs-comment">//第二个线程进入，此时singleton因为已经被第一个线程实例化了，就进不来第二个if判断</span>                    singleton=<span class="hljs-keyword">new</span> Singleton();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> singleton;    &#125;&#125;</code></pre><p>但是上面代码还是有问题，我们可以通过反射获取构造器，修改构造器访问权限，然后再使用构造器的<code>newInstance()</code>方法来创建实例，代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Constructor&lt;Singleton&gt; constructor = Singleton<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getDeclaredConstructor</span>(<span class="hljs-title">null</span>)</span>;        constructor.setAccessible(<span class="hljs-keyword">true</span>);        Singleton singleton = constructor.newInstance();        Singleton singleton1=constructor.newInstance();        System.out.println(singleton.hashCode());<span class="hljs-comment">//打印出来hashcode，发现两个对象的hashcode不同，所以不是一个对象</span>        System.out.println(singleton1.hashCode());    &#125;</code></pre><p>解决方法：枚举，关键字<code>enum</code>可以使得JVM阻止反射获取枚举类的私有构造方法</p><h3 id="使用枚举的单例"><a href="#使用枚举的单例" class="headerlink" title="使用枚举的单例"></a>使用枚举的单例</h3><pre><code class="hljs java"><span class="hljs-keyword">enum</span> EnumSingleton &#123;    INSTANCE;    <span class="hljs-function"><span class="hljs-keyword">public</span> EnumSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创建型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2020/06/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式基于六大设计原则，分成三类，一共有23种</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>开闭原则：扩展开发，修改关闭</p><p>单一职责：一个类只负责一件事情</p><p>里氏替换原则：子类应该可以完全替代父类。</p><p>依赖倒置原则：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程。</p><p>迪米特法则：又名最少知道原则，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。</p><p>接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法未被客户端实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法</p><p>组合原则：尽量使用对象组合，而不是继承来达到复用的目的。</p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模型提供创建对象的机制，省去new的步骤</p><p>一共有六种：<strong>单例模式(Singleton)、原型模式(prototype)、工厂方法(Factory method)、抽象工厂(Abstract Factory)</strong>和建造者模式(Builder)</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>作用：从程序实现送耦合，扩大类结构，解决更大的问题</p><p>一共有七种：<strong>组合模式(Composite)、适配器模式(Adapter)、装饰者模式(Decorator)、代理模式(Proxy)</strong>、外观模式(Facade)、桥接模式(Bridge)、享元模式(Flyweight)</p><h2 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h2><p>行为模式负责对象间的高效沟通和职责委派。</p><p>一共有十一种：<strong>策略模式(Strategy)、观察者模式(Observer)</strong>、责任链(chain of Responsibilty)、命令(Command)、迭代器(Iterator)、中介者(Mediator)、备忘录(Memento)、状态(State)、模板方法(Template Method)、访问者(Visitor)、解释器模式(Interpreter)</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>大纲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC</title>
    <link href="/2020/06/11/SpringMVC/"/>
    <url>/2020/06/11/SpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC（待续）"><a href="#SpringMVC（待续）" class="headerlink" title="SpringMVC（待续）"></a>SpringMVC（待续）</h1><p>MVC是一种开发模式，将程序分层的一种思想。</p><blockquote><p>M：Model—&gt;业务数据（service、repository、entity）</p><p>V：View—&gt;视图（JSP、HTML、APP客户端）</p><p>C：Controller—&gt;控制（Servlet、Handler、Action）</p><p>这三者关系简单来说是：请求进入Controller，Controller调用业务模型Model，Model再去数据库获取数据，然后返回View层</p></blockquote><p>SpringMVC就是通过DispatcherServlet将一堆组件串联起来的Web框架，SpringMVC的整个运行体系，是由DispatcherServlet、组件和容器这三者共同构成的。DispatcherServlet是逻辑处理的调度中心，组件则是被调度的操作对象。而容器在这里所起到的作用，是协助DispatcherServlet更好地对组件进行管理DispatcherServlet对容器进行初始化，容器对组件进行全局管理，DispatcherServlet对组件进行逻辑调用</p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>DispatcherServlet：前置控制器，整个流程控制的核心，控制其他组件的执行，进行统一调度，降低组件之间的耦合性。</p><p>Handler：处理器，完成具体的业务逻辑，相当于Servlet</p><p>HandlerMapping：DispatcherServlet接受到请求后，通过HandlerMapping将不同的请求映射到不同的Handler</p><p>HandlerInterceptor：处理器拦截器，主要功能是负责拦截一些请求和操作</p><p>HandlerExecutionChain：处理器执行链，包括两部分：Handler和HandlerInterceptor</p><p>HandlerAdapter：处理器适配器，handler执行业务方法之前，需要进行一系列操作，包括表单数据的验证、数据类型的转换、将表单数据封装到JavaBean等，使得开发者只需要将注意力集中到业务逻辑的处理上。DispatcherServlet通过HandlerAdapter执行不同的Handler</p><p>ModelAndView：装载了模型数据和视图信息，作为Handler的处理结果，返回给DispatcherServlet</p><p>ViewResolver：视图解析器，DispatcherServlet通过它将逻辑视图解析为物理视图。逻辑视图不是真实存在的一个视图，逻辑概念，物理视图是真实存在的</p><h3 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h3><p>客户端发起请求，DispatcherServlet接受请求</p><p>HandlerMapping根据不同的请求映射到不同的Handler上，返回一个HandlerExecutionChain给DispatcherServlet</p><p>DispatcherServlet调用HandlerAdapter执行handler，handler执行完毕后返回一个ModelAndView</p><p>DispatcherServlet拿到结果后解析ModelAndView，解析由ViewResolver负责解析，把逻辑视图解析成物理视图。解析结果返回给DispatcherServlet</p><p>DispatcherServlet根据View进行视图渲染，将模型数据填充到视图View中</p><p>DispatcherServlet将渲染后的结果响应再返回给客户端</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200613165102.png" srcset="/img/loading.gif" alt="image-20200613165056813"></p><h2 id="DispatcherServlet：前置控制器"><a href="#DispatcherServlet：前置控制器" class="headerlink" title="DispatcherServlet：前置控制器"></a>DispatcherServlet：前置控制器</h2><p>DispatcherServlet对于容器<strong>WebApplicationContext</strong>的初始化是在FrameworkServlet中完成的，在默认情况下，这个初始化过程是由web.xml中的入口程序配置所驱动的</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Processes application requests --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/**<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据Spring的设计原则，所有纳入WebApplicationContext中管理的对象，都被映射为XML中的一个&lt;bean&gt;节点，通过对于&lt;bean&gt;节点的一个完整描述，我们可以有效地将整个应用程序中所有的对象都纳入到一个统一的容器中进行管理--&gt;</span></code></pre><p>在默认情况下，web.xml配置节点中<code>&lt;servlet-name&gt;</code>的值就是建立起核心分发器DispatcherServlet与核心配置文件之间联系的桥梁。DispatcherServlet在初始化时会加载位置在/WEB-INF/[servlet-name]-servlet.xml的配置文件作为SpringMVC的核心配置。</p><p>SpringMVC核心配置文件中所有的bean定义，就是SpringMVC的组件定义，也是DispatcherServlet在初始化容器（WebApplicationContext）时，所要进行初始化的组件。</p><p>概括一下WebApplicationContext初始化的两个逻辑层次：</p><ul><li><strong>DispatcherServlet负责对容器（WebApplicationContext）进行初始化。</strong></li><li><strong>容器（WebApplicationContext）将读取SpringMVC的核心配置文件进行组件的实例化。</strong></li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>@RequestMapping</p><p>作用：将URL请求与业务方法进行映射，在Handler的类定义出以及方法定义处都可以添加。在类定义处添加，相当于客户端多了一层访问路径。</p><p>参数</p><blockquote><p>value：直到URL请求的实际地址，是@RequestMapping的默认值</p><p>method：指定请求的类型（GET/POST/PUT/DELETE），表示该方法只可以被指定请求来访问，不加的话get和post都可以</p><p>params：表示指定请求中必须含有某些参数，否则无法访问</p></blockquote><p>SpringMVC支持restful风格，使用方式</p><blockquote><p>@RequestMapping(“/xx/{xx}/{xx}”)，而且必须在形参列表加注解@PathVariable(“xx”)，传统方式是参数名和形参名一样即可</p></blockquote><p>@Controller</p><p>作用：将该类交给IOC容器来管理（结合springmvc.xml的自动扫描配置使用），成为一个控制器，可以接受客户端请求</p><p>@RestController</p><p>作用：该控制器会直接将业务方法的返回值响应给客户端，不进行视图解析</p><p>@RequestParam</p><p>作用：在形参列表中添加该注解，可以完成请求参数与业务方法形参的映射</p><p>@ResponseBody</p><p>作用：直接返回该类型值给客户端，如果不加，SpringMVC会将该方法传递给DispatcherServlet，再由DispatcherServlet调用ViewResolver对返回值进行解析，映射到JSP资源</p><p>数据绑定：直接获取客户端HTTP请求中的参数，将参数映射到业务方法的形参中，该工作由HandleAdapter完成</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>常用依赖</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>       <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Spring：<a href="https://docs.spring.io/spring/docs/4.3.24.RELEASE/spring-framework-reference/html/mvc.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/4.3.24.RELEASE/spring-framework-reference/html/mvc.html</a></p>]]></content>
    
    
    <categories>
      
      <category>SSM</category>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2020/06/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/06/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h1><p>各个算法的时间和空间复杂度如下图所示：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200611124222.png" srcset="/img/loading.gif" alt="image-20200611124218763"></p><p>选择排序：最稳定的排序算法，无论什么情况时间复杂度否是O(n^2)</p><p>插入排序：采用in-place内部排序，空间复杂度为O(1)</p><p>归并排序：稳定的排序算法，分治思想的典型应用，先使子序列有序，再将两个子序列合并成有序序列</p><p>快速排序：不稳定</p><p>堆排序：利用数据结构堆设计的排序算法</p><p>计数排序：稳定排序算法，不是基于比较的排序算法，将数组转换成键值对的形式存储在额外的数组空间</p><p>桶排序：稳定，桶的划分很重要</p><p>基数排序：稳定，按照数字位上的数排序。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基数排序</title>
    <link href="/2020/06/11/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/11/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>基数排序是桶排序的升级版把数组中每一个数字，都分成不同位，先比较数字不同位的大小，先按照个位大小排序，再按照十位大小排序….一直到最高位，最高位的排序结果就是最终的排序结果，具体见下图，图片来自@sky。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200611122731.png" srcset="/img/loading.gif" alt="image-20200611122725122"></p><p>Java代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buicketSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> maxExp=getExp(nums);    <span class="hljs-keyword">int</span> len=nums.length;    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) lists.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<span class="hljs-comment">//因为是十进制，所以有0~9，十个桶</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=maxExp;i++)    &#123;        <span class="hljs-comment">//1234,假如想得到百位的2，应该是1234%1000=234,234/100=2，所以应该先取模，再相除，最终就知道了值</span>        <span class="hljs-keyword">double</span> exp1=Math.pow(<span class="hljs-number">10</span>, i);        <span class="hljs-keyword">double</span> exp2=Math.pow(<span class="hljs-number">10</span>,i-<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)<span class="hljs-comment">//先按照位添加到指定数组中</span>        &#123;            <span class="hljs-keyword">int</span> index=(<span class="hljs-keyword">int</span>)(nums[j]%exp1/exp2);<span class="hljs-comment">//算出这数字nums[j]的某一位的值，来决定添加到哪一个桶上</span>            lists.get(index).add(nums[j]);<span class="hljs-comment">//添加到指定桶</span>        &#125;        <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<span class="hljs-comment">//下标，按照位排好序的结果要写回原数组</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">10</span>;j++)<span class="hljs-comment">//遍历list中的每一个数组，将其写回到原数组中去</span>        &#123;            <span class="hljs-keyword">while</span> (lists.get(j).size()&gt;<span class="hljs-number">0</span>)            &#123;                ArrayList&lt;Integer&gt; temp=lists.get(j);                nums[k++]=temp.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//把按照某一位排序的结果写回到数组</span>                temp.remove(<span class="hljs-number">0</span>);            &#125;        &#125;    &#125;&#125;</code></pre><p>用处：主要用于处理数字较多的情况，比如手机号排序。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桶排序</title>
    <link href="/2020/06/11/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/11/%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>桶排序是一种计数排序的升级版，如果把每一个数都看成是一个桶的话，那么桶排序就是计数排序，简单来说就是生成若干个桶，每一个桶存放指定范围内的数据，如数组范围是0<del>100，有十个桶，每一个桶的范围分别是0</del>10,10~20，….等，通过把数据分到桶中，再对桶中数据进行排序，然后再依次从桶中取出数据，即为最终排好序的数据。桶排序需要尽量保证元素分散均匀，否则当所有数据集中在同一个桶中时，桶排序失效</p><p>注：桶之间也是有序的，即后一个桶的最小值是大于前一个桶的最大值的。</p><p>Java代码如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buicketSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> min=nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> max=nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> len=nums.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">if</span>(min&gt;nums[i]) min=nums[i];        <span class="hljs-keyword">if</span> (max&lt;nums[i]) max=nums[i];    &#125;    <span class="hljs-keyword">int</span> buicketNum=(max-min)/len+<span class="hljs-number">1</span>;<span class="hljs-comment">//确定桶的个数</span>    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; buicket=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;buicketNum;i++)    &#123;        buicket.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)        buicket.get((i-min)/len).add(nums[i]);<span class="hljs-comment">//按照元素的值来放到指定的桶内</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;buicketNum;i++)        Collections.sort(buicket.get(i));<span class="hljs-comment">//每一个桶内的排序方式任意</span>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;buicketNum;i++)<span class="hljs-comment">//遍历桶，后一个桶内的最小值是大于前一个桶内的最大值的。</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;buicket.get(i).size();i++)            nums[index++]= buicket.get(i).get(j);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计数排序</title>
    <link href="/2020/06/11/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/11/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序是通过数组中元素出现的次数来计数的，先找到数组中的最大值max，然后建立一个长度为max+1的数组count，对原数组nums中的数字出现的次数遍历，最后再遍历count数组，如果count[i]值不为空，说明nums中有这个值，输出回原数组nums，遍历完count数组，即得到了nums数组排序后的结果</p><p>代码如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录数组最大值</span>    <span class="hljs-keyword">int</span> len=nums.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">if</span>(res&lt;nums[i]) res=nums[i];<span class="hljs-comment">//找到数组最大值</span>    &#125;    <span class="hljs-keyword">int</span>[] count=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res+<span class="hljs-number">1</span>];<span class="hljs-comment">//建立长度为res+1的计数数组</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) count[nums[i]]++;<span class="hljs-comment">//计算nums[i]出现的次数</span>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;res;i++)<span class="hljs-comment">//遍历count数组</span>    &#123;        <span class="hljs-keyword">while</span> (count[i]&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//如果数组大于0，说明nums数组中有i这个值</span>        &#123;            nums[k++]=i;<span class="hljs-comment">//将这个值写会到数组中</span>            count[i]--;<span class="hljs-comment">//i这个值出现次数-1</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(i&gt;=nums.length) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> temp=nums[i];    nums[i]=nums[j];    nums[j]=temp;&#125;</code></pre><p>优化：</p><p>容易发现count数组小于下标nums中最小值的空间都被浪费了，是不可能存在值的，所以可以建立一个长度为Max-min+1数组</p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> max=nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> min=nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> len=nums.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">if</span>(max&lt;nums[i]) max=nums[i];        <span class="hljs-keyword">if</span>(min&gt;nums[i]) min=nums[i];    &#125;    <span class="hljs-keyword">int</span>[] count=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max-min+<span class="hljs-number">1</span>];<span class="hljs-comment">//优化空间</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) count[nums[i]-min]++;<span class="hljs-comment">//优化代码</span>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;max-min+<span class="hljs-number">1</span>;i++)    &#123;        <span class="hljs-keyword">while</span> (count[i]&gt;<span class="hljs-number">0</span>)        &#123;            nums[k++]=i+min;<span class="hljs-comment">//优化代码</span>            count[i]--;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(i&gt;=nums.length) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> temp=nums[i];    nums[i]=nums[j];    nums[j]=temp;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序</title>
    <link href="/2020/06/11/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/11/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆是一颗完全二叉树，即除了最后一层，其余每一层的左右结点都被填满，且最后一层叶子节点从左到右依次填充</p><p>大根堆：根节点的值大于左右结点的值(不要求左右节点的相对大小，即左节点一定要大于右节点或者右节点一定要大于左节点)</p><p>小根堆：根节点的值小于左右结点的值</p><p>下面讲解大根堆的堆排序</p><p>堆排序是通过维护一个大根堆，来使得堆顶元素总是为最大值，交换堆顶元素和最后一个结点元素，这样最大值就跑到了数组最后，然后继续维护剩余元素为一个大根堆，再交换堆顶元素和倒数第二个元素，以此类推，这样不断交换最大值，最终实现了排序。</p><p>注意：数组下标在堆中的对应关系：因为堆是一颗完全二叉树，所以下标为i的根节点，左节点的下标为<code>i*2+1</code>，右节点下标为<code>i*2+2</code></p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heap, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> i)</span><span class="hljs-comment">//维护下标为i的结点，使得该节点值大于左右子节点的值</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> max_index=i;<span class="hljs-comment">//下标为i的结点</span>    <span class="hljs-keyword">int</span> left=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//i结点的左节点</span>    <span class="hljs-keyword">int</span> right=i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;<span class="hljs-comment">//i节点的右节点</span>    <span class="hljs-keyword">if</span>(left&lt;size &amp;&amp; heap[left]&gt;heap[max_index]) max_index=left;<span class="hljs-comment">//记录最大值的下标</span>    <span class="hljs-keyword">if</span>(right &lt;size &amp;&amp; heap[right]&gt;heap[max_index]) max_index=right;    <span class="hljs-keyword">if</span>(max_index!=i)<span class="hljs-comment">//如果下标i的值小于左右节点中的最大值</span>    &#123;        swap(heap,max_index,i);<span class="hljs-comment">//交换堆顶元素和左右节点中的最大值</span>        heapify(heap,size,max_index);<span class="hljs-comment">//下标为i的结点被交换下来，继续维护这个结点，使得这个结点为大根堆</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heap, <span class="hljs-keyword">int</span> size)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        heapify(heap,size,i);<span class="hljs-comment">//维护每一个非叶子节点</span>    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        swap(heap,<span class="hljs-number">0</span>,i);<span class="hljs-comment">//上面已经建好一个大根堆，所以堆顶元素为最大值，把最大值放到数组最后面</span>        heapify(heap,i,<span class="hljs-number">0</span>);<span class="hljs-comment">//继续维护，数组此时长度减一</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(i&gt;=nums.length) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> temp=nums[i];    nums[i]=nums[j];    nums[j]=temp;&#125;</code></pre><p>小根堆代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heap, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> i)</span><span class="hljs-comment">//维护下标为i的结点，使得该节点值小于左右子节点的值</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> min_index=i;    <span class="hljs-keyword">int</span> left=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> right=i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span>(left&lt;size &amp;&amp; heap[left]&lt;heap[min_index]) min_index=left;<span class="hljs-comment">//只需要heap[left]&gt;heap[min_index]改成heap[left]&lt;heap[min_index]即可</span>    <span class="hljs-keyword">if</span>(right &lt;size &amp;&amp; heap[right]&lt;heap[min_index]) min_index=right;<span class="hljs-comment">//同上</span>    <span class="hljs-keyword">if</span>(max_index!=i)    &#123;        swap(heap,min_index,i);        heapify(heap,size,min_index);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heap, <span class="hljs-keyword">int</span> size)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        heapify(heap,size,i);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        swap(heap,<span class="hljs-number">0</span>,i);        heapify(heap,i,<span class="hljs-number">0</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(i&gt;=nums.length) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> temp=nums[i];    nums[i]=nums[j];    nums[j]=temp;&#125;</code></pre><p>参考资料：</p><p>图解排序算法：<a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p><p>排序算法总结：<a href="https://www.acwing.com/blog/content/2064/" target="_blank" rel="noopener">https://www.acwing.com/blog/content/2064/</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2020/06/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序先把数组分成两半，每一半再递归进行平分，当只有一个元素时，递归结束。然后两两比较值，合并数组，进行排序。</p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">//找到数组中点</span>    merge_sort(q,l,mid);<span class="hljs-comment">//递归左半部分</span>    merge_sort(q,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//递归右半部分</span>    <span class="hljs-keyword">int</span> i=l,j=mid+<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(i &lt;=mid &amp;&amp; j&lt;=r)<span class="hljs-comment">//递归结束后，开始左右两部分的值，进行排序</span>    &#123;        <span class="hljs-keyword">if</span>(q[i]&lt;q[j]) temp[k++]=q[i++];<span class="hljs-comment">//temp数组用来继续排序结果</span>        <span class="hljs-keyword">else</span> temp[k++]=q[j++];    &#125;    <span class="hljs-keyword">while</span>(i&lt;=mid) temp[k++]=q[i++];<span class="hljs-comment">//如果左半部分还有值</span>    <span class="hljs-keyword">while</span>(j&lt;=r) temp[k++]=q[j++];<span class="hljs-comment">//如果右半部分还有值</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> w=l,k=<span class="hljs-number">0</span>;w&lt;=r;w++,k++) q[w]=temp[k];<span class="hljs-comment">//将temp记录的排好序后的元素写回到原数组</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2020/06/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快排是从数组中选一个锚点privot，把数组按照锚点分成小于锚点的值和大于锚点的值两部分，然后再递归求解这两部分</p><p>下面这种解法来自@Diamondz </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//if(i&gt;=nums.length) return;</span>    <span class="hljs-keyword">int</span> temp=nums[i];    nums[i]=nums[j];    nums[j]=temp;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(left&gt;=right) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果区间长度为1，则返回</span>    <span class="hljs-keyword">int</span> privot=nums[left];<span class="hljs-comment">//选定锚点</span>    <span class="hljs-keyword">int</span> j=left;<span class="hljs-comment">//j表示锚点值privot在数组中排第几</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left+<span class="hljs-number">1</span>;i&lt;=right;i++)    &#123;        <span class="hljs-keyword">if</span>(nums[i]&lt;privot)<span class="hljs-comment">//如果有值小于privot</span>        &#123;            j++;<span class="hljs-comment">//那么就让privot的排名上升一位</span>            swap(nums,j,i);<span class="hljs-comment">//交换的目的：把小于privot的值都放到左边</span>        &#125;    &#125;    <span class="hljs-comment">//遍历完区间[left,right]后可以得到，privot在数组中排序为j,所以交换锚点的位置，从left到j</span>    swap(nums,left,j);<span class="hljs-comment">//遍历完毕后，把锚点和j位置交换一下，j位置表示锚点privot在这个数组中的排序</span>    quickSort(nums,left,j-<span class="hljs-number">1</span>);    quickSort(nums,j+<span class="hljs-number">1</span>,right);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序</title>
    <link href="/2020/06/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>把第一个元素看成是一个有序序列，然后后面的元素看成是无序序列，从这个无序序列中依次取出元素，<strong>选择</strong>应该插到前面有序序列的哪个位置</p><p><strong>注意</strong>：插入排序，不是一次就直接找到了位置，插入，而是要一个一个比较值，交换值，最后才可以找到正确位置。</p><p><strong>思路</strong>：对于无序序列的值A，在有序序列中找到一个比他的大的值就和他交换，最后停留的位置就是值A此时在有序序列中的位置。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">choseSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=nums.length;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> index=-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)<span class="hljs-comment">//无序数组的下标</span>        &#123;            res=nums[i];            index=i;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--)<span class="hljs-comment">//从后往前扫描有序数组</span>            &#123;                <span class="hljs-keyword">if</span>(nums[i]&lt;nums[j])<span class="hljs-comment">//如果无序数组的值，小于有序数组的值，说明就找到了插入位置</span>                &#123;                    swap(nums,i,j);                &#125;                <span class="hljs-keyword">else</span><span class="hljs-comment">//如果无序数组的值，大于有序数组，说明此时已经到了正确位置</span>                    <span class="hljs-keyword">break</span>;            &#125;        &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">     </span>&#123;         <span class="hljs-keyword">int</span> temp=nums[i];         nums[i]=nums[j];         nums[j]=temp;     &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/2020/06/10/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/10/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序就是选择最大值，放到最后/最前面。</p><p>在未排序的序列中找打最大值，然后将其放到最后</p><p>再从剩余的未排序序列中找到次大值，放到倒数第二个位置</p><p>依次类推，直到结束</p><p>Java代码如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=nums.length;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> index=-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len-<span class="hljs-number">1</span>;i++)<span class="hljs-comment">//剩余未排序数组的长度</span>        &#123;            res=nums[<span class="hljs-number">0</span>];            index=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len-i;j++)<span class="hljs-comment">//在剩余未排序序列中，选出剩余未排序序列的最大值</span>            &#123;                <span class="hljs-keyword">if</span>(nums[j]&gt;res)                &#123;                    res=nums[j];                    index=j;                &#125;            &#125;            swap(nums,index,len-<span class="hljs-number">1</span>-i);        &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">     </span>&#123;         <span class="hljs-keyword">int</span> temp=nums[i];         nums[i]=nums[j];         nums[j]=temp;     &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/2020/06/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序：给定数组nums，比较元素nums[i]和nums[i+1],如果nums[i+1] &lt; nums[i]就交换两者，从第一个元素开始，两两比较，这样一轮下来，最后一个元素一定是最大值，第二轮再从第一个元素开始，倒数第二个元素截止，第二轮结束后，倒数第二个元素一定是这一轮中的最大值，这样不断的把最大值选出来，放到最后的排序算法就是冒泡排序</p><p>java代码如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=nums.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;len--)<span class="hljs-comment">//剩余未排序数组的长度</span>        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len-<span class="hljs-number">1</span>-i;j++)<span class="hljs-comment">//可以进行比较的数组下标范围</span>            &#123;                <span class="hljs-keyword">if</span>(nums[j+<span class="hljs-number">1</span>]&lt;nums[j])                    swap(nums,j,j+<span class="hljs-number">1</span>);            &#125;        &#125;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">     </span>&#123;         <span class="hljs-keyword">int</span> temp=nums[i];         nums[i]=nums[j];         nums[j]=temp;     &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode114-二叉树展开为链表</title>
    <link href="/2020/06/10/LeetCode114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/06/10/LeetCode114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode114-二叉树展开为链表"><a href="#LeetCode114-二叉树展开为链表" class="headerlink" title="LeetCode114-二叉树展开为链表"></a>LeetCode114-二叉树展开为链表</h1><p>思路：二叉树转成链表，这个链表要求把左节点放到根节点后面，右节点的前面，转换过程先把右子树转成链表，再转左子树。</p><p>对于每一个节点的转换，需要记录上一次操作返回的根节点，因为当前结点的下一个结点就是上次的根节点。</p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    TreeNode prev=<span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        flatten(root.right);        flatten(root.left);        root.right=prev;        root.left=<span class="hljs-keyword">null</span>;        prev=root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode617-合并二叉树</title>
    <link href="/2020/06/10/LeetCode617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/06/10/LeetCode617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode617-合并二叉树"><a href="#LeetCode617-合并二叉树" class="headerlink" title="LeetCode617 合并二叉树"></a>LeetCode617 合并二叉树</h1><p>思路：给定两颗二叉树A和B，在A的基础上合并成一颗新树，遍历A的每一个节点。如果A和B的节点都为空，就返回空，如果A，B只有一个不为空，返回不会空的那个结点，如果两者都不为空，返回两个节点之和</p><p>代码</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode t1, TreeNode t2)</span> </span>&#123;                <span class="hljs-keyword">if</span>(t1==<span class="hljs-keyword">null</span> &amp;&amp; t2==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t1==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> t2;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t2==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> t1;        t1.val+=t2.val;        t1.left=mergeTrees(t1.left,t2.left);        t1.right=mergeTrees(t1.right,t2.right);        <span class="hljs-keyword">return</span> t1;    &#125;   &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode104-求二叉树的最大高度</title>
    <link href="/2020/06/10/LeetCode104-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/"/>
    <url>/2020/06/10/LeetCode104-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode104-求二叉树的最大高度"><a href="#LeetCode104-求二叉树的最大高度" class="headerlink" title="LeetCode104 求二叉树的最大高度"></a>LeetCode104 求二叉树的最大高度</h1><p>思路：二叉树的最大高度=max（左子树的最大高度，右子树的最大高度）+1，所以递归求解</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> dfs(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>)        &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> left=dfs(node.left);        <span class="hljs-keyword">int</span> right=dfs(node.right);        <span class="hljs-keyword">return</span> Math.max(left,right)+<span class="hljs-number">1</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode226-翻转二叉树</title>
    <link href="/2020/06/10/LeetCode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/06/10/LeetCode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode226-翻转二叉树"><a href="#LeetCode226-翻转二叉树" class="headerlink" title="LeetCode226 翻转二叉树"></a>LeetCode226 翻转二叉树</h1><p>思路：把节点放到队列，先把右子树放到节点，再把左子树放到节点，然后再生成二叉树</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        Queue&lt;TreeNode&gt; queue=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.offer(root);<span class="hljs-comment">//把根节点压入队列</span>        <span class="hljs-keyword">while</span>(!queue.isEmpty())        &#123;            TreeNode node=queue.poll();<span class="hljs-comment">//弹出队列的队首元素</span>            <span class="hljs-keyword">if</span>(node!=<span class="hljs-keyword">null</span>)<span class="hljs-comment">//依次遍历每一个节点</span>            &#123;                TreeNode left=node.left;<span class="hljs-comment">//记录节点的左节点</span>                TreeNode right=node.right;<span class="hljs-comment">//记录节点的右节点</span>                queue.offer(right);<span class="hljs-comment">//先压入右节点</span>                queue.offer(left);<span class="hljs-comment">//再压入左节点</span>                node.left=right;<span class="hljs-comment">//把节点的左右指向交换</span>                node.right=left;            &#125;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode654-最大二叉树</title>
    <link href="/2020/06/10/LeetCode654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/06/10/LeetCode654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode654-最大二叉树"><a href="#LeetCode654-最大二叉树" class="headerlink" title="LeetCode654 最大二叉树"></a>LeetCode654 最大二叉树</h1><p>题目：</p><pre><code class="hljs java">给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：二叉树的根是数组中的最大元素。左子树是通过数组中最大值左边部分构造出的最大二叉树。右子树是通过数组中最大值右边部分构造出的最大二叉树。通过给定的数组构建最大二叉树，并且输出这个树的根节点。</code></pre><p>思路：分治递归，先找到数组中元素的最大值，然后分成左右两部分，左边是左子树，右边是右子树，对于每一个子树，再进行分治递归</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">return</span> dfs(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>);            &#125;    <span class="hljs-function">TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(end&lt;start) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> index=start;        <span class="hljs-keyword">int</span> maxValue=nums[index];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start+<span class="hljs-number">1</span>;i&lt;=end;i++)        &#123;            <span class="hljs-keyword">if</span>(nums[i]&gt;maxValue)            &#123;                index=i;                maxValue=nums[index];            &#125;        &#125;        TreeNode node=<span class="hljs-keyword">new</span> TreeNode(nums[index]);        node.left=dfs(nums,start,index-<span class="hljs-number">1</span>);        node.right=dfs(nums,index+<span class="hljs-number">1</span>,end);        <span class="hljs-keyword">return</span> node;    &#125;        &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode101-判断二叉树是否对称</title>
    <link href="/2020/06/10/LeetCode101-%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0/"/>
    <url>/2020/06/10/LeetCode101-%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode101-判断二叉树是否对称"><a href="#LeetCode101-判断二叉树是否对称" class="headerlink" title="LeetCode101 判断二叉树是否对称"></a>LeetCode101 判断二叉树是否对称</h1><p>思路：二叉树对称指的是，要求每一个节点Node的左右子树要对称，而且左右子树的左右子树也要对称，即</p><pre><code class="hljs java">Node.left=Node.right;left.left=right.left;left.right=right.left;具体看下图</code></pre><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200610120726.png" srcset="/img/loading.gif" alt="image-20200610120720720"></p><p>递归求解每一个节点，如果有一个节点不满足上述条件，即返回true，这个二叉树不是对称二叉树</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> dfs(root.left,root.right);    &#125;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode left, TreeNode right)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(left==<span class="hljs-keyword">null</span> &amp;&amp; right==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(left ==<span class="hljs-keyword">null</span> || right ==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(left.val!=right.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> dfs(left.left,right.right) &amp;&amp; dfs(left.right,right.left);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode102-二叉树层序遍历</title>
    <link href="/2020/06/10/LeetCode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/06/10/LeetCode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-二叉树层序遍历"><a href="#LeetCode-二叉树层序遍历" class="headerlink" title="LeetCode 二叉树层序遍历"></a>LeetCode 二叉树层序遍历</h1><p>思路：用队列实现，把每一个节点都放到队列中去，遍历队列中每一个节点，把每一个节点的左右子树都加入到队列，然后再把这个结点出队，依次遍历直到队列为空</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; res=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;        Queue&lt;TreeNode&gt; queue=<span class="hljs-keyword">new</span> LinkedList();        queue.offer(root);        <span class="hljs-keyword">while</span>(!queue.isEmpty())        &#123;            <span class="hljs-keyword">int</span> size=queue.size();            List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)            &#123;                TreeNode node=queue.poll();                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-keyword">null</span>) queue.offer(node.left);                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-keyword">null</span>) queue.offer(node.right);                list.add(node.val);            &#125;            res.add(<span class="hljs-number">0</span>,list);        &#125;                <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode144-二叉树前序遍历</title>
    <link href="/2020/06/10/LeetCode144-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/06/10/LeetCode144-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode144-二叉树前序遍历"><a href="#LeetCode144-二叉树前序遍历" class="headerlink" title="LeetCode144 二叉树前序遍历"></a>LeetCode144 二叉树前序遍历</h1><p>套用模板即可</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; list;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        dfs(root);        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        list.add(node.val);        dfs(node.left);        dfs(node.right);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode94-二叉树中序遍历</title>
    <link href="/2020/06/10/LeetCode94-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/06/10/LeetCode94-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode94-二叉树中序遍历"><a href="#LeetCode94-二叉树中序遍历" class="headerlink" title="LeetCode94 二叉树中序遍历"></a>LeetCode94 二叉树中序遍历</h1><p>套用模板，递归求解</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; list;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        dfs(root);        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        dfs(node.left);        list.add(node.val);        dfs(node.right);    &#125;        &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode145-二叉树后序遍历</title>
    <link href="/2020/06/10/LeetCode145-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/06/10/LeetCode145-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode145-二叉树后续遍历"><a href="#LeetCode145-二叉树后续遍历" class="headerlink" title="LeetCode145 二叉树后续遍历"></a>LeetCode145 二叉树后续遍历</h1><p>后续遍历的顺序是：左节点–&gt;右节点–&gt;根节点，根节点最后一个遍历，套用一下模板即可</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; list;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        dfs(root);        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        dfs(node.left);        dfs(node.right);        list.add(node.val);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树遍历模板</title>
    <link href="/2020/06/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/"/>
    <url>/2020/06/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树遍历模板"><a href="#二叉树遍历模板" class="headerlink" title="二叉树遍历模板"></a>二叉树遍历模板</h1><p>模板来源于@labuladong</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-comment">// 前序遍历</span>    traverse(root.left)    <span class="hljs-comment">// 中序遍历</span>    traverse(root.right)    <span class="hljs-comment">// 后序遍历</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode106-从中序和后序遍历序列中构建二叉树</title>
    <link href="/2020/06/10/LeetCode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/06/10/LeetCode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode106-从中序和后序遍历序列中构建二叉树"><a href="#LeetCode106-从中序和后序遍历序列中构建二叉树" class="headerlink" title="LeetCode106 从中序和后序遍历序列中构建二叉树"></a>LeetCode106 从中序和后序遍历序列中构建二叉树</h1><p>先从后序遍历中得到根节点，得到根节点在中序遍历中的位置index，中序遍历序列中index左边的就是左子树，右边的就是右子树，然后递归求解左右子树即可<br><strong>难点</strong>：如何计算下一次后序遍历左子树根节点的位置（后序遍历根节点的下标-中序遍历根节点右边的子节点数量=下一次迭代的后序遍历根节点位置）<br>中序+后序构建二叉树：难点是计算左子树的位置。因为后序根节点的位置-1就是右子树的位置<br>中序+先序构建二叉树：难点是计算右子树的位置，因为先序根节点的位置+1就是左子树的位置。<br>当然这两种情况都要判断边界</p><p>java代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;        HashMap&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">int</span> length=postorder.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)        &#123;            map.put(inorder[i],i);        &#125;        <span class="hljs-keyword">return</span> help(inorder,postorder,<span class="hljs-number">0</span>,length-<span class="hljs-number">1</span>,length-<span class="hljs-number">1</span>,map);    &#125;    <span class="hljs-function">TreeNode <span class="hljs-title">help</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder, <span class="hljs-keyword">int</span> inStart, <span class="hljs-keyword">int</span> inEnd, <span class="hljs-keyword">int</span> postEnd, HashMap&lt;Integer,Integer&gt; map)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(postEnd&lt;<span class="hljs-number">0</span> || inStart&gt;inEnd) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> index=map.get(postorder[postEnd]);        TreeNode node=<span class="hljs-keyword">new</span> TreeNode(postorder[postEnd]);        node.left=help(inorder,postorder,inStart,index-<span class="hljs-number">1</span>,postEnd-(inEnd-index)-<span class="hljs-number">1</span>,map);        node.right=help(inorder,postorder,index+<span class="hljs-number">1</span>,inEnd,postEnd-<span class="hljs-number">1</span>,map);        <span class="hljs-keyword">return</span> node;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode105-从前序和中序遍历序列中构建二叉树</title>
    <link href="/2020/06/10/LeetCode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/06/10/LeetCode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode105-从前序和中序遍历中构建二叉树"><a href="#LeetCode105-从前序和中序遍历中构建二叉树" class="headerlink" title="LeetCode105 从前序和中序遍历中构建二叉树"></a>LeetCode105 从前序和中序遍历中构建二叉树</h1><p>前序遍历的顺序是：根结点–&gt;左节点–&gt;右节点</p><p>中序遍历的顺序是：左节点–&gt;根节点–&gt;右节点</p><p>后序遍历的顺序是：左节点–&gt;右节点–&gt;根节点</p><p>构建二叉树的核心是先确定根节点，题目给了前序遍历和中序遍历，想到前序遍历的第一个节点是根节点，所以可以从前序遍历中确认根节点root，然后去中序遍历中找到根节点的位置index，那么在中序遍历index左边的就是左子树，右边的就是右子树，然后再递归求解左右子树，便可成功构建二叉树</p><p>Java代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;        HashMap&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">int</span> length=postorder.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)        &#123;            map.put(inorder[i],i);        &#125;        <span class="hljs-keyword">return</span> help(inorder,postorder,<span class="hljs-number">0</span>,length-<span class="hljs-number">1</span>,length-<span class="hljs-number">1</span>,map);    &#125;    <span class="hljs-function">TreeNode <span class="hljs-title">help</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder, <span class="hljs-keyword">int</span> inStart, <span class="hljs-keyword">int</span> inEnd, <span class="hljs-keyword">int</span> postEnd, HashMap&lt;Integer,Integer&gt; map)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(postEnd&lt;<span class="hljs-number">0</span> || inStart&gt;inEnd) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> index=map.get(postorder[postEnd]);        TreeNode node=<span class="hljs-keyword">new</span> TreeNode(postorder[postEnd]);        node.left=help(inorder,postorder,inStart,index-<span class="hljs-number">1</span>,postEnd-(inEnd-index)-<span class="hljs-number">1</span>,map);        node.right=help(inorder,postorder,index+<span class="hljs-number">1</span>,inEnd,postEnd-<span class="hljs-number">1</span>,map);        <span class="hljs-keyword">return</span> node;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习-1</title>
    <link href="/2020/06/10/Spring%E5%AD%A6%E4%B9%A0-1/"/>
    <url>/2020/06/10/Spring%E5%AD%A6%E4%B9%A0-1/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring学习心得-01"><a href="#Spring学习心得-01" class="headerlink" title="Spring学习心得-01"></a>Spring学习心得-01</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>Spring的核心是IOC和AOP，IOC（Inversion of Control）中文是控制反转。</p><p>了解IOC前要先知道<strong>依赖倒置原则</strong>（Dependency Inversion Principle），即</p><blockquote><p>高层模块不应该依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象</p></blockquote><p>举例来形容一下什么是依赖倒置原则：假设我们要盖楼，先设计好房间，在设计好楼层，再设计好大楼结构。这里的依赖关系是：大楼依赖楼层、楼层依赖房间。假如业主对房间不满意，我们需要修改房间，那就需要修改楼层，修改完楼层，大楼结构也就需要修改。</p><p>那假如反一下呢？</p><p>我先设计好大楼结构，再去设计楼层，然后去设计房间。如果业主对房间不满意，那我只需要修改房间就可以。这样一来，依赖关系就倒置过来了：房间依赖楼层，楼层依赖大楼。这就是依赖倒置原则，把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。</p><p>IOC就是采用了依赖注入（<strong>Dependency Injection</strong>）来实现了依赖倒置原则。</p><p><strong>依赖注入</strong></p><blockquote><p>组件之间依赖关系由<strong>容器在运行期决定,</strong>即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台</p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200610103441.png" srcset="/img/loading.gif" alt="image-20200603115013451"></p><blockquote><p><strong>谁依赖于谁：</strong>当然是应用程序依赖于IoC容器，依赖是指容器负责创建Bean并管理Bean的生命周期；（当类与类之间有使用关系时就属于依赖关系）</p><p><strong>为什么需要依赖：</strong>应用程序需要IoC容器来提供对象需要的外部资源；</p><p><strong>谁注入谁：</strong>容器负责注入Bean的依赖资源，依赖资源可以是Bean、外部文件、常量数据等，在Java中都反映为对象，并且由容器负责组装Bean之间的依赖关系；</p><p><strong>此处的依赖是指**</strong>Bean<strong>**之间的依赖关系</strong>，<strong>可以认为是传统类与类之间的“关联”、“聚合”、“组合”关系</strong>。</p><p>为什么要应用依赖注入？</p><p> <strong>动态替换Bean</strong>依赖对象，程序更灵活：替换Bean依赖对象，无需修改源文件：应用依赖注入后，由于可以采用配置文件方式实现，从而能随时动态的替换Bean的依赖对象，无需修改java源文件；</p><p><strong>更好实践面向接口编程，代码更清晰：</strong>在Bean中只需指定依赖对象的接口，接口定义依赖对象完成的功能，通过容器注入依赖实现；</p><p><strong>更好实践优先使用对象组合，而不是类继承：</strong>因为IoC容器采用注入依赖，也就是<strong>组合对象</strong>，从而更好的实践对象组合。</p><p> 对象组合：Bean的功能由几个依赖Bean功能组合而成，组合具有动态性，可以方便的替换掉依赖Bean，从而改变Bean功能，而且增加了代码的复用性，降低了耦合性</p><p>来自参考资料1</p></blockquote><p>所以IOC就是不需要程序员自己去创建和维护对象，把创建对象的权利交给Spring，由Spring来管理维护对象。</p><p>控制反转这个词再细说一下：</p><p>控制：传统的Java开发都是程序员自己去new对象，程序员控制对象的创建，而IOC是由IOC容器去创建对象，由IOC控制对象的创建，IOC控制了外部资源的获取。</p><p>反转：一般的开发是程序员自己去获取依赖对象，而IOC是由容器来查找并注入依赖对象，对象只是被动的接受依赖对象</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603143635.png" srcset="/img/loading.gif" alt=""></p><p>IOC出现后：</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603143654.png" srcset="/img/loading.gif" alt="image-20200603143649919"></p><blockquote><p><strong>谁控制谁，控制什么：</strong>传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</p><p><strong>为何是反转，哪些方面反转了：</strong>有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。（来自参考资料1）</p></blockquote><p>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603113111.jpg" srcset="/img/loading.gif" alt="img"></p><h4 id="依赖资源注入方式"><a href="#依赖资源注入方式" class="headerlink" title="依赖资源注入方式"></a>依赖资源注入方式</h4><p>依赖：bean对象的创建依赖于容器</p><p>注入：bean对象中的所有属性，由容器来注入</p><p>xml文件的基本约束代码</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">&gt;</span>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;xsi:schemaLocation="http://www.springframework.org/schema/beans  https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>   <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>  <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-comment">&lt;!-- more bean definitions go here --&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></blockquote><h5 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h5><p>容器实例化Bean时注入那些依赖，通过在在Bean定义中指定构造器参数进行注入依赖，构造器参数就是依赖。</p><p>注入方式：构造器方式、静态工厂、实例工厂</p><p>构造器注入(代码来自参考资料1)：</p><blockquote><p>1 根据参数索引注入</p><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello"</span> /&gt;</span>&gt;索引下标从0开始</code></pre><p>2 根据参数类型注入</p><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"java.lang.String"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello"</span> /&gt;</span>&gt;参数类型必须是全限定类名</code></pre><p>3 根据参数名称注入</p><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"15"</span> /&gt;</span>&gt;name表示需要匹配的参数名字</code></pre><p>使用方式：生成IOC容器，调用容器的getBean(下标/参数类型/参数名称,字节码)</p></blockquote><p>静态工厂注入</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byIndex"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定类名"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byType"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定类名"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"java.lang.String"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"2"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byName"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定类名"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"index"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>实例工厂注入</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"instanceFactory"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定类名"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byIndex"</span>  <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"instanceFactory"</span>  <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byType"</span>  <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"instanceFactory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"java.lang.String"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"2"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"byName"</span>  <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"instanceFactory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"newInstance"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"index"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注：静态工厂方式和实例工厂方式区别是实例工厂需要创建实例，然后通过实例调用方法返回bean</p><h5 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h5><p>setter注入，是通过在通过构造器、静态工厂或实例工厂实例好Bean后，通过调用Bean类的setter方法进行注入依赖，原类中要有getter()和setter()方法</p><p>setter注入方式</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"XX"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"要注入的值"</span>&gt;</span> 使用property标签，setXX(),name那里填写XX。如setName,那里就写Name&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"XX"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanid"</span>&gt;</span>：注入引用类型</code></pre><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.javass.spring.chapter3.HelloImpl4"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello World!"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"index"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注入常量</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Hello"</span>/&gt;</span></code></pre></blockquote><p>JavaBean本质就是一个POJO类，该类有以下限制：</p><blockquote><p><strong>有公共的无参构造器</strong></p><p><strong>属性为private访问级别</strong></p><p><strong>有getter和setter方法</strong></p></blockquote><h5 id="注入集合、数组和Map"><a href="#注入集合、数组和Map" class="headerlink" title="注入集合、数组和Map"></a>注入集合、数组和Map</h5><p>注入集合（List，Set）</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--注入List，使用list标签--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"listBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定名"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据名称来决定注入类中哪个list--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">list</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">"java.lang.String"</span>&gt;</span>  <span class="hljs-comment">&lt;!--value-type是list集合内的元素类型，默认是String，格式是全限定名--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--注入set，使用set标签--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"setBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定名"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据名称来决定注入类中哪个set--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">"java.lang.String"</span>&gt;</span>  <span class="hljs-comment">&lt;!--value-type是set集合内的元素类型，默认是String，格式是全限定名--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注入数组</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--使用array标签--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"arrayBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定名"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据名称来决定注入类中哪个array--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">array</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">"java.lang.String"</span>&gt;</span>  <span class="hljs-comment">&lt;!--value-type是set集合内的元素类型，默认是String，格式是全限定名--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注入Map</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--使用map标签--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"arrayBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定名"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据名称来决定注入类中哪个Map--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">key-type</span>=<span class="hljs-string">"全限定名"</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">"全限定名"</span>&gt;</span><span class="hljs-comment">&lt;!--默认是String类型--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">""</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">""</span>/&gt;</span><span class="hljs-comment">&lt;!--key和value是你想注入的键值对--&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注入Properties</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--使用props标签，注入java.util.Properties类型数据，键和值必须都是Srring类型数据--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"arrayBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"全限定名"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span>  <span class="hljs-comment">&lt;!--根据名称来决定注入中哪个Properties--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">props</span> <span class="hljs-attr">key-type</span>=<span class="hljs-string">"全限定名"</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">"全限定名"</span>&gt;</span><span class="hljs-comment">&lt;!--String类型--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">""</span>&gt;</span>"value值"<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>注入空值</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">""</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre></blockquote><p>注入其他Bean</p><blockquote><p>构造器注入</p><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--使用constructor-arg标签的ref属性来引用其他Bean--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">""</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanid"</span>/&gt;</span>&gt;<span class="hljs-comment">&lt;!--使用constructor-arg标签的子&lt;ref&gt;标签来引用其他Bean--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">""</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"beanid"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span></code></pre><p><strong>setter</strong>注入</p><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--第一种方式--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanid"</span>/&gt;</span>&gt;<span class="hljs-comment">&lt;!--第二种方式--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"values"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"beanid"</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre></blockquote><h5 id="P命名空间注入"><a href="#P命名空间注入" class="headerlink" title="P命名空间注入"></a><strong>P命名空间注入</strong></h5><blockquote><p>P就是propertity的缩写</p><p>P命名空间对应所有的属性注入</p><p>添加配置文件约束代码：xmlns:p=”<a href="http://www.springframework.org/schema/p&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/p&quot;</a></p><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"p-namespace"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.ExampleBean"</span></span><span class="hljs-tag">  <span class="hljs-attr">p:email</span>=<span class="hljs-string">"someone@somewhere.com"</span>/&gt;</span></code></pre></blockquote><h5 id="C命名空间注入"><a href="#C命名空间注入" class="headerlink" title="C命名空间注入"></a><strong>C命名空间注入</strong></h5><blockquote><p>c：就是constrctor-arg的缩写</p><p>c命名空间对应构造器注入</p><p>添加约束代码：xmlns:c=”<a href="http://www.springframework.org/schema/c&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/c&quot;</a></p><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--原来是这样实现构造器注入--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingOne"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"thingTwo"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanTwo"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"thingThree"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"beanThree"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"email"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"something@somewhere.com"</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-comment">&lt;!--c命名空间出来以后是这样实现的--&gt;</span>&gt;<span class="hljs-comment">&lt;!-- c-namespace declaration with argument names --&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x.y.ThingOne"</span> <span class="hljs-attr">c:thingTwo-ref</span>=<span class="hljs-string">"beanTwo"</span></span><span class="hljs-tag">  <span class="hljs-attr">c:thingThree-ref</span>=<span class="hljs-string">"beanThree"</span> <span class="hljs-attr">c:email</span>=<span class="hljs-string">"something@somewhere.com"</span>/&gt;</span></code></pre></blockquote><p>内部Bean</p><blockquote><p>内部Bean就是在<property>或<constructor-arg>内通过<bean>标签定义的Bean，该Bean不管是否指定id或name，该Bean都会有唯一的匿名标识符，而且不能指定别名，该内部Bean对其他外部Bean不可见</p></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603113111.jpg" srcset="/img/loading.gif" alt="img"></p><h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><blockquote><p>Spring提供“singleton”和“prototype”两种基本作用域，另外提供“request”、“session”、“global session”三种web作用域；</p></blockquote><p><strong>singleton</strong>（默认）</p><blockquote><p>指“singleton”作用域的Bean只会在每个Spring IoC容器中存在一个实例，而且其完整生命周期完全由Spring容器管理。对于所有获取该Bean的操作Spring容器将只返回同一个Bean。</p><p>Spring是注册表单例设计模式的实现，消除了编程式单例，而且对代码是非入侵式。</p><p>Spring不仅会缓存单例对象，Bean定义也是会缓存的，对于惰性初始化的对象是在首次使用时根据Bean定义创建并存放于单例缓存池。</p><p>注册表单例设计模式：先将需要单例的实例通过唯一键注册到注册表，然后通过键来获取单例</p><p>注意：Spring中单例模式指的是这种类型的bean在同一个容器中只存在一个共享实例，而GoF的单例模式指的是一个类加载器中只存在一个这种类型的实例</p></blockquote><p><strong>prototype</strong></p><blockquote><p>原型，指每次向Spring容器请求获取Bean都返回一个全新的Bean，相对于“singleton”来说就是不缓存Bean，每次都是一个根据Bean定义创建的全新Bean。</p><p>Spring不会缓存原型对象，而是根据Bean定义每次请求返回一个全新的Bean：</p><p>Spring中的原型和GoF中介绍的原型含义是不一样的：</p><p>GoF通过用原型实例指定创建对象的种类，而Spring容器用Bean定义指定创建对象的种类；</p><p>GoF通过拷贝这些原型创建新的对象，而Spring容器根据Bean定义创建新对象。</p><p>其相同地方都是根据某些东西创建新东西，而且GoF原型必须显示实现克隆操作，属于侵入式，而Spring容器只需配置即可，属于非侵入式。</p></blockquote><p><strong>Web应用中的作用域</strong></p><blockquote><p>在Web应用中，我们可能需要将数据存储到request、session、global session。因此Spring提供了三种Web作用域：request、session、globalSession。</p><p><strong>request</strong>作用域：表示每个请求需要容器创建一个全新Bean</p><p><strong>session</strong>作用域：表示每个会话需要容器创建一个全新Bean</p><p><strong>globalSession</strong>：类似于session作用域，只是其用于portlet环境的web应用</p></blockquote><h4 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h4><p>之前在xml中Bean的配置都是手动装配，</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cat"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>   <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">""</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"cat"</span>&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></blockquote><p>自动装配</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">"byName"</span>&gt;</span><span class="hljs-comment">&lt;!--byName会自动查找，和自己对象set方法后面对应的bean，弊端是名字相同会报错--&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">"byType"</span>&gt;</span><span class="hljs-comment">&lt;!--byName会自动查找，和自己对象属性类型相同的bean，弊端类型相同会报错--&gt;</span></code></pre><p>byName需要保证所有bean的id唯一，并且需要保证和注入的set属性的方法值相同</p><p>byType是需要保证所有bean的类型唯一，并且需要保证和注入的set属性的类型相同</p></blockquote><h4 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h4><p>使用注解需要加入一些支持</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">&gt;</span>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;xmlns:context="http://www.springframework.org/schema/context"&gt;xsi:schemaLocation="http://www.springframework.org/schema/beans  https://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  https://www.springframework.org/schema/context/spring-context.xsd"&gt;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></blockquote><p>使用了注解@Autowired：原来xml文件可以写成</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"XX"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">""</span>&gt;</span></code></pre><p>在java对应的类中加入注解@Autowired</p><p>@Autowired：可以直接在属性、set方法上使用。</p><p>使用@Autowired，可以不写set方法，@Autowired是通过byType来实现的，所以需要你这个属性在IOC容器中存在</p><p>@Autowired注解，默认是true，意思是不允许为null，如果修改为@Autowired(required=false)，意思是可以为null</p><p>如果有多个Bean对象时，Autowired通过byType都无法找到应该装配哪一个，需要搭配@Qualifier注解一起使用</p></blockquote><p>@Resource注解</p><blockquote><p>@Autowired是通过byType实现的</p><p>@Resource是通过byName/byType实现的，默认是byName，如果找不到就通过byType实现。</p><p>@Resource比@Autowired更强大</p></blockquote><p>@component注解：组件组件，搭配@V alue使用</p><blockquote><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"XX.XX"</span>&gt;</span><span class="hljs-comment">&lt;!--意思是会扫描XX.XX包下的所有组件--&gt;</span></code></pre><p>衍生注解：@Repository，@Service，@Controller，都是组件的意思</p><p>加上这些注解就表示这个类要被spring托管了，是Spring的一个组件了</p><p>这四个注解功能都是一样的，意思都是将某个类注册到Spring容器中，然后装配</p></blockquote><p><strong>xml用来管理bean，注解负责完成属性的注入</strong></p><h4 id="使用Java配置注解开发"><a href="#使用Java配置注解开发" class="headerlink" title="使用Java配置注解开发"></a>使用Java配置注解开发</h4><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200609183446.png" srcset="/img/loading.gif" alt="image-20200609183441950"></p><blockquote><p>@Configuration：表示这个类是一个配置类</p><p>注意如果使用了配置类，那么只能通过AnnotationConfig上下文获取IOC容器</p><pre><code class="hljs java">&gt;ApplicationContext context=<span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(xx<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&gt;User getUser=(User)context.getBean(<span class="hljs-string">"getUser"</span>);&gt;sout(getUser.getName);</code></pre></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603113111.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP：Aspect Oriented Programming，面向切面编程，核心原理是使用动态代理模式在方法执行前后或者出现异常时添加相关逻辑</p><p>AOP一般被用来解决一些系统交叉业务的织入，比如日志啦、事务。</p><p>比如我想在方法1、2、3中添加一个打印日志功能，那我就需要去修改方法1、2、3中的代码，添加日志功能。但这违法了设计原则中开闭原则（扩展开发，修改关闭）。</p><p>那怎么办？简单点，写一个子类，在子类中重写这三个方法，那假如方法要是多呢？都一个个重写？</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603120706.png" srcset="/img/loading.gif" alt="image-20200603120703141"></p><p>那能不能让这些方法在执行前（或者执行后）统一调用一个代码呢？如下图</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603121316.png" srcset="/img/loading.gif" alt=""></p><p>我们原来是在方法内部添加打印日志功能，AOP是在执行方法前添加日志功能（交叉业务），原因是AOP的底层是使用了动态代理技术，动态代理调用了原方法，AOP只不过是在在原方法的基础上新创建了一个方法，然后在新方法的内部添加功能，添加的功能代码也称之为增强代码。如下图</p><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603121649.png" srcset="/img/loading.gif" alt="image-20200603121645266"></p><p>AOP通过动态代理实现的，动态代理是在<strong>运行期间</strong>，生成一个代理对象</p><blockquote><p>静态代理是用户自己写代理对象，比如继承一个类，重写这个类中的方法</p><p>动态代理是在程序运行期，生成一个代理对象</p></blockquote><p>Spring AOP的动态代理，有分成两种：基于接口的动态代理和基于类的动态代理</p><p>基于接口的动态代理：如果要代理的对象，继承了某个接口，那么Spring AOP就会使用JDK Proxy创建代理对象</p><p>基于类的动态代理：如果要代理的对象没有继承接口，那么Spring AOP就会使用Cglib，生成一个被代理对象的子类，作为代理</p><h4 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h4><p>Advice（通知/增强）：就是你想要新增加的功能，比如打印日志。<strong>“干什么”</strong></p><p>Aspect（切面）：切面是通知和切点的结合。<strong>”在哪干和干什么集合“</strong></p><p>Joint point（连接点）：Spring允许使用Advice的地方，比如方法的前后，抛出异常，都可以是连接点。<strong>”在哪干“</strong></p><p>Pointcut（切点）：不是类中所有的方法都需要新增加一些功能，把需要新增加功能的方法集合起来就是切点，可以理解为连接点的集合。<strong>“在哪干的集合”</strong></p><p>introduction（引入）：允许我们向现有的类添加新方法属性，就是把切面用到了目标类中。“<strong>干什么</strong>”</p><p>Target（目标对象）：引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。“<strong>对谁干</strong>”</p><p>Weaving（织入）：把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时进行织入</p><h4 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h4><blockquote><ul><li><strong>前置通知（Before Advice</strong>）:在切入点选择的连接点处的方法之前执行的通知，该通知不影响正常程序执行流程（除非该通知抛出异常，该异常将中断当前方法链的执行而返回）。</li><li><strong>后置通知（After Advice</strong>）:在切入点选择的连接点处的方法之后执行的通知，包括如下类型的后置通知：</li><li><strong>后置返回通知（After returning Advice</strong>）:在切入点选择的连接点处的方法正常执行完毕时执行的通知，必须是连接点处的方法没抛出任何异常正常返回时才调用后置通知。</li><li><strong>后置异常通知（After throwing Advice）</strong>: 在切入点选择的连接点处的方法抛出异常返回时执行的通知，必须是连接点处的方法抛出任何异常返回时才调用异常通知。</li><li><strong>后置最终通知（After finally Advice</strong>）: 在切入点选择的连接点处的方法返回时执行的通知，不管抛没抛出异常都执行，类似于Java中的finally块。</li><li><strong>环绕通知（Around Advices**</strong>）：环绕着在切入点选择的连接点处的方法所执行的通知，环绕通知可以在方法调用之前和之后自定义任何行为，并且可以决定是否执行连接点处的方法、替换返回值、抛出异常等等。</li></ul></blockquote><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200603185338.JPG" srcset="/img/loading.gif" alt="img"></p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>Spring中使用到的设计模式</p><h5 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h5><p>BeanFactory</p><h5 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h5><p>FactoryBean接口</p><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>getSingleton</p><h5 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h5><p>SpringMVC中的适配器HandlerAdatper</p><h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><p>Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator</p><h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><p>AOP底层，就是动态代理模式的实现</p><h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><p>spring的事件驱动模型使用的是 观察者模式 ，Spring中Observer模式常用的地方是listener的实现</p><h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><p>Spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了 Resource 接口来访问底层资源。</p><h5 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h5><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>Spring IOC</p><p><a href="https://www.iteye.com/category/206533?page=2" target="_blank" rel="noopener">https://www.iteye.com/category/206533?page=2</a> （这个系列都是精华）</p><p>Spring AOP术语理解：<a href="https://blog.csdn.net/changudeng1992/article/details/80625134" target="_blank" rel="noopener">https://blog.csdn.net/changudeng1992/article/details/80625134</a></p>]]></content>
    
    
    <categories>
      
      <category>SSM</category>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
