<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>简历问题 - 郭寰宇</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>郭寰宇的个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-06-28 08:30">
      2020年6月28日 早上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      97
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="Java语法"><a href="#Java语法" class="headerlink" title="Java语法"></a>Java语法</h3><h3 id="设计模式（15-23）"><a href="#设计模式（15-23）" class="headerlink" title="设计模式（15/23）"></a>设计模式（15/23）</h3><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><blockquote>
<p>开闭原则、单一职责原则、里氏替换原则、依赖倒置原则、迪米特原则、接口隔离原则、组合原则</p>
</blockquote>
<p>设计模式分类：创建型、结构型、行为型</p>
<h4 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h4><p>解释：省去New的过程</p>
<blockquote>
<p>单例、原型、工厂方法、抽象工厂、建造者</p>
</blockquote>
<h5 id="DCL单例"><a href="#DCL单例" class="headerlink" title="DCL单例"></a>DCL单例</h5><pre><code class="hljs java"><span class="hljs-comment">//单例四大原则：构造私有、静态方法或者枚举返回实例、确保实例只有一个、反序列时不会重构对象</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton singleton=<span class="hljs-keyword">null</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span>(singleton==<span class="hljs-keyword">null</span>)
        &#123;
            <span class="hljs-keyword">synchronized</span> (Singleton<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class">            </span>&#123;
                <span class="hljs-keyword">if</span>(singleton==<span class="hljs-keyword">null</span>)
                &#123;
                    singleton=<span class="hljs-keyword">new</span> Singleton();
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> singleton;
    &#125;
&#125;</code></pre>

<h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><p>根据一个已经创建好的实例，不断的克隆出其他对象，省去了复杂的new过程。</p>
<p>但是原型的克隆分为浅克隆和深克隆，Object类的Clone方法为浅克隆，要想实现深克隆必须我们自己动手实现</p>
<pre><code class="hljs java"><span class="hljs-comment">//原型设计模式的设计原则：实现Cloneable接口，重写Clone方法</span>
<span class="hljs-comment">//浅克隆，我们只需要重写Clone方法，但是方法内部方法体不需要改变</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prototype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Prototype</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age,String name)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>.age=age;
        <span class="hljs-keyword">this</span>.name=name;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Prototype&#123;"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'&#125;'</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();
    &#125;
&#125;

<span class="hljs-comment">//深克隆，需要重写Clone方法的方法体</span>
<span class="hljs-meta">@Date</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrototypeDeep</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;
    <span class="hljs-keyword">private</span> Date date;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrototypeDeep</span><span class="hljs-params">(Date date, String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.date = date;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"PrototypeDeep&#123;"</span> +
                <span class="hljs-string">"date="</span> + date +
                <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'&#125;'</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> PrototypeDeep <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        PrototypeDeep prototypeDeep= (PrototypeDeep) <span class="hljs-keyword">super</span>.clone();
        Date cloneDate= (Date) <span class="hljs-keyword">this</span>.date.clone();
        prototypeDeep.date=cloneDate;
        <span class="hljs-keyword">return</span> prototypeDeep;
    &#125;
&#125;</code></pre>

<h5 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h5><p>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”</p>
<pre><code class="hljs java"><span class="hljs-comment">//简单工厂，不属于设计模式，但是这里引入简单工厂是为了后面铺垫，简单工厂只有一个工厂类</span>
<span class="hljs-comment">//缺点是，如果要增加新的产品，就需要修改源代码</span>
<span class="hljs-comment">//产品接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProductA</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">introduce</span><span class="hljs-params">()</span></span>;
&#125;
<span class="hljs-comment">//实现类</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Buick</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProductA</span></span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">introduce</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"this is Buick"</span>);
    &#125;
&#125;
<span class="hljs-comment">//实现类</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WuLing</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProductA</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">introduce</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"this is WuLing"</span>);
    &#125;
&#125;
<span class="hljs-comment">//简单工厂</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> ProductA <span class="hljs-title">Factory</span><span class="hljs-params">(String product)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span>(product.equals(<span class="hljs-string">"Buick"</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Buick();
        <span class="hljs-keyword">if</span> (product.equals(<span class="hljs-string">"WuLing"</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WuLing();<span class="hljs-comment">//如果想要增加新产品，就需要修改源代码</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
&#125;</code></pre>

<h5 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h5><p>定义一个<strong>创建产品对象的工厂接口</strong>，将产品对象的实际创建工作推迟到<strong>具体子工厂类当中</strong>。这满足创建型模式中所要求的“<strong>创建与使用相分离</strong>”的特点</p>
<p>“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p>
<p>工厂方法模式的主要优点有：</p>
<ul>
<li><p>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</p>
</li>
<li><p>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</p>
</li>
</ul>
<p>缺点是：每增加一个<strong>产品</strong>就要增加一个具体<strong>产品类</strong>和一个对应的<strong>具体工厂类</strong>，这增加了系统的复杂度。</p>
<pre><code class="hljs java"><span class="hljs-comment">//抽象工厂接口</span>
<span class="hljs-keyword">package</span> com.guo.factory;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FactoryMethod</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">//工厂A，生产产品A</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryMethod</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Buick();
    &#125;
&#125;
<span class="hljs-comment">//工厂B，生产产品B</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryMethod</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WuLing();
    &#125;
&#125;
<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        FactoryA factoryA=<span class="hljs-keyword">new</span> FactoryA();
        FactoryB factoryB=<span class="hljs-keyword">new</span> FactoryB();
        factoryA.createProduct().introduce();
        factoryB.createProduct().introduce();
    &#125;
&#125;</code></pre>

<h5 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h5><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<p>结构为：抽象产品、抽象工厂、具体产品、具体工厂</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200628095822.png" srcset="/img/loading.gif" alt="image-20200628095817985"></p>
<p>使用抽象工厂模式一般要满足以下条件。</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。<br>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</li>
</ul>
<p>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</p>
<p>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</p>
<p>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>
<p>按照上面的图片来写一个抽象工厂设计模式代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//手机接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Phone</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>;
&#125;
<span class="hljs-comment">//电脑接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Computer</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">network</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">//手机实现类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiPhone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Phone</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"this is Mi Phone"</span>);
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuaWeiPhone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Phone</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"this is Hua Wei phone"</span>);
    &#125;
&#125;


<span class="hljs-comment">//电脑实现类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiComputer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Computer</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">network</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"this is Mi Computer"</span>);
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuaWeiComputer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Computer</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">network</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"this is HuaWei Computer"</span>);
    &#125;
&#125;
<span class="hljs-comment">//小米工厂</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Phone <span class="hljs-title">createPhone</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MiPhone();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Computer <span class="hljs-title">createComputer</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MiComputer();
    &#125;
&#125;
<span class="hljs-comment">//华为工厂</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuaWeiFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Phone <span class="hljs-title">createPhone</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HuaWeiPhone();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Computer <span class="hljs-title">createComputer</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HuaWeiComputer();
    &#125;
&#125;

<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        MiFactory miFactory=<span class="hljs-keyword">new</span> MiFactory();
        HuaWeiFactory huaWeiFactory=<span class="hljs-keyword">new</span> HuaWeiFactory();
        miFactory.createComputer().network();
        miFactory.createPhone().call();
        huaWeiFactory.createComputer().network();
        huaWeiFactory.createPhone().call();
    &#125;
&#125;</code></pre>

<h5 id="建造者"><a href="#建造者" class="headerlink" title="建造者"></a>建造者</h5><p>买汽车，不需要管汽车零件的生产步骤，只需要去4S店提车就可以，每一个车由很多部件构成，部件可以灵活选择，组织部件的顺序也可以灵活选择，这类产品的创建无法用工厂模式描述，建造者模式就是用来描述这类产品的创建</p>
<p>定义：它是将<strong>一个复杂的对象分解为多个简单的对象</strong>，然后一步一步构建而成。它将<strong>变与不变相分离</strong>，即产品的<strong>组成部分是不变的</strong>，但<strong>每一部分是可以灵活选择的</strong>。</p>
<p>组成：</p>
<p>产品角色：包含多个组件</p>
<p>抽象建造者：包含创建产品各个组件的抽象方法的接口</p>
<p>具体建造者：实现接口，完成创建各个组件的方法</p>
<p>指挥者：按照一定顺序调用建造者的方法</p>
<pre><code class="hljs java"><span class="hljs-comment">//产品</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;
    <span class="hljs-keyword">public</span> String productA;
    <span class="hljs-keyword">public</span> String productB;
    <span class="hljs-keyword">public</span> String productC;

&#125;
<span class="hljs-comment">//抽象建造者</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AbstractBuild</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createProductA</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createProductB</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createProductC</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">getProduct</span><span class="hljs-params">()</span></span>;
&#125;



<span class="hljs-comment">//具体建造者</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActualBuild</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractBuild</span></span>&#123;
    Product product;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">getProduct</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> product=<span class="hljs-keyword">new</span> Product();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createProductA</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"创建产品A"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createProductB</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"创建产品B"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createProductC</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"创建产品C"</span>);
    &#125;
&#125;
<span class="hljs-comment">//指挥者</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> </span>&#123;
    ActualBuild actualBuild;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Director</span><span class="hljs-params">(ActualBuild actualBuild)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.actualBuild=actualBuild;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        actualBuild.createProductA();
        actualBuild.createProductB();
        actualBuild.createProductC();
        <span class="hljs-keyword">return</span> actualBuild.product;
    &#125;
&#125;

<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        ActualBuild actualBuild=<span class="hljs-keyword">new</span> ActualBuild();
        Director director=<span class="hljs-keyword">new</span> Director(actualBuild);
        director.createProduct();
    &#125;
&#125;</code></pre>

<h4 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h4><p>解释：将<strong>类和对象</strong>结合在一起成为一个更大的结构。分为类结构型和对象结构型模式。</p>
<p>​    类结构模型关心<strong>类的组合</strong>，由多个类可以组成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系；</p>
<p>​    对象结构型模式<strong>关心类与对象的组合</strong>，通过<strong>组合关系</strong>使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。根据“<strong>组合复用原则</strong>”，在系统中尽量使用组合关系来替代继承关系，因此大部分结构型模式都是对象结构型模式</p>
<blockquote>
<p>代理、适配器、桥接、装饰、享元、外观、组合</p>
</blockquote>
<h5 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h5><p>定义</p>
<blockquote>
<p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，<strong>访问对象</strong>不适合或者<strong>不能直接引用目标对象</strong>，<strong>代理对象作为访问对象和目标对象之间的中介。</strong></p>
</blockquote>
<p>你不想上课，找人替你去上课，那个人就是代理。</p>
<p>优点</p>
<blockquote>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>
</ul>
</blockquote>
<p>缺点</p>
<blockquote>
<ul>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度</li>
</ul>
</blockquote>
<p>组成</p>
<blockquote>
<p>抽象主题类：可以是接口也可以是抽象类，用来进行业务定义</p>
<p>真实主题类（被代理类）：用来实现真正的业务逻辑</p>
<p>代理类：它负责控制对真实主题类访问的控制，在真实主题类中的方法上实现一些增强功能</p>
<p>客户端：访问代理类实现某些业务</p>
</blockquote>
<h6 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h6><pre><code class="hljs java"><span class="hljs-comment">//静态代理，代理类实现增加功能</span>
<span class="hljs-comment">//下面以租房为例，中介是搭理，房东是真实角色，两人共同的业务是收房租</span>
<span class="hljs-comment">//接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Rent</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">price</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">//真实主题</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Landlord</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Rent</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"房屋价格是XXX"</span>);
    &#125;
&#125;
<span class="hljs-comment">//代理主题</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Rent</span></span>&#123;
    <span class="hljs-keyword">private</span> Landlord landlord;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StaticProxy</span><span class="hljs-params">(Landlord landlord)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.landlord = landlord;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"代理类实现XXXXX功能"</span>);
        landlord.price();
    &#125;
&#125;
<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        Landlord landlord=<span class="hljs-keyword">new</span> Landlord();
        StaticProxy staticProxy=<span class="hljs-keyword">new</span> StaticProxy(landlord);
        staticProxy.price();
    &#125;
&#125;</code></pre>

<h6 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h6><p>静态代理缺点是每一个真实对象都要生成一个代理对象，代码量翻倍</p>
<pre><code class="hljs java"><span class="hljs-comment">//实现一个代理类，然后从动态的生成代理对象</span>
<span class="hljs-comment">//代理类，Rent接口和Host类在上面的静态代理类中已经定义了，所以这里省略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;
    <span class="hljs-keyword">public</span> Rent rent;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Rent <span class="hljs-title">getRent</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> rent;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRent</span><span class="hljs-params">(Rent rent)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.rent = rent;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span>  Proxy.newProxyInstance(<span class="hljs-keyword">this</span>.getClass().getClassLoader(),rent.getClass().getInterfaces(),<span class="hljs-keyword">this</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
        Object invoke = method.invoke(rent, args);
        <span class="hljs-keyword">return</span> invoke;
    &#125;
&#125;

<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        Landlord landlord=<span class="hljs-keyword">new</span> Landlord();
        DynamicProxy dynamicProxy=<span class="hljs-keyword">new</span> DynamicProxy();
        dynamicProxy.setRent(landlord);
        Rent proxy = (Rent) dynamicProxy.getProxy();
        proxy.price();
    &#125;
&#125;</code></pre>

<h5 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h5><p>定义：<strong>将一个类的接口转换成客户希望的另外一个接口</strong>，<strong>使得原本由于接口不兼容而不能一起工作的那些类能一起工作</strong>。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<p>优点</p>
<blockquote>
<ul>
<li>客户端通过适配器可以透明地调用目标接口。</li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>
</ul>
</blockquote>
<p>缺点：</p>
<p>对类适配器来说，更换适配器的实现过程比较复杂</p>
<p>结构组成</p>
<blockquote>
<p>距离：去美国出差，手机没电了，但是只带了一个<strong>中国220V标准电压的充电头</strong>，美国插座是<strong>240V标准电压</strong>，所以需要一个<strong>转换头</strong>，把240V的交流电转成220V的，这样才可以给手机充电。这个过程中，目标就是220V接口，适配者类就是240V接口，适配器类就是转换头。</p>
<ol>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ol>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//目标接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Target</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;

&#125;

<span class="hljs-comment">//适配者------被适配的类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">"被适配者的方法---220V"</span>);
    &#125;
&#125;

<span class="hljs-comment">//适配器-----将被适配的类转成需要的类。继承被适配者、实现目标接口，在重写的方法中调用父类方法</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;
        function();
    &#125;
&#125;</code></pre>

<h5 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h5><p>比如手机有很多品牌，每一个品牌又有不同的内存，如果我们设计手机，有两种方案，一种是一个一个设计，比如小米4G、小米8G、华为4G、华为8G等，另外一种方案是：把手机品牌和手机内存分开设计，然后组合两者。这样降低了两者的耦合、也减少了代码量</p>
<p>定义</p>
<blockquote>
<p><strong>将抽象与实现分离，使它们可以独立变化</strong>。它是用<strong>组合关系代替继承关系来实现</strong>，从而降低了抽象和实现这两个可变维度的耦合度</p>
</blockquote>
<p>优点</p>
<blockquote>
<ul>
<li>由于抽象与实现分离，所以扩展能力强；</li>
<li>其实现细节对客户透明。</li>
</ul>
</blockquote>
<p>缺点</p>
<blockquote>
<p>由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度</p>
</blockquote>
<p>组成</p>
<blockquote>
<p>抽象类：手机抽象类，包含一个对实现化角色的引用</p>
<p>扩展抽象类：具体的品牌，小米、华为。实现抽象类中的业务方法，通过组合来调用实现类接口中的业务方法</p>
<p>实现类接口：内存。定义实现化角色的接口，光扩展抽象化角色调用</p>
<p>具体实现类：具体的内存型号，给出具体实现</p>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//抽象类</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;
    <span class="hljs-keyword">public</span> Memory memory;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemory</span><span class="hljs-params">(Memory memory)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>.memory=memory;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span></span>;

&#125;
<span class="hljs-comment">//扩展抽象类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Phone</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"Mi Phone memory:"</span>);
        memory.MemorySize();
        System.out.println(<span class="hljs-string">"======="</span>);
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuaWeiPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Phone</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"Hua Wei memory size:"</span>);
        memory.MemorySize();
    &#125;
&#125;

<span class="hljs-comment">//扩展类接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Memory</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MemorySize</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">//具体实现类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memory4G</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Memory</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MemorySize</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"4G内存"</span>);
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memory8G</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Memory</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MemorySize</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"8G内存"</span>);
    &#125;
&#125;
<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        Memory memory4G=<span class="hljs-keyword">new</span> Memory4G();
        Memory memory8G=<span class="hljs-keyword">new</span> Memory8G();
        Phone phone1=<span class="hljs-keyword">new</span> MiPhone();
        Phone phone2=<span class="hljs-keyword">new</span> HuaWeiPhone();
        phone1.setMemory(memory4G);
        phone2.setMemory(memory8G);
        phone1.info();
        phone2.info();
    &#125;
&#125;</code></pre>



<h5 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h5><p>去吃饭，你可以在面的基础上不断加料，这样就有了：牛肉面、鸡蛋牛肉面、番茄鸡蛋牛肉面等，也可以在米饭的基础上加牛肉、鸡蛋、蔬菜等配料</p>
<p>定义</p>
<blockquote>
<p>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来<strong>创建一个包装对象（即装饰对象）来包裹真实对象</strong>，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标</p>
</blockquote>
<p>组成</p>
<blockquote>
<ol>
<li><p>抽象被装饰者（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。——面的抽象接口</p>
</li>
<li><p>具体被装饰者（Concrete  Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。——具体的面：牛肉面、鸡蛋面等</p>
</li>
<li><p>抽象装饰者（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。—-各种料</p>
</li>
<li><p>具体装饰者（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。—-具体的料：鸡蛋、牛肉、蔬菜等</p>
</li>
</ol>
<p>要点：</p>
<p>  1 多种具体被装饰者（主体类）抽象出一个抽象被装饰类，后面通过多态，动态传递具体对象。</p>
<p>  2 抽象装饰类<strong>继承</strong>抽象被装饰者（保持接口）；要求传入被装饰者（使用父类应用、protected修饰）；</p>
<p>  3 多种具体装饰者抽象出一个抽象装饰类。</p>
<p>  4 具体装饰者中，可以添加新方法，可以重写方法；需要使用被装饰者方法的地方用传入的被装饰者引用。</p>
</blockquote>
<p>缺点</p>
<blockquote>
<p>装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//以吃面为例，普通面、牛肉面、鸡蛋牛肉面、蔬菜鸡蛋牛肉面，牛肉米饭、鸡蛋米饭</span>
<span class="hljs-comment">//抽象父类---食物</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">//实现类---面条</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Noodle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"面条"</span>);
    &#125;
&#125;
<span class="hljs-comment">//实现类----米饭</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"米饭"</span>);
    &#125;
&#125;
<span class="hljs-comment">//抽象装饰者类</span>
<span class="hljs-comment">/*</span>
<span class="hljs-comment">1.抽象装饰者类中继承该抽象类以保持接口规范</span>
<span class="hljs-comment">2.包含该抽象类的引用以通过多态的方式对多种被装饰者类进行装饰。</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span>&#123;
    <span class="hljs-keyword">protected</span> Food food;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Decorator</span><span class="hljs-params">(Food food)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.food = food;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> food.cal();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        food.display();
    &#125;
&#125;
<span class="hljs-comment">//具体装饰者类---牛肉</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeefDecoractor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decorator</span></span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BeefDecoractor</span><span class="hljs-params">(Food food)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(food);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.cal()+<span class="hljs-number">10</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">super</span>.display();
        System.out.println(<span class="hljs-string">"+牛肉"</span>);
    &#125;
&#125;

<span class="hljs-comment">//具体装饰者类---鸡蛋</span>
<span class="hljs-comment">//继承抽象的被装饰者类，并实现其中的抽象方法。</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EggDecoractor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decorator</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EggDecoractor</span><span class="hljs-params">(Food food)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(food);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.cal()+<span class="hljs-number">2</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">super</span>.display();
        System.out.println(<span class="hljs-string">"+鸡蛋"</span>);
    &#125;
&#125;
<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        Food food=<span class="hljs-keyword">new</span> Noodle();
        Decorator beefDecoractor=<span class="hljs-keyword">new</span> BeefDecoractor(<span class="hljs-keyword">new</span> EggDecoractor(<span class="hljs-keyword">new</span> BeefDecoractor(food)));<span class="hljs-comment">//面里面加两份牛肉，一份鸡蛋</span>
        System.out.println(beefDecoractor.cal());

    &#125;
&#125;</code></pre>

<p>类图：</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200628145900.png" srcset="/img/loading.gif" alt="image-20200628145855384"></p>
<h5 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h5><blockquote>
<p>是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>
<p>外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。</p>
<ol>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
</ol>
<p>外观（Facade）模式的主要缺点如下。</p>
<ol>
<li>不能很好地限制客户使用子系统类。</li>
<li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
</ol>
</blockquote>
<h5 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h5><blockquote>
<p>组合（Composite）模式的定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p>
<p>组合模式的主要优点有：</p>
<ol>
<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li>
<li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li>
</ol>
<p>其主要缺点是：</p>
<ol>
<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li>
<li>不容易限制容器中的构件；</li>
<li>不容易用继承的方法来增加构件的新功能；</li>
</ol>
</blockquote>
<h5 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h5><blockquote>
<p>运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
<p>享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p>
<p>其主要缺点是：</p>
<ol>
<li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li>
<li>读取享元模式的外部状态会使得运行时间稍微变长。</li>
</ol>
</blockquote>
<h4 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h4><p>解释描述程序在运行时复杂的流程控制，即描述<strong>多个类或对象之间怎样相互协作</strong>共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<blockquote>
<p>模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器</p>
</blockquote>
<h5 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h5><p>定义</p>
<blockquote>
<p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p>
</blockquote>
<p>优点</p>
<blockquote>
<ol>
<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在父类中提取了公共的部分代码，便于代码复用。</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
<li>我们在定义行为时候都是由父类去定义，然后子类去实现即可。</li>
</ol>
</blockquote>
<p>缺点</p>
<blockquote>
<ol>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
</ol>
</blockquote>
<p>组成</p>
<blockquote>
<p>(1) 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。</p>
<p>① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p>
<p>② 基本方法：是整个算法中的一个步骤，包含以下几种类型。</p>
<ul>
<li>抽象方法：在抽象类中申明，由具体子类实现。</li>
<li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li>
<li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li>
</ul>
<p>(2) 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。</p>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//以做饭为例，小明和小红做饭，同样一道菜，相同的步骤，俩人做出来的菜味道就是不一样，因为每一个步骤的执行效果不同</span>
<span class="hljs-comment">//抽象类-----这道菜的正常执行步骤是1、2、3、4</span>
<span class="hljs-keyword">package</span> com.guo.TemplatePattern;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cook</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step3</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step4</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">executeStep3</span><span class="hljs-params">()</span><span class="hljs-comment">//钩子函数，由子类决定某一个函数是否要执行</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>.step1();
        <span class="hljs-keyword">this</span>.step2();
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.executeStep3())
        &#123;
            <span class="hljs-keyword">this</span>.step3();
        &#125;
        <span class="hljs-keyword">this</span>.step4();
    &#125;
&#125;


<span class="hljs-comment">//子类----XM做饭</span>
<span class="hljs-keyword">package</span> com.guo.TemplatePattern;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XMCook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cook</span></span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> executeStep3=<span class="hljs-keyword">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExecuteStep3</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> executeStep3)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.executeStep3 = executeStep3;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step1</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XM--1"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XM--2"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step3</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XM--3"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step4</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XM--4"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">executeStep3</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.executeStep3;
    &#125;
&#125;

<span class="hljs-comment">//子类---XH做饭</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XHCook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cook</span></span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> executeStep3=<span class="hljs-keyword">true</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExecuteStep3</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> executeStep3)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.executeStep3 = executeStep3;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step1</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XH=====1"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XH=====2"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step3</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XH=====3"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step4</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XH=====4"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">executeStep3</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.executeStep3();
    &#125;
&#125;

<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        Cook xmCook=<span class="hljs-keyword">new</span> XMCook();
        xmCook.cook();
        XMCook xmCook=<span class="hljs-keyword">new</span> XMCook();
        xmCook.setExecuteStep3(<span class="hljs-keyword">false</span>);
        xmCook.cook();
    &#125;
&#125;</code></pre>

<h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><p>在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，购物，有不同的折扣，商家根据用户的不同级别打不同的折扣，普通人不打折，会员打9折，超级会员打6折等。</p>
<p>定义</p>
<blockquote>
<p><strong>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换</strong>，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
</blockquote>
<p>组成</p>
<blockquote>
<ol>
<li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。———购买东西的抽象</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。———-不同会员实现不同的打折（普通会员8折、超级会员6折等）</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。———-收银台</li>
</ol>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//抽象策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Buyer</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">calPrice</span><span class="hljs-params">(BigDecimal price)</span></span>;
&#125;


<span class="hljs-comment">//具体实现---针对普通人的计算价格策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrdinaryPeople</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Buyer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">calPrice</span><span class="hljs-params">(BigDecimal price)</span> </span>&#123;
        <span class="hljs-keyword">return</span> price;
    &#125;
&#125;
<span class="hljs-comment">//针对VIP的策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VIP</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Buyer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">calPrice</span><span class="hljs-params">(BigDecimal price)</span> </span>&#123;
        <span class="hljs-keyword">return</span> price.multiply(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">0.8</span>));
    &#125;
&#125;
<span class="hljs-comment">//针对SVIP的策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SVIP</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Buyer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">calPrice</span><span class="hljs-params">(BigDecimal price)</span> </span>&#123;
        <span class="hljs-keyword">return</span> price.multiply(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">0.5</span>));
    &#125;
&#125;
<span class="hljs-comment">//环境类---这里是收银台</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cashier</span> </span>&#123;
    <span class="hljs-keyword">private</span> Buyer buyer;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cashier</span><span class="hljs-params">(Buyer buyer)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.buyer = buyer;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">quote</span><span class="hljs-params">(BigDecimal price)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.buyer.calPrice(price);
    &#125;
&#125;

<span class="hljs-comment">//测试</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
    Buyer strategy1=<span class="hljs-keyword">new</span> OrdinaryPeople();
    Buyer strategy2=<span class="hljs-keyword">new</span> VIP();
    Buyer strategy3=<span class="hljs-keyword">new</span> SVIP();
    Cashier cashier1=<span class="hljs-keyword">new</span> Cashier(strategy1);
    BigDecimal quote=cashier1.quote(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">300</span>));
    System.out.println(<span class="hljs-string">"普通人购买价格"</span>+quote.doubleValue());
    Cashier cashier2=<span class="hljs-keyword">new</span> Cashier(strategy2);
    BigDecimal quote2=cashier2.quote(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">300</span>));
    System.out.println(<span class="hljs-string">"VIP购买价格"</span>+quote2.doubleValue());
    Cashier cashier3=<span class="hljs-keyword">new</span> Cashier(strategy3);
    BigDecimal quote3=cashier3.quote(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">300</span>));
    System.out.println(<span class="hljs-string">"SVIP购买价格"</span>+quote3.doubleValue());

&#125;</code></pre>



<h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><p>举例：明星发微博，粉丝自动收到提示，这就是观察者模式的一种体现。明星是被观察者，粉丝是观察者</p>
<p>定义</p>
<blockquote>
<p>指多个对象间存<strong>在一对多的依赖关系</strong>，<strong>当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</strong>。这种模式有时<strong>又称作发布-订阅模式</strong>、模型-视图模式，它是对象行为型模式。</p>
</blockquote>
<p>优点</p>
<blockquote>
<ol>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li>
<li>目标与观察者之间建立了一套触发机制。</li>
</ol>
</blockquote>
<p>缺点</p>
<blockquote>
<ol>
<li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li>
<li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li>
</ol>
</blockquote>
<p>组成</p>
<blockquote>
<p>主题：主题是观察者观察的对象，一个主题必须具备下面三个特征。</p>
<ul>
<li>持有监听的观察者的引用（以微博明星和粉丝为例，明星有自己的粉丝列表）</li>
<li>支持增加和删除观察者（明星可以拉黑自己的粉丝，也可以增加自己的粉丝—比如取消拉黑）</li>
<li>主题状态改变，通知观察者（明星有动态后，自动提醒粉丝）</li>
</ul>
<p>观察者：当主题发生变化，收到通知进行具体的处理是观察者必须具备的特征。（粉丝收到明星动态更新后，可以去查看具体动态）</p>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//抽象主题----明星</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Star</span> </span>&#123;
    <span class="hljs-comment">//add Fans</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFans</span><span class="hljs-params">(Fan fan)</span></span>;
    <span class="hljs-comment">//delete Fans</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteFan</span><span class="hljs-params">(Fan fan)</span></span>;
    <span class="hljs-comment">//notify Fans</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyFan</span><span class="hljs-params">(String msg)</span></span>;
&#125;

<span class="hljs-comment">//具体主题---具体的一个明星</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Star</span></span>&#123;
    <span class="hljs-keyword">public</span> List&lt;Fan&gt; list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFans</span><span class="hljs-params">(Fan fan)</span> </span>&#123;
        list.add(fan);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteFan</span><span class="hljs-params">(Fan fan)</span> </span>&#123;
        list.remove(fan);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyFan</span><span class="hljs-params">(String msg)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (Fan fan : list) &#123;
            fan.receive(msg);
        &#125;
    &#125;
&#125;

<span class="hljs-comment">//抽象观察者----粉丝</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Fan</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(String msg)</span></span>;
&#125;

<span class="hljs-comment">//具体观察者----某一个粉丝，具体的粉丝</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Fan</span> </span>&#123;
    <span class="hljs-keyword">public</span> String name;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteFan</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(String msg)</span> </span>&#123;
        System.out.println(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">"收到了动态"</span>+msg);
    &#125;
&#125;
<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        ConcreteStar star=<span class="hljs-keyword">new</span> ConcreteStar();
        ConcreteFan fan1=<span class="hljs-keyword">new</span> ConcreteFan(<span class="hljs-string">"qq"</span>);
        ConcreteFan fan2=<span class="hljs-keyword">new</span> ConcreteFan(<span class="hljs-string">"ww"</span>);
        ConcreteFan fan3=<span class="hljs-keyword">new</span> ConcreteFan(<span class="hljs-string">"ss"</span>);
        ConcreteFan fan4=<span class="hljs-keyword">new</span> ConcreteFan(<span class="hljs-string">"aa"</span>);
        star.addFans(fan1);
        star.addFans(fan2);
        star.addFans(fan3);
        star.addFans(fan4);
        star.notifyFan(<span class="hljs-string">"Hello World"</span>);
    &#125;
&#125;</code></pre>



<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p>跳表可以理解为可以使用二分法的数组。就是在链表上加多层索引。</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200628183828.png" srcset="/img/loading.gif" alt="image-20200628183825168"></p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>组成：由多个哈希函数+二进制的位向量。</p>
<p>可以判断一个元素是否存在，但是有误判率</p>
<p>假设输入对象个数为n，bitarray大小（也就是布隆过滤器大小）为m，所容忍的误判率p和哈希函数的个数k。计算公式如下：（<strong>小数向上取整</strong>）</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200628184001.png" srcset="/img/loading.gif" alt="image-20200628183958868"></p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>见其他文章</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>见其他文章</p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>见其他文章</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><h3 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h3><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="Java秒杀"><a href="#Java秒杀" class="headerlink" title="Java秒杀"></a>Java秒杀</h3><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3>
            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%A7%8B%E6%8B%9B/">秋招</a>
                    
                      <a class="hover-with-bg" href="/categories/%E7%A7%8B%E6%8B%9B/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%A7%8B%E6%8B%9B/">秋招</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/06/28/%E9%9D%A2%E8%AF%95%E9%A2%98/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">面试题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/06/27/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE-1/">
                        <span class="hidden-mobile">秒杀项目-1</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "简历问题&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
