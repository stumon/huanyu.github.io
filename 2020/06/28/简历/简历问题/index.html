<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>简历问题 - 郭寰宇</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>郭寰宇的个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-06-28 08:30">
      2020年6月28日 早上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      142
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="Java语法"><a href="#Java语法" class="headerlink" title="Java语法"></a>Java语法</h3><p>泛型擦除：<a href="https://www.cnblogs.com/wuqinglong/p/9456193.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuqinglong/p/9456193.html</a></p>
<p>Java中的四种引用：<a href="https://www.cnblogs.com/coder306/p/13087581.html" target="_blank" rel="noopener">https://www.cnblogs.com/coder306/p/13087581.html</a></p>
<p>new的过程发生了什么？：<a href="https://blog.csdn.net/moHedong/article/details/79618048" target="_blank" rel="noopener">https://blog.csdn.net/moHedong/article/details/79618048</a></p>
<p>Volatile：周志明深入理解JVM第三版 P448。总线风暴：<a href="https://blog.csdn.net/oschina_41790905/article/details/105951643" target="_blank" rel="noopener">https://blog.csdn.net/oschina_41790905/article/details/105951643</a></p>
<blockquote>
<p>基于 CPU 缓存一致性协议，JVM 实现了 volatile 的可见性，但由于总线嗅探机制，会不断的监听总线，如果大量使用 volatile 会引起总线风暴。所以，volatile 的使用要适合具体场景。</p>
<p>locak addl：<a href="https://www.jianshu.com/p/6ab7c3db13c3" target="_blank" rel="noopener">https://www.jianshu.com/p/6ab7c3db13c3</a></p>
<p>volatile：<a href="https://zhuanlan.zhihu.com/p/73126227" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73126227</a>      <a href="https://blog.csdn.net/oschina_41790905/article/details/105951643#comments_12751169" target="_blank" rel="noopener">https://blog.csdn.net/oschina_41790905/article/details/105951643#comments_12751169</a></p>
<p>为什么volatile不保证原子性：<a href="https://blog.csdn.net/xdzhouxin/article/details/81236356" target="_blank" rel="noopener">https://blog.csdn.net/xdzhouxin/article/details/81236356</a></p>
<p>我的理解是：对于多线程下res++，线程A读了值res为100，res值加1后，变成了101，但是还没有写会工作内存，此时阻塞，线程B进来，线程B操作后res值变成101，然后线程A把res写回工作内存，再刷新主存</p>
<p><a href="https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg</a></p>
<p>happens-before：<a href="https://baijiahao.baidu.com/s?id=1654963077694559106&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1654963077694559106&amp;wfr=spider&amp;for=pc</a>      <a href="https://www.cnblogs.com/tiancai/p/9636199.html" target="_blank" rel="noopener">https://www.cnblogs.com/tiancai/p/9636199.html</a></p>
</blockquote>
<p>HashMap扩容的时候读会有什么问题？：<a href="https://blog.csdn.net/bjwfm2011/article/details/81076736" target="_blank" rel="noopener">https://blog.csdn.net/bjwfm2011/article/details/81076736</a></p>
<blockquote>
<p>JDK7：如果读取的值的key和环形链表上的key相同，那么就会死循环</p>
<p>JDK8：尾插法可能会覆盖值，导致读不到</p>
</blockquote>
<p>HashMap：<a href="https://www.cnblogs.com/zhuifeng523/p/11390884.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuifeng523/p/11390884.html</a></p>
<p>HashMap链表转红黑树：<a href="https://www.jianshu.com/p/309ea054cbc9" target="_blank" rel="noopener">https://www.jianshu.com/p/309ea054cbc9</a></p>
<blockquote>
<p>如果链表长度大于8，但是数组长度&lt;64，只进行扩容</p>
<p>如果链表长度大于8，且数组长度&gt;=64，链表转成红黑树</p>
</blockquote>
<p>Hashtable+ConcurrentHashMap：</p>
<blockquote>
<p>JDK7—&gt;<a href="https://zhuanlan.zhihu.com/p/31614308" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31614308</a>      </p>
<p>JDK8—–&gt;<a href="https://zhuanlan.zhihu.com/p/97902016" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/97902016</a> </p>
<p>​                <a href="https://www.jianshu.com/p/865c813f2726" target="_blank" rel="noopener">https://www.jianshu.com/p/865c813f2726</a></p>
</blockquote>
<p>Comparable和Comparator接口的区别：<a href="https://zhuanlan.zhihu.com/p/94359581" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/94359581</a></p>
<p>锁升级过程：<a href="https://blog.csdn.net/lengxiao1993/article/details/81568130" target="_blank" rel="noopener">https://blog.csdn.net/lengxiao1993/article/details/81568130</a>  <a href="https://www.cnblogs.com/paddix/p/5405678.html" target="_blank" rel="noopener">https://www.cnblogs.com/paddix/p/5405678.html</a></p>
<blockquote>
<p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令</p>
<p>轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁</p>
</blockquote>
<p>static关键字：<a href="https://www.cnblogs.com/swisszhang/p/9892992.html" target="_blank" rel="noopener">https://www.cnblogs.com/swisszhang/p/9892992.html</a></p>
<p>内部类和静态内部类的区别：<a href="https://www.zhihu.com/question/285579995" target="_blank" rel="noopener">https://www.zhihu.com/question/285579995</a>  <a href="https://www.cnblogs.com/ConstXiong/p/11871149.html" target="_blank" rel="noopener">https://www.cnblogs.com/ConstXiong/p/11871149.html</a>  <a href="https://blog.csdn.net/fgakjfd/article/details/5282646" target="_blank" rel="noopener">https://blog.csdn.net/fgakjfd/article/details/5282646</a></p>
<p>为什么wait，notify，notifyAll定义在Object中？：<a href="https://blog.csdn.net/pulusite/article/details/82287462" target="_blank" rel="noopener">https://blog.csdn.net/pulusite/article/details/82287462</a></p>
<p>一个class文件有几个类：<a href="https://blog.csdn.net/TTTiaotiao/article/details/95007780" target="_blank" rel="noopener">https://blog.csdn.net/TTTiaotiao/article/details/95007780</a></p>
<p>IO：<a href="https://github.com/stumon/JavaGuide/blob/master/docs/java/BIO-NIO-AIO.md">https://github.com/stumon/JavaGuide/blob/master/docs/java/BIO-NIO-AIO.md</a></p>
<p>异常：</p>
<p>ArrayList：<a href="https://mp.weixin.qq.com/s/3PNWmtS-bEZgZjd9wyMiDA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3PNWmtS-bEZgZjd9wyMiDA</a></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>两个线程轮流打印字母和数字：</p>
<p>线程池使用无界队列的坑：<a href="https://blog.csdn.net/firefile/article/details/80745627" target="_blank" rel="noopener">https://blog.csdn.net/firefile/article/details/80745627</a></p>
<p>cglib：对指定的类生成一个子类，覆盖其中所有的方法并环绕增强，<strong>不可以代理</strong>被final修饰的类或方法</p>
<p>AQS：</p>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>select、poll和epoll：</p>
<blockquote>
</blockquote>
<p>协程：编程语言级别的线程，用户态的线程，不需要切换到内核态</p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>GC ROOT：<strong>一组必须活跃的引用</strong>。虚拟机栈里面的引用的对象（局部变量、临时遍历）、方法区中类静态属性引用的对象，方法区中常量引用的对象、JNI引用的对象、JVM内部引用如Class对象、被锁持有的对象</p>
<p>如何打破双亲</p>
<p>CPU100%如何排查：<a href="https://mp.weixin.qq.com/s/roEMz-5tzBZvGxbjq8NhOQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/roEMz-5tzBZvGxbjq8NhOQ</a></p>
<p>OOM如何排查：<a href="https://blog.csdn.net/fishinhouse/article/details/80781673" target="_blank" rel="noopener">https://blog.csdn.net/fishinhouse/article/details/80781673</a></p>
<blockquote>
<p>常见参数：<a href="https://www.cnblogs.com/anyehome/p/9071619.html" target="_blank" rel="noopener">https://www.cnblogs.com/anyehome/p/9071619.html</a></p>
</blockquote>
<p>JVM调优工具：</p>
<blockquote>
<p>教程：<a href="https://www.bilibili.com/video/BV1N741127Wt?t=51&amp;p=16" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1N741127Wt?t=51&amp;p=16</a></p>
<p>jps：列出 Java 上的所有进程</p>
<p>jstack：查看或导出Java应用程序中线程堆栈信息</p>
<p>jvisualvm：查看监控内存泄露，跟踪垃圾回收，执行时内存、cpu分析，线程分析</p>
</blockquote>
<p>JVM调优：</p>
<blockquote>
<p>内存溢出</p>
<p>​    原因：JVM内存过小、死循环或循环产生过多重复的对象实体、加载的数据量过于庞大、<strong>内存泄漏</strong></p>
<p>​    分析：使用jvisualvm分析dump，分析到底是内存泄漏还是内存溢出。如果是<strong>内存泄漏</strong>，可进一步通过工具查看泄漏对象到GC Roots的引用链，修复应用程序中的内存泄漏。如果是<strong>内存溢出</strong>，先检查是否有死循环。</p>
<p>​    解决方法：增加JVM的内存大小、避免死循环，防止一次载入太多的数据、及时地释放没用的对象，释放内存空间</p>
<p>内存泄漏</p>
<p>​    原因：程序在申请内存后，无法释放已申请的内存空间</p>
<p>​    特点：对象是可达的、对象是无用的。在程序中体现在，频繁GC，但是释放不了多少内存。比如静态static修饰对象。</p>
<p>​    解决方法：jvisualvm分析，定位代码（找出内存占用超出预期的嫌疑对象、分析程序的源代码，找出嫌疑对象数量过多的原因）</p>
<p>栈溢出：</p>
<p>​    栈里面放：局部变量表（重点）、操作数栈（重点）、动态链接，也称为指向运行时常量池的方法引用、方法返回地址，也称为方法退出的定义</p>
<p>​    描述：</p>
<p>​        如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常</p>
<p>​        如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常</p>
<p>​    原因：</p>
<p>​        单个线程下，栈帧太大，或者虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出StackOverflowError 异常</p>
<p>​        不断地建立线程的方式会导致内存溢出。</p>
<p>​    解决方法：看看是否有方法递归，避免递归在代码中无限循环</p>
<p>方法区溢出</p>
<p>​    原因：方法区用于存放Class的相关信息，如类名、访问修饰符、返回值、常量池、变量名、方法名等。<strong>静态变量也存储在方法区</strong>，生成了大量的类，导致方法区被撑爆</p>
<p>​    解决方法：检查是否永久代空间设置得过小、检查是否使用CGLib生成了大量的代理类</p>
</blockquote>
<p>TLAB：<a href="https://mp.weixin.qq.com/s/Wws24Fhg1nH4dHvtcFYi2g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Wws24Fhg1nH4dHvtcFYi2g</a></p>
<h3 id="设计模式（15-23）"><a href="#设计模式（15-23）" class="headerlink" title="设计模式（15/23）"></a>设计模式（15/23）</h3><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><blockquote>
<p>开闭原则、单一职责原则、里氏替换原则、依赖倒置原则、迪米特原则、接口隔离原则、组合原则</p>
</blockquote>
<p>设计模式分类：创建型、结构型、行为型</p>
<h4 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h4><p>解释：省去New的过程</p>
<blockquote>
<p>单例、原型、工厂方法、抽象工厂、建造者</p>
</blockquote>
<h5 id="DCL单例"><a href="#DCL单例" class="headerlink" title="DCL单例"></a>DCL单例</h5><pre><code class="hljs java"><span class="hljs-comment">//单例四大原则：构造私有、静态方法或者枚举返回实例、确保实例只有一个、反序列时不会重构对象</span></code></pre>

<h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><p>根据一个已经创建好的实例，不断的克隆出其他对象，省去了复杂的new过程。</p>
<p>但是原型的克隆分为浅克隆和深克隆，Object类的Clone方法为浅克隆，要想实现深克隆必须我们自己动手实现</p>
<pre><code class="hljs java"><span class="hljs-comment">//原型设计模式的设计原则：实现Cloneable接口，重写Clone方法</span>
<span class="hljs-comment">//浅克隆，我们只需要重写Clone方法，但是方法内部方法体不需要改变</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prototype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Prototype</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age,String name)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>.age=age;
        <span class="hljs-keyword">this</span>.name=name;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Prototype&#123;"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'&#125;'</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();
    &#125;
&#125;

<span class="hljs-comment">//深克隆，需要重写Clone方法的方法体</span>
<span class="hljs-meta">@Date</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrototypeDeep</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;
    <span class="hljs-keyword">private</span> Date date;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrototypeDeep</span><span class="hljs-params">(Date date, String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.date = date;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"PrototypeDeep&#123;"</span> +
                <span class="hljs-string">"date="</span> + date +
                <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'&#125;'</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> PrototypeDeep <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        PrototypeDeep prototypeDeep= (PrototypeDeep) <span class="hljs-keyword">super</span>.clone();
        Date cloneDate= (Date) <span class="hljs-keyword">this</span>.date.clone();
        prototypeDeep.date=cloneDate;
        <span class="hljs-keyword">return</span> prototypeDeep;
    &#125;
&#125;</code></pre>

<h5 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h5><p>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”</p>
<pre><code class="hljs java"><span class="hljs-comment">//简单工厂，不属于设计模式，但是这里引入简单工厂是为了后面铺垫，简单工厂只有一个工厂类</span>
<span class="hljs-comment">//缺点是，如果要增加新的产品，就需要修改源代码</span>
<span class="hljs-comment">//产品接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProductA</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">introduce</span><span class="hljs-params">()</span></span>;
&#125;
<span class="hljs-comment">//实现类</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Buick</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProductA</span></span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">introduce</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"this is Buick"</span>);
    &#125;
&#125;
<span class="hljs-comment">//实现类</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WuLing</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProductA</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">introduce</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"this is WuLing"</span>);
    &#125;
&#125;
<span class="hljs-comment">//简单工厂</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> ProductA <span class="hljs-title">Factory</span><span class="hljs-params">(String product)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span>(product.equals(<span class="hljs-string">"Buick"</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Buick();
        <span class="hljs-keyword">if</span> (product.equals(<span class="hljs-string">"WuLing"</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WuLing();<span class="hljs-comment">//如果想要增加新产品，就需要修改源代码</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
&#125;</code></pre>

<h5 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h5><p>定义一个<strong>创建产品对象的工厂接口</strong>，将产品对象的实际创建工作推迟到<strong>具体子工厂类当中</strong>。这满足创建型模式中所要求的“<strong>创建与使用相分离</strong>”的特点</p>
<p>“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p>
<p>工厂方法模式的主要优点有：</p>
<ul>
<li><p>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</p>
</li>
<li><p>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</p>
</li>
</ul>
<p>缺点是：每增加一个<strong>产品</strong>就要增加一个具体<strong>产品类</strong>和一个对应的<strong>具体工厂类</strong>，这增加了系统的复杂度。</p>
<h5 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h5><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<p>结构为：抽象产品、抽象工厂、具体产品、具体工厂</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200628095822.png" srcset="/img/loading.gif" alt="image-20200628095817985"></p>
<p>使用抽象工厂模式一般要满足以下条件。</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。<br>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</li>
</ul>
<p>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</p>
<p>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</p>
<p>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>
<p>按照上面的图片来写一个抽象工厂设计模式代码</p>
<h5 id="建造者"><a href="#建造者" class="headerlink" title="建造者"></a>建造者</h5><p>买汽车，不需要管汽车零件的生产步骤，只需要去4S店提车就可以，每一个车由很多部件构成，部件可以灵活选择，组织部件的顺序也可以灵活选择，这类产品的创建无法用工厂模式描述，建造者模式就是用来描述这类产品的创建</p>
<p>定义：它是将<strong>一个复杂的对象分解为多个简单的对象</strong>，然后一步一步构建而成。它将<strong>变与不变相分离</strong>，即产品的<strong>组成部分是不变的</strong>，但<strong>每一部分是可以灵活选择的</strong>。</p>
<p>组成：</p>
<p>产品角色：包含多个组件</p>
<p>抽象建造者：包含创建产品各个组件的抽象方法的接口</p>
<p>具体建造者：实现接口，完成创建各个组件的方法</p>
<p>指挥者：按照一定顺序调用建造者的方法</p>
<h4 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h4><p>解释：将<strong>类和对象</strong>结合在一起成为一个更大的结构。分为类结构型和对象结构型模式。</p>
<p>​    类结构模型关心<strong>类的组合</strong>，由多个类可以组成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系；</p>
<p>​    对象结构型模式<strong>关心类与对象的组合</strong>，通过<strong>组合关系</strong>使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。根据“<strong>组合复用原则</strong>”，在系统中尽量使用组合关系来替代继承关系，因此大部分结构型模式都是对象结构型模式</p>
<blockquote>
<p>代理、适配器、桥接、装饰、享元、外观、组合</p>
</blockquote>
<h5 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h5><p>定义</p>
<blockquote>
<p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，<strong>访问对象</strong>不适合或者<strong>不能直接引用目标对象</strong>，<strong>代理对象作为访问对象和目标对象之间的中介。</strong></p>
</blockquote>
<p>你不想上课，找人替你去上课，那个人就是代理。</p>
<p>优点</p>
<blockquote>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>
</ul>
</blockquote>
<p>缺点</p>
<blockquote>
<ul>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度</li>
</ul>
</blockquote>
<p>组成</p>
<blockquote>
<p>抽象主题类：可以是接口也可以是抽象类，用来进行业务定义</p>
<p>真实主题类（被代理类）：用来实现真正的业务逻辑</p>
<p>代理类：它负责控制对真实主题类访问的控制，在真实主题类中的方法上实现一些增强功能</p>
<p>客户端：访问代理类实现某些业务</p>
</blockquote>
<h6 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h6><pre><code class="hljs java"><span class="hljs-comment">//静态代理，代理类实现增加功能</span>
<span class="hljs-comment">//下面以租房为例，中介是搭理，房东是真实角色，两人共同的业务是收房租</span>
<span class="hljs-comment">//接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Rent</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">price</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">//真实主题</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Landlord</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Rent</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"房屋价格是XXX"</span>);
    &#125;
&#125;
<span class="hljs-comment">//代理主题</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Rent</span></span>&#123;
    <span class="hljs-keyword">private</span> Landlord landlord;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StaticProxy</span><span class="hljs-params">(Landlord landlord)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.landlord = landlord;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"代理类实现XXXXX功能"</span>);
        landlord.price();
    &#125;
&#125;
<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        Landlord landlord=<span class="hljs-keyword">new</span> Landlord();
        StaticProxy staticProxy=<span class="hljs-keyword">new</span> StaticProxy(landlord);
        staticProxy.price();
    &#125;
&#125;</code></pre>

<h6 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h6><p>静态代理缺点是每一个真实对象都要生成一个代理对象，代码量翻倍</p>
<pre><code class="hljs java"><span class="hljs-comment">//实现一个代理类，然后从动态的生成代理对象</span>
<span class="hljs-comment">//代理类，Rent接口和Host类在上面的静态代理类中已经定义了，所以这里省略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;
    <span class="hljs-keyword">public</span> Rent rent;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Rent <span class="hljs-title">getRent</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> rent;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRent</span><span class="hljs-params">(Rent rent)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.rent = rent;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span>  Proxy.newProxyInstance(<span class="hljs-keyword">this</span>.getClass().getClassLoader(),rent.getClass().getInterfaces(),<span class="hljs-keyword">this</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
        Object invoke = method.invoke(rent, args);
        <span class="hljs-keyword">return</span> invoke;
    &#125;
&#125;

<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        Landlord landlord=<span class="hljs-keyword">new</span> Landlord();
        DynamicProxy dynamicProxy=<span class="hljs-keyword">new</span> DynamicProxy();
        dynamicProxy.setRent(landlord);
        Rent proxy = (Rent) dynamicProxy.getProxy();
        proxy.price();
    &#125;
&#125;</code></pre>

<h5 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h5><p>定义：<strong>将一个类的接口转换成客户希望的另外一个接口</strong>，<strong>使得原本由于接口不兼容而不能一起工作的那些类能一起工作</strong>。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<p>优点</p>
<blockquote>
<ul>
<li>客户端通过适配器可以透明地调用目标接口。</li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>
</ul>
</blockquote>
<p>缺点：</p>
<p>对类适配器来说，更换适配器的实现过程比较复杂</p>
<p>结构组成</p>
<blockquote>
<p>距离：去美国出差，手机没电了，但是只带了一个<strong>中国220V标准电压的充电头</strong>，美国插座是<strong>240V标准电压</strong>，所以需要一个<strong>转换头</strong>，把240V的交流电转成220V的，这样才可以给手机充电。这个过程中，目标就是220V接口，适配者类就是240V接口，适配器类就是转换头。</p>
<ol>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ol>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//目标接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Target</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;

&#125;

<span class="hljs-comment">//适配者------被适配的类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">"被适配者的方法---220V"</span>);
    &#125;
&#125;

<span class="hljs-comment">//适配器-----将被适配的类转成需要的类。继承被适配者、实现目标接口，在重写的方法中调用父类方法</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;
        function();
    &#125;
&#125;</code></pre>

<h5 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h5><p>比如手机有很多品牌，每一个品牌又有不同的内存，如果我们设计手机，有两种方案，一种是一个一个设计，比如小米4G、小米8G、华为4G、华为8G等，另外一种方案是：把手机品牌和手机内存分开设计，然后组合两者。这样降低了两者的耦合、也减少了代码量</p>
<p>定义</p>
<blockquote>
<p><strong>将抽象与实现分离，使它们可以独立变化</strong>。它是用<strong>组合关系代替继承关系来实现</strong>，从而降低了抽象和实现这两个可变维度的耦合度</p>
</blockquote>
<p>优点</p>
<blockquote>
<ul>
<li>由于抽象与实现分离，所以扩展能力强；</li>
<li>其实现细节对客户透明。</li>
</ul>
</blockquote>
<p>缺点</p>
<blockquote>
<p>由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度</p>
</blockquote>
<p>组成</p>
<blockquote>
<p>抽象类：手机抽象类，包含一个对实现化角色的引用</p>
<p>扩展抽象类：具体的品牌，小米、华为。实现抽象类中的业务方法，通过组合来调用实现类接口中的业务方法</p>
<p>实现类接口：内存。定义实现化角色的接口，光扩展抽象化角色调用</p>
<p>具体实现类：具体的内存型号，给出具体实现</p>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//抽象类</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;
    <span class="hljs-keyword">public</span> Memory memory;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemory</span><span class="hljs-params">(Memory memory)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>.memory=memory;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span></span>;

&#125;
<span class="hljs-comment">//扩展抽象类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Phone</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"Mi Phone memory:"</span>);
        memory.MemorySize();
        System.out.println(<span class="hljs-string">"======="</span>);
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuaWeiPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Phone</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"Hua Wei memory size:"</span>);
        memory.MemorySize();
    &#125;
&#125;

<span class="hljs-comment">//扩展类接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Memory</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MemorySize</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">//具体实现类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memory4G</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Memory</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MemorySize</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"4G内存"</span>);
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memory8G</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Memory</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MemorySize</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"8G内存"</span>);
    &#125;
&#125;
<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        Memory memory4G=<span class="hljs-keyword">new</span> Memory4G();
        Memory memory8G=<span class="hljs-keyword">new</span> Memory8G();
        Phone phone1=<span class="hljs-keyword">new</span> MiPhone();
        Phone phone2=<span class="hljs-keyword">new</span> HuaWeiPhone();
        phone1.setMemory(memory4G);
        phone2.setMemory(memory8G);
        phone1.info();
        phone2.info();
    &#125;
&#125;</code></pre>



<h5 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h5><p>去吃饭，你可以在面的基础上不断加料，这样就有了：牛肉面、鸡蛋牛肉面、番茄鸡蛋牛肉面等，也可以在米饭的基础上加牛肉、鸡蛋、蔬菜等配料</p>
<p>定义</p>
<blockquote>
<p>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来<strong>创建一个包装对象（即装饰对象）来包裹真实对象</strong>，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标</p>
</blockquote>
<p>组成</p>
<blockquote>
<ol>
<li><p>抽象被装饰者（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。——面的抽象接口</p>
</li>
<li><p>具体被装饰者（Concrete  Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。——具体的面：牛肉面、鸡蛋面等</p>
</li>
<li><p>抽象装饰者（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。—-各种料</p>
</li>
<li><p>具体装饰者（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。—-具体的料：鸡蛋、牛肉、蔬菜等</p>
</li>
</ol>
<p>要点：</p>
<p>  1 多种具体被装饰者（主体类）抽象出一个抽象被装饰类，后面通过多态，动态传递具体对象。</p>
<p>  2 抽象装饰类<strong>继承</strong>抽象被装饰者（保持接口）；要求传入被装饰者（使用父类应用、protected修饰）；</p>
<p>  3 多种具体装饰者抽象出一个抽象装饰类。</p>
<p>  4 具体装饰者中，可以添加新方法，可以重写方法；需要使用被装饰者方法的地方用传入的被装饰者引用。</p>
</blockquote>
<p>缺点</p>
<blockquote>
<p>装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//以吃面为例，普通面、牛肉面、鸡蛋牛肉面、蔬菜鸡蛋牛肉面，牛肉米饭、鸡蛋米饭</span>
<span class="hljs-comment">//抽象父类---食物</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">//实现类---面条</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Noodle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"面条"</span>);
    &#125;
&#125;
<span class="hljs-comment">//实现类----米饭</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"米饭"</span>);
    &#125;
&#125;
<span class="hljs-comment">//抽象装饰者类</span>
<span class="hljs-comment">/*</span>
<span class="hljs-comment">1.抽象装饰者类中继承该抽象类以保持接口规范</span>
<span class="hljs-comment">2.包含该抽象类的引用以通过多态的方式对多种被装饰者类进行装饰。</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span>&#123;
    <span class="hljs-keyword">protected</span> Food food;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Decorator</span><span class="hljs-params">(Food food)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.food = food;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> food.cal();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        food.display();
    &#125;
&#125;
<span class="hljs-comment">//具体装饰者类---牛肉</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeefDecoractor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decorator</span></span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BeefDecoractor</span><span class="hljs-params">(Food food)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(food);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.cal()+<span class="hljs-number">10</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">super</span>.display();
        System.out.println(<span class="hljs-string">"+牛肉"</span>);
    &#125;
&#125;

<span class="hljs-comment">//具体装饰者类---鸡蛋</span>
<span class="hljs-comment">//继承抽象的被装饰者类，并实现其中的抽象方法。</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EggDecoractor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decorator</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EggDecoractor</span><span class="hljs-params">(Food food)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(food);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.cal()+<span class="hljs-number">2</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">super</span>.display();
        System.out.println(<span class="hljs-string">"+鸡蛋"</span>);
    &#125;
&#125;
<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        Food food=<span class="hljs-keyword">new</span> Noodle();
        Decorator beefDecoractor=<span class="hljs-keyword">new</span> BeefDecoractor(<span class="hljs-keyword">new</span> EggDecoractor(<span class="hljs-keyword">new</span> BeefDecoractor(food)));<span class="hljs-comment">//面里面加两份牛肉，一份鸡蛋</span>
        System.out.println(beefDecoractor.cal());

    &#125;
&#125;</code></pre>

<p>类图：</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200628145900.png" srcset="/img/loading.gif" alt="image-20200628145855384"></p>
<h5 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h5><blockquote>
<p>是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>
<p>外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。</p>
<ol>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
</ol>
<p>外观（Facade）模式的主要缺点如下。</p>
<ol>
<li>不能很好地限制客户使用子系统类。</li>
<li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
</ol>
</blockquote>
<h5 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h5><blockquote>
<p>组合（Composite）模式的定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p>
<p>组合模式的主要优点有：</p>
<ol>
<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li>
<li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li>
</ol>
<p>其主要缺点是：</p>
<ol>
<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li>
<li>不容易限制容器中的构件；</li>
<li>不容易用继承的方法来增加构件的新功能；</li>
</ol>
</blockquote>
<h5 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h5><blockquote>
<p>运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
<p>享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p>
<p>其主要缺点是：</p>
<ol>
<li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li>
<li>读取享元模式的外部状态会使得运行时间稍微变长。</li>
</ol>
</blockquote>
<h4 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h4><p>解释描述程序在运行时复杂的流程控制，即描述<strong>多个类或对象之间怎样相互协作</strong>共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<blockquote>
<p><strong>模板方法</strong>、<strong>策略</strong>、命令、职责链、状态、<strong>观察者</strong>、中介者、迭代器、访问者、备忘录、解释器</p>
</blockquote>
<h5 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h5><p>定义</p>
<blockquote>
<p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p>
</blockquote>
<p>优点</p>
<blockquote>
<ol>
<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在父类中提取了公共的部分代码，便于代码复用。</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
<li>我们在定义行为时候都是由父类去定义，然后子类去实现即可。</li>
</ol>
</blockquote>
<p>缺点</p>
<blockquote>
<ol>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
</ol>
</blockquote>
<p>组成</p>
<blockquote>
<p>(1) 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。</p>
<p>① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p>
<p>② 基本方法：是整个算法中的一个步骤，包含以下几种类型。</p>
<ul>
<li>抽象方法：在抽象类中申明，由具体子类实现。</li>
<li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li>
<li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li>
</ul>
<p>(2) 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。</p>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//以做饭为例，小明和小红做饭，同样一道菜，相同的步骤，俩人做出来的菜味道就是不一样，因为每一个步骤的执行效果不同</span>
<span class="hljs-comment">//抽象类-----这道菜的正常执行步骤是1、2、3、4</span>
<span class="hljs-keyword">package</span> com.guo.TemplatePattern;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cook</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step3</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step4</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">executeStep3</span><span class="hljs-params">()</span><span class="hljs-comment">//钩子函数，由子类决定某一个函数是否要执行</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>.step1();
        <span class="hljs-keyword">this</span>.step2();
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.executeStep3())
        &#123;
            <span class="hljs-keyword">this</span>.step3();
        &#125;
        <span class="hljs-keyword">this</span>.step4();
    &#125;
&#125;


<span class="hljs-comment">//子类----XM做饭</span>
<span class="hljs-keyword">package</span> com.guo.TemplatePattern;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XMCook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cook</span></span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> executeStep3=<span class="hljs-keyword">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExecuteStep3</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> executeStep3)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.executeStep3 = executeStep3;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step1</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XM--1"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XM--2"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step3</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XM--3"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step4</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XM--4"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">executeStep3</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.executeStep3;
    &#125;
&#125;

<span class="hljs-comment">//子类---XH做饭</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XHCook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cook</span></span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> executeStep3=<span class="hljs-keyword">true</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExecuteStep3</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> executeStep3)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.executeStep3 = executeStep3;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step1</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XH=====1"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XH=====2"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step3</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XH=====3"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step4</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XH=====4"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">executeStep3</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.executeStep3();
    &#125;
&#125;

<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        Cook xmCook=<span class="hljs-keyword">new</span> XMCook();
        xmCook.cook();
        XMCook xmCook=<span class="hljs-keyword">new</span> XMCook();
        xmCook.setExecuteStep3(<span class="hljs-keyword">false</span>);
        xmCook.cook();
    &#125;
&#125;</code></pre>

<h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><p>在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，购物，有不同的折扣，商家根据用户的不同级别打不同的折扣，普通人不打折，会员打9折，超级会员打6折等。</p>
<p>定义</p>
<blockquote>
<p><strong>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换</strong>，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
</blockquote>
<p>组成</p>
<blockquote>
<ol>
<li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。———购买东西的抽象</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。———-不同会员实现不同的打折（普通会员8折、超级会员6折等）</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。———-收银台</li>
</ol>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//抽象策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Buyer</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">calPrice</span><span class="hljs-params">(BigDecimal price)</span></span>;
&#125;


<span class="hljs-comment">//具体实现---针对普通人的计算价格策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrdinaryPeople</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Buyer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">calPrice</span><span class="hljs-params">(BigDecimal price)</span> </span>&#123;
        <span class="hljs-keyword">return</span> price;
    &#125;
&#125;
<span class="hljs-comment">//针对VIP的策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VIP</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Buyer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">calPrice</span><span class="hljs-params">(BigDecimal price)</span> </span>&#123;
        <span class="hljs-keyword">return</span> price.multiply(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">0.8</span>));
    &#125;
&#125;
<span class="hljs-comment">//针对SVIP的策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SVIP</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Buyer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">calPrice</span><span class="hljs-params">(BigDecimal price)</span> </span>&#123;
        <span class="hljs-keyword">return</span> price.multiply(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">0.5</span>));
    &#125;
&#125;
<span class="hljs-comment">//环境类---这里是收银台</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cashier</span> </span>&#123;
    <span class="hljs-keyword">private</span> Buyer buyer;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cashier</span><span class="hljs-params">(Buyer buyer)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.buyer = buyer;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">quote</span><span class="hljs-params">(BigDecimal price)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.buyer.calPrice(price);
    &#125;
&#125;

<span class="hljs-comment">//测试</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
    Buyer strategy1=<span class="hljs-keyword">new</span> OrdinaryPeople();
    Buyer strategy2=<span class="hljs-keyword">new</span> VIP();
    Buyer strategy3=<span class="hljs-keyword">new</span> SVIP();
    Cashier cashier1=<span class="hljs-keyword">new</span> Cashier(strategy1);
    BigDecimal quote=cashier1.quote(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">300</span>));
    System.out.println(<span class="hljs-string">"普通人购买价格"</span>+quote.doubleValue());
    Cashier cashier2=<span class="hljs-keyword">new</span> Cashier(strategy2);
    BigDecimal quote2=cashier2.quote(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">300</span>));
    System.out.println(<span class="hljs-string">"VIP购买价格"</span>+quote2.doubleValue());
    Cashier cashier3=<span class="hljs-keyword">new</span> Cashier(strategy3);
    BigDecimal quote3=cashier3.quote(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">300</span>));
    System.out.println(<span class="hljs-string">"SVIP购买价格"</span>+quote3.doubleValue());

&#125;</code></pre>



<h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><p>举例：明星发微博，粉丝自动收到提示，这就是观察者模式的一种体现。明星是被观察者，粉丝是观察者</p>
<p>定义</p>
<blockquote>
<p>指多个对象间存<strong>在一对多的依赖关系</strong>，<strong>当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</strong>。这种模式有时<strong>又称作发布-订阅模式</strong>、模型-视图模式，它是对象行为型模式。</p>
</blockquote>
<p>优点</p>
<blockquote>
<ol>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li>
<li>目标与观察者之间建立了一套触发机制。</li>
</ol>
</blockquote>
<p>缺点</p>
<blockquote>
<ol>
<li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li>
<li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li>
</ol>
</blockquote>
<p>组成</p>
<blockquote>
<p>主题：主题是观察者观察的对象，一个主题必须具备下面三个特征。</p>
<ul>
<li>持有监听的观察者的引用（以微博明星和粉丝为例，明星有自己的粉丝列表）</li>
<li>支持增加和删除观察者（明星可以拉黑自己的粉丝，也可以增加自己的粉丝—比如取消拉黑）</li>
<li>主题状态改变，通知观察者（明星有动态后，自动提醒粉丝）</li>
</ul>
<p>观察者：当主题发生变化，收到通知进行具体的处理是观察者必须具备的特征。（粉丝收到明星动态更新后，可以去查看具体动态）</p>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//抽象主题----明星</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Star</span> </span>&#123;
    <span class="hljs-comment">//add Fans</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFans</span><span class="hljs-params">(Fan fan)</span></span>;
    <span class="hljs-comment">//delete Fans</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteFan</span><span class="hljs-params">(Fan fan)</span></span>;
    <span class="hljs-comment">//notify Fans</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyFan</span><span class="hljs-params">(String msg)</span></span>;
&#125;

<span class="hljs-comment">//具体主题---具体的一个明星</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Star</span></span>&#123;
    <span class="hljs-keyword">public</span> List&lt;Fan&gt; list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFans</span><span class="hljs-params">(Fan fan)</span> </span>&#123;
        list.add(fan);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteFan</span><span class="hljs-params">(Fan fan)</span> </span>&#123;
        list.remove(fan);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyFan</span><span class="hljs-params">(String msg)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (Fan fan : list) &#123;
            fan.receive(msg);
        &#125;
    &#125;
&#125;

<span class="hljs-comment">//抽象观察者----粉丝</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Fan</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(String msg)</span></span>;
&#125;

<span class="hljs-comment">//具体观察者----某一个粉丝，具体的粉丝</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Fan</span> </span>&#123;
    <span class="hljs-keyword">public</span> String name;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteFan</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(String msg)</span> </span>&#123;
        System.out.println(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">"收到了动态"</span>+msg);
    &#125;
&#125;
<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        ConcreteStar star=<span class="hljs-keyword">new</span> ConcreteStar();
        ConcreteFan fan1=<span class="hljs-keyword">new</span> ConcreteFan(<span class="hljs-string">"qq"</span>);
        ConcreteFan fan2=<span class="hljs-keyword">new</span> ConcreteFan(<span class="hljs-string">"ww"</span>);
        ConcreteFan fan3=<span class="hljs-keyword">new</span> ConcreteFan(<span class="hljs-string">"ss"</span>);
        ConcreteFan fan4=<span class="hljs-keyword">new</span> ConcreteFan(<span class="hljs-string">"aa"</span>);
        star.addFans(fan1);
        star.addFans(fan2);
        star.addFans(fan3);
        star.addFans(fan4);
        star.notifyFan(<span class="hljs-string">"Hello World"</span>);
    &#125;
&#125;</code></pre>



<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p>跳表可以理解为可以使用二分法的数组。就是在链表上加多层索引。</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200628183828.png" srcset="/img/loading.gif" alt="image-20200628183825168"></p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>组成：由多个哈希函数+二进制的位向量。</p>
<p>可以判断一个元素是否存在，但是有误判率</p>
<p>假设输入对象个数为n，bitarray大小（也就是布隆过滤器大小）为m，所容忍的误判率p和哈希函数的个数k。计算公式如下：（<strong>小数向上取整</strong>）</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200628184001.png" srcset="/img/loading.gif" alt="image-20200628183958868"></p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>一致性哈希：<a href="https://zhuanlan.zhihu.com/p/34985026" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34985026</a> （一个圆环、缺点是查询慢、优点是只影响局部数据或服务器）</p>
<h3 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h3><p>线程池：<a href="https://zhuanlan.zhihu.com/p/73990200" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73990200</a></p>
<h3 id="JVM-1"><a href="#JVM-1" class="headerlink" title="JVM"></a>JVM</h3><p>如何打破双亲委派机制：想打破双亲委派模型，那么就重写整个loadClass方法。如果不想打破双亲委派模型，那么只需要重写findClass方法即可</p>
<p>.class和getClass()的区别：.class用于类名，getClass()是一个final native的方法，因此用于类实例。。.class在编译期间就确定了一个类的java.lang.Class对象，但是getClass()方法在运行期间确定一个类实例的java.lang.Class对象</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><p>TCP如何保证可靠传输：<a href="https://blog.csdn.net/QEcode/article/details/90339162" target="_blank" rel="noopener">https://blog.csdn.net/QEcode/article/details/90339162</a></p>
<p>如何设计一个可靠的UDP：<a href="https://blog.csdn.net/weixin_42388901/article/details/102477507" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42388901/article/details/102477507</a></p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><h3 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h3><blockquote>
<p>传统的HTTP协议通信：传统的HTTP报文是直接将报文信息传输到TCP然后TCP再通过TCP套接字发送给目的主机上。</p>
<p>HTTPS协议通信：HTTPS是HTTP报文直接将报文信息传输给SSL套接字进行加密，SSL加密后将加密后的报文发送给TCP套接字，然后TCP套接字再将加密后的报文发送给目的主机，目的主机将通过TCP套接字获取加密后的报文给SSL套接字，SSL解密后交给对应进程</p>
</blockquote>
<p>CA：</p>
<p>SSL握手：</p>
<blockquote>
<p>第一步：客户端发送给服务端自己所支持的<strong>秘钥算法和一个随机数R1</strong></p>
<p>第二步：服务端从秘钥算法中选择三种加密算法（对称加密算法、MCA算法、公钥加密算法），<strong>生成一个随机数R2</strong>，把这<strong>三种加密算法和证书+随机数R2</strong>发送给客户端</p>
<p>第三步：客户端验证证书是否合法，然后从证书中取出<strong>公钥</strong>，自己再生成一个<strong>随机数R3</strong>，利用公钥对这个随机数加密，生成<strong>PreMasterKey</strong>，把它发送给服务端</p>
<p>第四步：客户端收到<strong>PreMasterKey</strong>后，利用自己的私钥解密后得到随机数R3，至此双方都知道了加密算法和三个随机数。</p>
<p>第五步：两边根据加密算法和三个随机数，生成秘钥<strong>Key</strong>，握手结束。以后的应用层数据都使用这个秘钥进行对称加密。</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/e30a8c4fa329" target="_blank" rel="noopener">https://www.jianshu.com/p/e30a8c4fa329</a></p>
<p><a href="https://www.bilibili.com/video/BV1EK4y1b7Mu/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1EK4y1b7Mu/?spm_id_from=333.788.videocard.0</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/32513816" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32513816</a></p>
<p><a href="https://juejin.im/post/584b76d3a22b9d0058d5036f" target="_blank" rel="noopener">https://juejin.im/post/584b76d3a22b9d0058d5036f</a></p>
<p>TCP如何保证可靠传输：<a href="https://www.jianshu.com/p/6aac4b2a9fd7" target="_blank" rel="noopener">https://www.jianshu.com/p/6aac4b2a9fd7</a></p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>常用命令：<a href="https://blog.csdn.net/xulong_08/article/details/81463054" target="_blank" rel="noopener">https://blog.csdn.net/xulong_08/article/details/81463054</a></p>
<blockquote>
<p>创建文件夹 nkdir  创建文件 touch  </p>
<p>查询CPU占用最多的十个进程：ps（报告当前系统的进程状态） top（类似于windows的任务管理器）  free（显示当前系统未使用的和已使用的内存数目）</p>
<p>top命令下，按M是把结果安装内存大小排序，按P是按照CPU占用率排序</p>
<p>查询日期：Date</p>
<p>删除文件 rm -f</p>
<p>搜索文件 find / -name file1</p>
<p>创建用户和群组 groupadd group_name   usedadd user_name</p>
<p>查看文件 cat   tail</p>
<p>显示当前java进程pid</p>
<p>查看硬盘情况：df -lh</p>
</blockquote>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>大纲：<a href="https://www.bilibili.com/video/BV1YE411D7nH?p=29" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YE411D7nH?p=29</a></p>
<p>进程和线程的区别：<a href="https://www.zhihu.com/question/25532384/answer/81152571" target="_blank" rel="noopener">https://www.zhihu.com/question/25532384/answer/81152571</a> </p>
<p>进程间通信（IPC）的方式：<a href="https://www.bilibili.com/video/BV1YE411D7nH?p=10" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YE411D7nH?p=10</a>  (管道、套接字、信号交互、共享内存、消息队列)</p>
<p>线程间通信的方式：wait和notify、volatile、ReentLock <a href="https://blog.csdn.net/jisuanji12306/article/details/86363390" target="_blank" rel="noopener">https://blog.csdn.net/jisuanji12306/article/details/86363390</a></p>
<p>进程互斥：<a href="https://www.bilibili.com/video/BV1YE411D7nH?p=18" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YE411D7nH?p=18</a></p>
<blockquote>
<p>单标志法：只检查，不上锁。缺点：违背空闲让进原则</p>
<p>双标志先检查法：先检查后上锁吗，缺点：同时访问临界资源，<strong>因为检查和上锁不是一气呵成的</strong></p>
<p>双标志后检查法：上锁在前，检查在后。缺点：两个进程都进不去</p>
<p>Peterson算法：双标志后检查法+礼让。如果两个线程都想进入，就礼让。缺点：CPU忙等—&gt;不遵守让权等待</p>
<p>信号量：PV原语</p>
</blockquote>
<p>避免死锁：银行家算法：<a href="https://www.bilibili.com/video/BV1YE411D7nH?p=30" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YE411D7nH?p=30</a></p>
<p>局部性原理：<a href="https://www.zhihu.com/question/25142664" target="_blank" rel="noopener">https://www.zhihu.com/question/25142664</a></p>
<p>虚拟内存：<a href="https://juejin.im/post/59f8691b51882534af254317" target="_blank" rel="noopener">https://juejin.im/post/59f8691b51882534af254317</a>      <a href="https://zhuanlan.zhihu.com/p/82746153" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/82746153</a></p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>一条SQL执行流程：<a href="https://zhuanlan.zhihu.com/p/95082274" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/95082274</a> （缓存、解析器、预处理器、查询优化器、执行、查询执行引擎）</p>
<p>char和varchar的区别：<a href="https://www.cnblogs.com/canger/p/9845969.html" target="_blank" rel="noopener">https://www.cnblogs.com/canger/p/9845969.html</a></p>
<p>左连接、右连接、内连接：<a href="https://www.cnblogs.com/wanglijun/p/8916790.html" target="_blank" rel="noopener">https://www.cnblogs.com/wanglijun/p/8916790.html</a></p>
<p>Delete、Drop、Ttuncate区别：<a href="https://blog.csdn.net/fzy198926/article/details/78190633" target="_blank" rel="noopener">https://blog.csdn.net/fzy198926/article/details/78190633</a></p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>联合索引失效问题：<a href="https://mp.weixin.qq.com/s/COpOB4JJa0Tj4aFn2EawRQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/COpOB4JJa0Tj4aFn2EawRQ</a></p>
<blockquote>
<ol>
<li>联合索引的最左前缀匹配指的是where条件一定要有联合索引的第一个字段</li>
<li>是否走联合索引与where条件的顺序无关，只与字段有关</li>
</ol>
</blockquote>
<p>聚簇索引和非聚簇索引：<a href="https://blog.csdn.net/u013132035/article/details/82193763" target="_blank" rel="noopener">https://blog.csdn.net/u013132035/article/details/82193763</a></p>
<p>explain：<a href="https://blog.csdn.net/wuseyukui/article/details/71512793" target="_blank" rel="noopener">https://blog.csdn.net/wuseyukui/article/details/71512793</a></p>
<blockquote>
<p>type：<a href="https://www.cnblogs.com/chancy/p/10684452.html" target="_blank" rel="noopener">https://www.cnblogs.com/chancy/p/10684452.html</a>        一种数据库引擎查找表的一种方式</p>
</blockquote>
<p>SQL调优：</p>
<p>唯一索引和普通索引选择问题：<a href="https://www.cnblogs.com/lamp01/p/10752100.html" target="_blank" rel="noopener">https://www.cnblogs.com/lamp01/p/10752100.html</a></p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>死锁：<a href="https://www.cnblogs.com/xinruyi/p/11109058.html" target="_blank" rel="noopener">https://www.cnblogs.com/xinruyi/p/11109058.html</a></p>
<p>悲观锁：通过加锁实现，比如 for update</p>
<p>乐观锁：CAS+版本号</p>
<p>读锁：加读锁：Lock Table XX read 。解锁 unlock tables</p>
<p>写锁：加写锁：Lock Table XX write。解锁：unlock tables</p>
<p>共享锁（读锁）：Lock in share mode（<strong>当前读</strong>）。只允许其他人读，不允许其他人写</p>
<p>排它锁（写锁）：for update。其他事务既不能读，也不能写</p>
<p>表锁：锁住整个表</p>
<p>行锁：锁住一行，就是给索引上的索引项加锁。如果没有就是表锁</p>
<p>临建锁（Next-Key）和 间隙锁：<a href="https://blog.csdn.net/WSYW126/article/details/105324239/" target="_blank" rel="noopener">https://blog.csdn.net/WSYW126/article/details/105324239/</a></p>
<p>测试了一个下午，发现也和他的结果不一样，草：<a href="https://blog.csdn.net/WSYW126/article/details/105324239/" target="_blank" rel="noopener">https://blog.csdn.net/WSYW126/article/details/105324239/</a></p>
<p>区间问题：</p>
<blockquote>
<p>根据检索条件向下寻找最靠近检索条件的记录值X作为左区间，向上寻找最靠近检索条件的记录值Y作为右区间，即锁定的间隙为（X，Y）。</p>
</blockquote>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务：<a href="https://zhuanlan.zhihu.com/p/148035779" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/148035779</a></p>
<p>不可重复读和幻读的区别：<a href="https://blog.csdn.net/jdnicky/article/details/91493719" target="_blank" rel="noopener">https://blog.csdn.net/jdnicky/article/details/91493719</a></p>
<p>MVCC：<a href="https://blog.csdn.net/DILIGENT203/article/details/100751755" target="_blank" rel="noopener">https://blog.csdn.net/DILIGENT203/article/details/100751755</a></p>
<p>MVCC和RR、RC的关系：<a href="https://www.zhihu.com/question/279538775/answer/1298076200" target="_blank" rel="noopener">https://www.zhihu.com/question/279538775/answer/1298076200</a></p>
<p>Redolog：<a href="https://blog.csdn.net/wanbin6470398/article/details/81941586" target="_blank" rel="noopener">https://blog.csdn.net/wanbin6470398/article/details/81941586</a></p>
<p>乐观锁和MVCC的区别：<a href="https://www.zhihu.com/question/27876575" target="_blank" rel="noopener">https://www.zhihu.com/question/27876575</a></p>
<p>隔离级别：<a href="https://www.bilibili.com/video/BV1yt411A7hp?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1yt411A7hp?p=2</a></p>
<pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> @@tx_isolation
<span class="hljs-keyword">SET</span> tx_isolation=<span class="hljs-string">'read-committed'</span>;
<span class="hljs-keyword">SET</span> tx_isolation=<span class="hljs-string">'repeatable-read'</span>;<span class="hljs-comment">----处于RR级别下的事务，不会受其他事务影响</span></code></pre>

<p>可重复读</p>
<blockquote>
<p>实现可重复读的隔离级别，只需要在事务开始的时候创建一致性视图，也叫做快照，之后的查询里都共用这个一致性视图，后续的事务对数据的更改是对当前事务是不可见的，这样就实现了可重复读</p>
</blockquote>
<p>读已经提交</p>
<blockquote>
<p>而读提交，每一个语句执行前都会重新计算出一个新的视图，这个也是可重复读和读提交在MVCC实现层面上的区别。</p>
</blockquote>
<p>感觉RP可以解决幻读：<a href="https://www.zhihu.com/question/372905832/answer/1106544250" target="_blank" rel="noopener">https://www.zhihu.com/question/372905832/answer/1106544250</a> 下@yangsoon的回答，RP下读的是快照</p>
<p>脏读： 加排它锁</p>
<p>不可重复读：加排它锁</p>
<p>幻读：临建锁。锁住了间隙，所以解决了幻读的插入</p>
<p>三大范式：<a href="https://zhuanlan.zhihu.com/p/63146817" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/63146817</a></p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>binlog、redolog、undolog：<a href="https://blog.csdn.net/lzhcoder/article/details/88814364" target="_blank" rel="noopener">https://blog.csdn.net/lzhcoder/article/details/88814364</a></p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>Spring的原型和 GOF 的原型的区别： GoF通过用原型实例指定创建对象的种类，而Spring容器用Bean定义指定创建对象的种类；GoF通过拷贝这些原型创建新的对象，而Spring容器根据Bean定义创建新对象。</p>
<p>SpringBoot的自动配置原理：<a href="https://juejin.im/post/5ea2593f6fb9a03c73799bf4" target="_blank" rel="noopener">https://juejin.im/post/5ea2593f6fb9a03c73799bf4</a></p>
<p>Spring的事务：</p>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>SpringMVC的请求过程：<a href="http://www.tianxiaobo.com/2018/06/29/Spring-MVC-%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A7%98-%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%85%E8%A1%8C%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">http://www.tianxiaobo.com/2018/06/29/Spring-MVC-%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A7%98-%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%85%E8%A1%8C%E8%BF%87%E7%A8%8B/</a></p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>大纲：</p>
<blockquote>
<p>redis为什么单线程、IO多路复用、redis和memcached的缺点、redis五种数据类型的底层数据结构、布隆过滤器、redis持久化、redis的过期删除机制、淘汰机制、redis主从、哨兵、集群、分布式锁、大key拆分</p>
<p><a href="https://juejin.im/post/5dccf260f265da0bf66b626d" target="_blank" rel="noopener">https://juejin.im/post/5dccf260f265da0bf66b626d</a></p>
</blockquote>
<p>Redis为什么是单线程：<a href="https://blog.csdn.net/AAA821/article/details/82930679" target="_blank" rel="noopener">https://blog.csdn.net/AAA821/article/details/82930679</a></p>
<blockquote>
<p>每个事情都是非常简单的（能在极短时间内完成）</p>
</blockquote>
<p>Redis和Memcached的对比：<a href="https://zhuanlan.zhihu.com/p/65013389" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/65013389</a></p>
<p>基本数据类型的应用场景：<a href="https://zhuanlan.zhihu.com/p/81455096" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/81455096</a></p>
<p>基本数据类型的底层原理：<a href="https://mp.weixin.qq.com/s/MT1tB2_7f5RuOxKhuEm1vQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/MT1tB2_7f5RuOxKhuEm1vQ</a></p>
<p>set类型实现交集、并集、差集：<a href="https://blog.csdn.net/oGuiGui12345/article/details/89634131" target="_blank" rel="noopener">https://blog.csdn.net/oGuiGui12345/article/details/89634131</a></p>
<p>Redis分布式锁：</p>
<p>渐进式rehash：<a href="https://blog.csdn.net/belalds/article/details/93713491" target="_blank" rel="noopener">https://blog.csdn.net/belalds/article/details/93713491</a></p>
<p>使用Redis实现消息队列：<a href="https://segmentfault.com/q/1010000010777585" target="_blank" rel="noopener">https://segmentfault.com/q/1010000010777585</a></p>
<p>redis和mysql数据不一致如何解决：<a href="https://www.bbsmax.com/A/gVdnqXWQ5W/" target="_blank" rel="noopener">https://www.bbsmax.com/A/gVdnqXWQ5W/</a></p>
<blockquote>
<ol>
<li>一般缓存是这样的：</li>
<li>#读的顺序是先读缓存，后读数据库</li>
<li>#写的顺序是先写数据库，然后写缓存</li>
<li>#每次更新了相关的数据，都要把该缓存清理掉</li>
<li>#为了避免极端条件下造成的缓存与数据库之间的数据不一致，缓存需要设置一个失效时间。时间到了，缓存自动被清理，达到缓存和数据库数据的“最终一致性”</li>
</ol>
<p>这个问题是：数据库有100台MAC，有人买了一台，那我去数据库修改数据，如果我数据库修改了数据变成了99，但是Redis里面还是100台，那这就是不一致</p>
<p>解决方法：请求进来时，先删除缓存，再去修改数据库，但是这样也有一个问题，高并发下，假如说缓存删了，进来一个请求查询数据，但是数据库还没有及时更新，此时还是100，那么这个请求读的数据还是100，读了以后把100再写回Redis中，这又会产生不一致。</p>
<p>解决方法：消息队列，如果我要修改一个MAC库存，那么我就把这个商品ID放入消息队列，修改结束再从队列中移出。请求进来时，先去缓存查，缓存没有再去消息队列看看，有就进入消息队列等待，直到商品从消息队列移出，再进去数据库查。</p>
<p>最终解决方法：先删除缓存、再把要修改的商品ID放入消息队列、请求先查缓存、再查消息队列、再查数据库。</p>
<p>问题：队列可能积累了大量更新操作，</p>
<p>最终极解决方法：不用Redis，只用数据库（比如银行）</p>
</blockquote>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列的优缺点：<a href="https://zhuanlan.zhihu.com/p/84007327" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/84007327</a></p>
<p>如何保证消息队列的可靠传输：<a href="https://zhuanlan.zhihu.com/p/59759422" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59759422</a></p>
<p>RabbitMQ和其他队列相比较的优缺点：</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>正向代理和反向代理：<a href="https://www.zhihu.com/question/24723688" target="_blank" rel="noopener">https://www.zhihu.com/question/24723688</a>   <strong>正向代理</strong>代理的对象是客户端，<strong>反向代理</strong>代理的对象是服务端</p>
<p>负载均衡算法：<a href="https://zhuanlan.zhihu.com/p/68733507（轮询、IP_Hash" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68733507（轮询、IP_Hash</a>, url_Hash，fair（响应时间最短）、weight（指定轮询记录））</p>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="Java秒杀"><a href="#Java秒杀" class="headerlink" title="Java秒杀"></a>Java秒杀</h3><p>秒杀问题总结：<a href="https://blog.csdn.net/NIUBILISI/article/details/89890716" target="_blank" rel="noopener">https://blog.csdn.net/NIUBILISI/article/details/89890716</a></p>
<p>秒杀流程：<a href="https://blog.csdn.net/niubilisi/article/details/89786480。" target="_blank" rel="noopener">https://blog.csdn.net/niubilisi/article/details/89786480。</a></p>
<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>Spring、Redis原理</p>
<p>nginx</p>
<p>dubbo</p>
<h2 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h2><p><a href="https://mp.weixin.qq.com/s/nzvg3e-RgM59zs9WSeUpLg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nzvg3e-RgM59zs9WSeUpLg</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%A7%8B%E6%8B%9B/">秋招</a>
                    
                      <a class="hover-with-bg" href="/categories/%E7%A7%8B%E6%8B%9B/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%A7%8B%E6%8B%9B/">秋招</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "简历问题&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
