<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>简历问题 - 郭寰宇</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>郭寰宇的个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-06-28 08:30">
      2020年6月28日 早上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      223
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="Java语法"><a href="#Java语法" class="headerlink" title="Java语法"></a>Java语法</h3><p>泛型擦除：<a href="https://www.cnblogs.com/wuqinglong/p/9456193.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuqinglong/p/9456193.html</a> </p>
<p>反射：<strong>运行时获取类的完整构造，并调用对应的方法</strong></p>
<blockquote>
<p>反射工作原理<br>当我们编写完一个Java项目之后，每个java文件都会被编译成一个.class文件，这些Class对象承载了这个类的所有信息，包括父类、接口、构造函数、方法、属性等，这些class文件在程序运行时会被ClassLoader加载到虚拟机中。当一个类被加载以后，Java虚拟机就会在内存中自动产生一个Class对象。我们通过new的形式创建对象实际上就是通过这些Class来创建，只是这个过程对于我们是不透明的而已。</p>
<p>反射的工作原理就是借助Class.java、Constructor.java、Method.java、Field.java这四个类在程序运行时动态访问和修改任何类的行为和状态</p>
</blockquote>
<blockquote>
<p>优点：</p>
<p>反射提高了Java程序的灵活性和扩展性，降低耦合性，提高自适应能力。它允许程序创建和控制任何类的对象，无需提高硬编码目标类</p>
<p>缺点：</p>
<p>性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此Java反射机制主要应用在对灵活性和扩展性要求很高的系统框架上,普通程序不建议使用</p>
<p>反射执行是要遍历这个对象的属性方法的（如果是字段就遍历相关对象全部字段，如果是是方法就遍历相关所有方法），当这个反射对象属性方法越多越复杂执行的时候，相对来说耗时越长。而通过对象直接执行调用是不需要经过这些复杂的操作</p>
</blockquote>
<p>intern方法：<a href="https://mp.weixin.qq.com/s/Av2phrOe_TXnRwD0SeYPCg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Av2phrOe_TXnRwD0SeYPCg</a></p>
<p>java的equals()和==的区别：<a href="https://blog.csdn.net/lcsy000/article/details/82782864" target="_blank" rel="noopener">https://blog.csdn.net/lcsy000/article/details/82782864</a></p>
<p>上界通配符和下界通配符：<a href="https://www.zhihu.com/question/20400700/answer/117464182?utm_source=wechat_session&amp;utm_medium=social&amp;s_s_i=Xoqz9XfT63KhUnqNqqxi548fbJvULd4%2FVS%2F1MrubiTk%3D&amp;s_r=1" target="_blank" rel="noopener">https://www.zhihu.com/question/20400700/answer/117464182?utm_source=wechat_session&amp;utm_medium=social&amp;s_s_i=Xoqz9XfT63KhUnqNqqxi548fbJvULd4%2FVS%2F1MrubiTk%3D&amp;s_r=1</a></p>
<blockquote>
<p>上界通配符，规定了上限，所以可以get读出来，但是不可以set存进去。就是我一定知道读出来的就是上限那个类型，但是编译器不知道存进去的类型是什么，就是规定了上限，但是没有规定下限。</p>
<p>下界通配符，规定了下限，所以可以set存进去，但是读出来就只能以Object类型接受了，因为所有类的父类都是Object</p>
<p>PECS：如何这个容器是生产者，一直有人从里面get，就使用上界通配符，如果容器是消费者，一直有人set，就使用下界通配符</p>
</blockquote>
<p>Java中的四种引用：<a href="https://www.cnblogs.com/coder306/p/13087581.html" target="_blank" rel="noopener">https://www.cnblogs.com/coder306/p/13087581.html</a></p>
<p>new的过程发生了什么？：<a href="https://blog.csdn.net/moHedong/article/details/79618048" target="_blank" rel="noopener">https://blog.csdn.net/moHedong/article/details/79618048</a>  <a href="https://www.cnblogs.com/chenyangyao/p/5296807.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenyangyao/p/5296807.html</a></p>
<blockquote>
<p>首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过，若没有，必须先执行相应的类加载过程。</p>
<p>在通过类加载检查通过后，接下来虚拟机将为新生对象分配内存, 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值、执行实例初始化代码</p>
</blockquote>
<p>Volatile：周志明深入理解JVM第三版 P448。总线风暴：<a href="https://blog.csdn.net/oschina_41790905/article/details/105951643" target="_blank" rel="noopener">https://blog.csdn.net/oschina_41790905/article/details/105951643</a></p>
<blockquote>
<p>基于 CPU 缓存一致性协议，JVM 实现了 volatile 的可见性，但由于总线嗅探机制，会不断的监听总线，如果大量使用 volatile 会引起总线风暴。所以，volatile 的使用要适合具体场景。</p>
<p>locak addl：<a href="https://www.jianshu.com/p/6ab7c3db13c3" target="_blank" rel="noopener">https://www.jianshu.com/p/6ab7c3db13c3</a></p>
<p>volatile：<a href="https://zhuanlan.zhihu.com/p/73126227" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73126227</a>      <a href="https://blog.csdn.net/oschina_41790905/article/details/105951643#comments_12751169" target="_blank" rel="noopener">https://blog.csdn.net/oschina_41790905/article/details/105951643#comments_12751169</a></p>
<p>为什么volatile不保证原子性：<a href="https://blog.csdn.net/xdzhouxin/article/details/81236356" target="_blank" rel="noopener">https://blog.csdn.net/xdzhouxin/article/details/81236356</a></p>
<p>我的理解是：对于多线程下res++，线程A读了值res为100，res值加1后，变成了101，但是还没有写会工作内存，此时阻塞，线程B进来，线程B操作后res值变成101，然后线程A把res写回工作内存，再刷新主存</p>
<p><a href="https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg</a></p>
<p>happens-before：<a href="https://baijiahao.baidu.com/s?id=1654963077694559106&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1654963077694559106&amp;wfr=spider&amp;for=pc</a>      <a href="https://www.cnblogs.com/tiancai/p/9636199.html" target="_blank" rel="noopener">https://www.cnblogs.com/tiancai/p/9636199.html</a></p>
</blockquote>
<p>HashMap扩容的时候读会有什么问题？：<a href="https://blog.csdn.net/bjwfm2011/article/details/81076736" target="_blank" rel="noopener">https://blog.csdn.net/bjwfm2011/article/details/81076736</a></p>
<blockquote>
<p>JDK7：如果读取的值的key和环形链表上的key相同，那么就会死循环</p>
<p>JDK8：尾插法可能会覆盖值，导致读不到</p>
</blockquote>
<p>HashMap：<a href="https://www.cnblogs.com/zhuifeng523/p/11390884.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuifeng523/p/11390884.html</a></p>
<p>HashMap链表转红黑树：<a href="https://www.jianshu.com/p/309ea054cbc9" target="_blank" rel="noopener">https://www.jianshu.com/p/309ea054cbc9</a></p>
<blockquote>
<p>如果链表长度大于8，但是数组长度&lt;64，只进行扩容</p>
<p>如果链表长度大于8，且数组长度&gt;=64，链表转成红黑树</p>
</blockquote>
<p>Hashtable+ConcurrentHashMap：</p>
<blockquote>
<p>JDK7—&gt;<a href="https://zhuanlan.zhihu.com/p/31614308" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31614308</a>      </p>
<p>​    ConcurrentHashMap：分段锁，数组+链表。</p>
<p>​            get方法：两次hash，定位到元素。值和next，使用volatile变量修饰，保证可见性</p>
<p>JDK8—–&gt;<a href="https://zhuanlan.zhihu.com/p/97902016" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/97902016</a> </p>
<p>​                <a href="https://www.jianshu.com/p/865c813f2726" target="_blank" rel="noopener">https://www.jianshu.com/p/865c813f2726</a></p>
<p>​    ConcurrentHashMap：CAS+synchronized。</p>
<p>​            put方法：计算哈希值+初始化+CAS+synchronized+帮助扩容</p>
<p>​            get方法：计算哈希值+遍历（链表/红黑树）。如果遇到扩容，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回</p>
</blockquote>
<p>Comparable和Comparator接口的区别：<a href="https://zhuanlan.zhihu.com/p/94359581" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/94359581</a></p>
<p>锁升级过程：<a href="https://blog.csdn.net/lengxiao1993/article/details/81568130" target="_blank" rel="noopener">https://blog.csdn.net/lengxiao1993/article/details/81568130</a>  <a href="https://www.cnblogs.com/paddix/p/5405678.html" target="_blank" rel="noopener">https://www.cnblogs.com/paddix/p/5405678.html</a></p>
<blockquote>
<p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令</p>
<p>轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁</p>
</blockquote>
<p>static关键字：<a href="https://www.cnblogs.com/swisszhang/p/9892992.html" target="_blank" rel="noopener">https://www.cnblogs.com/swisszhang/p/9892992.html</a></p>
<p>内部类和静态内部类的区别：<a href="https://www.zhihu.com/question/285579995" target="_blank" rel="noopener">https://www.zhihu.com/question/285579995</a>  <a href="https://www.cnblogs.com/ConstXiong/p/11871149.html" target="_blank" rel="noopener">https://www.cnblogs.com/ConstXiong/p/11871149.html</a>  <a href="https://blog.csdn.net/fgakjfd/article/details/5282646" target="_blank" rel="noopener">https://blog.csdn.net/fgakjfd/article/details/5282646</a></p>
<p>为什么wait，notify，notifyAll定义在Object中？：<a href="https://blog.csdn.net/pulusite/article/details/82287462" target="_blank" rel="noopener">https://blog.csdn.net/pulusite/article/details/82287462</a></p>
<p>一个class文件有几个类：<a href="https://blog.csdn.net/TTTiaotiao/article/details/95007780" target="_blank" rel="noopener">https://blog.csdn.net/TTTiaotiao/article/details/95007780</a></p>
<p>IO：<a href="https://github.com/stumon/JavaGuide/blob/master/docs/java/BIO-NIO-AIO.md">https://github.com/stumon/JavaGuide/blob/master/docs/java/BIO-NIO-AIO.md</a></p>
<p>error 和 exception：<a href="https://www.zhihu.com/question/26057769" target="_blank" rel="noopener">https://www.zhihu.com/question/26057769</a></p>
<p>ArrayList：<a href="https://mp.weixin.qq.com/s/3PNWmtS-bEZgZjd9wyMiDA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3PNWmtS-bEZgZjd9wyMiDA</a></p>
<p>final、finally、finalize的区别：</p>
<blockquote>
<p><strong>若父类中final方法的访问权限为private，将导致子类中不能直接继承该方法，因此，此时可以在子类中定义相同方法名的函数，此时不会与重写final的矛盾，而是在子类中重新地定义了新方法。</strong></p>
<p>final修饰引用：只是引用不可变，但是内存的值是可以变的</p>
<p>finally：1、当遇到System.exit(0)时，会直接退出程序，。2、try里面抛出异常，finally语句块也不会执行（<a href="https://www.cnblogs.com/ljysy/p/7846755.html）" target="_blank" rel="noopener">https://www.cnblogs.com/ljysy/p/7846755.html）</a> 。3、在try块或catch块中程序被中断，比如说死机</p>
<p>finalize：这个方法在gc启动，该对象被回收的时候被调用，一个对象的finalize()方法只会被调用一次，而且finalize()被调用不意味着gc会立即回收该对象</p>
</blockquote>
<p>Java中的多态：<a href="https://www.cnblogs.com/shuaifing/p/10762682.html" target="_blank" rel="noopener">https://www.cnblogs.com/shuaifing/p/10762682.html</a></p>
<p>String类为什么要被设计为final的？：不可变性支持线程安全、不可变性支持字符串常量池，提升性能。</p>
<p>notify和notifyAll的区别：前者会死锁，后者不会  <a href="https://www.jianshu.com/p/25e243850bd2?appinstall" target="_blank" rel="noopener">https://www.jianshu.com/p/25e243850bd2?appinstall</a></p>
<blockquote>
<p>单线程下可以用if代替while的，多线程不可以，否则就会出现：唤醒生产者的是另一个生产者或者唤醒消费者的是另一个消费者，这样的情况下用if就必然会现类似过度生产或者过度消费的情况了</p>
</blockquote>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>两个线程轮流打印字母和数字：<a href="https://www.cnblogs.com/jyx140521/p/6747750.html" target="_blank" rel="noopener">https://www.cnblogs.com/jyx140521/p/6747750.html</a></p>
<p>线程池使用无界队列的坑：<a href="https://blog.csdn.net/firefile/article/details/80745627" target="_blank" rel="noopener">https://blog.csdn.net/firefile/article/details/80745627</a></p>
<p>ConcurrentHashMap一定是线程安全吗？：<a href="https://blog.csdn.net/loveqishan/article/details/89393122（内部操作是，外部不是，比如线程A先根据keyget得到value，准备put(key,value+1)时，线程B进来put(key,value+1)，然后线程A再put，就会导致线程B的值被覆盖掉）" target="_blank" rel="noopener">https://blog.csdn.net/loveqishan/article/details/89393122（内部操作是，外部不是，比如线程A先根据keyget得到value，准备put(key,value+1)时，线程B进来put(key,value+1)，然后线程A再put，就会导致线程B的值被覆盖掉）</a></p>
<p>cglib：对指定的类生成一个子类，覆盖其中所有的方法并环绕增强，<strong>不可以代理</strong>被final修饰的类或方法</p>
<p>线程池原理：</p>
<p>ThreadLocal：<a href="https://mp.weixin.qq.com/s/bcH2pL06J5udBWedE1tbCA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/bcH2pL06J5udBWedE1tbCA</a></p>
<blockquote>
<p>如何做到线程互不干扰？：每一个线程都有一个自己的threadLocalMap，每一个线程访问自己的Map获取数据</p>
<p>老版本是维护一个大map，新版本是每一个线程维护自己的map</p>
<p>threadLocal的hash算法，是自己重写的。用黄金分割数，产生均匀的分布</p>
<p>为什么自定义map，不适用hashmap：key是弱引用，写数据和读数据的时候可以清理数据</p>
<p>每一个线程的threadLocalMap对象是懒加载。第一次调用get和set时，会检测是否创建，没有就去创建。只会被创建一次。初始化长度是16。扩容阈值是2/3，达到扩容阈值时，会rehash一次，先全表扫描，清理过期数据，如果清理完毕后，容量长度还达到扩容前的3/4，就会扩容。</p>
<p>扩容算法：创建一个新的数组，长度是老数组的长度的两倍，计算下次扩容的阈值，然后迭代老数组，把其中数组重新安装hash算法，放到新数组中。然后更新threadLocalMap的引用</p>
<p>set方法：根据key找到slot，如果slot为空，说明是新添加的数据，那么直接添加进去即可。如果不是空，先检查key是否相等，相等就更新数据，不相等就代表发生了哈希冲突，那么就需要向后找一个slot为空的位置，存放这个元素。如果查找过程，碰到了key相同的slot，就替换。如果碰到了过期数据，向后查找，如果找到key为空，就会重写value，然后用这个entry替换掉过期数据，如果一直遍历到null，都没有找到key相同的entry，就直接在过期数据这里重写一个slot，相当于抹掉这个slot</p>
<p>get方法：传进来的对象计算hash值，和（长度-1）按位与得到index，得到下标后，判断那个位置的元素key是否相同，如果是就返回value，如果不是，就继续查找。</p>
<p>get方法首次未命中，向后迭代的时候，如果碰到过期数据(当key对应的threadLocal对象被GC回收后，也就是key为null)的Entry，就会触发探测式清理，从当前位置向后迭代，清理key为null的entry。一直迭代到entry为null的位置为止。如果这个过程碰到了正常数据，就会重写hash，计算下标，放到里这个下标最近的位置。</p>
<p>哈希冲突解决方法：线性探测法</p>
</blockquote>
<p>AQS：</p>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>select、poll和epoll：</p>
<blockquote>
</blockquote>
<p>协程：编程语言级别的线程，用户态的线程，不需要切换到内核态</p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>常见的垃圾回收器：<a href="https://blog.csdn.net/weixin_43258908/article/details/89287217" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43258908/article/details/89287217</a></p>
<blockquote>
<p>Seriral：年轻代、复制算法、单线程、简单高效、Stop the World</p>
<p>Serial Old：老年代、标记整理算法、单线程、简单高效、Stop the World</p>
<p>Par New：常用于和CMS搭配使用</p>
<p>​    年轻代、复制算法、多线程</p>
<p>​    老年代、标记整理算法、</p>
<p>CMS：老年代、标记清除算法。过程：三次标记、一次清除。第一次和第三次过程会stop the world</p>
<p>Parrallel Scavenge：年轻代、复制算法、多线程。特点：关注吞吐量（运行用户代码时间/（运行用户代码时间+运行垃圾回收时间））。所以也叫作吞吐量优先回收器</p>
<p>Parrallel old：老年代、标记整理</p>
<p>G1：整堆收集器、标记整理。过程：三次标记、一次回收。除了第二次，都会stop the world。 特点：用户指定停顿时间</p>
</blockquote>
<p>GC ROOT：<strong>一组必须活跃的引用</strong>。虚拟机栈里面的引用的对象（局部变量、临时变量）、方法区中类静态属性引用的对象，方法区中常量引用的对象、JNI引用的对象、JVM内部引用如Class对象、被锁持有的对象</p>
<p>什么时候对象进入老年代：<a href="https://blog.csdn.net/dl674756321/article/details/102871999" target="_blank" rel="noopener">https://blog.csdn.net/dl674756321/article/details/102871999</a></p>
<blockquote>
<p>大对象直接进、新生代迭代次数超过一定阈值直接进</p>
</blockquote>
<p>什么时候回Full GC？</p>
<blockquote>
<p>调用System.gc()方法</p>
<p>如果新生代和老年代空间都不够，就会直接GC</p>
</blockquote>
<p>如何优化GC？</p>
<blockquote>
<p>调整新生代大小</p>
<p>不要创建过大的对象或数组</p>
<p>调大对象进入老年代的年龄</p>
</blockquote>
<p>如何打破双亲：重写loadclass方法，重写findclass方法</p>
<p>CPU100%如何排查：<a href="https://mp.weixin.qq.com/s/roEMz-5tzBZvGxbjq8NhOQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/roEMz-5tzBZvGxbjq8NhOQ</a></p>
<p>OOM如何排查：<a href="https://blog.csdn.net/fishinhouse/article/details/80781673" target="_blank" rel="noopener">https://blog.csdn.net/fishinhouse/article/details/80781673</a></p>
<blockquote>
<p>常见参数：<a href="https://www.cnblogs.com/anyehome/p/9071619.html" target="_blank" rel="noopener">https://www.cnblogs.com/anyehome/p/9071619.html</a></p>
</blockquote>
<p>JVM调优工具：</p>
<blockquote>
<p>教程：<a href="https://www.bilibili.com/video/BV1N741127Wt?t=51&amp;p=16" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1N741127Wt?t=51&amp;p=16</a></p>
<p>jps：列出 Java 上的所有进程</p>
<p>jstack：查看或导出Java应用程序中线程堆栈信息</p>
<p>jvisualvm：查看监控内存泄露，跟踪垃圾回收，执行时内存、cpu分析，线程分析</p>
</blockquote>
<p>JVM调优：</p>
<blockquote>
<p>内存溢出</p>
<p>​    原因：JVM内存过小、死循环或循环产生过多重复的对象实体、加载的数据量过于庞大、<strong>内存泄漏</strong></p>
<p>​    分析：使用jvisualvm分析dump，分析到底是内存泄漏还是内存溢出。如果是<strong>内存泄漏</strong>，可进一步通过工具查看泄漏对象到GC Roots的引用链，修复应用程序中的内存泄漏。如果是<strong>内存溢出</strong>，先检查是否有死循环。</p>
<p>​    解决方法：增加JVM的内存大小、避免死循环，防止一次载入太多的数据、及时地释放没用的对象，释放内存空间</p>
<p>内存泄漏</p>
<p>​    原因：程序在申请内存后，无法释放已申请的内存空间</p>
<p>​    特点：<strong>对象是可达的、对象是无用的</strong>。在程序中体现在，频繁GC，但是释放不了多少内存。比如静态static修饰对象。</p>
<p>​    解决方法：jvisualvm分析，定位代码（找出内存占用超出预期的嫌疑对象、分析程序的源代码，找出嫌疑对象数量过多的原因）</p>
<p>栈溢出：</p>
<p>​    栈里面放：局部变量表（重点）、操作数栈（重点）、动态链接，也称为指向运行时常量池的方法引用、方法返回地址，也称为方法退出的定义</p>
<p>​    描述：</p>
<p>​        如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常</p>
<p>​        如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常</p>
<p>​    原因：</p>
<p>​        单个线程下，栈帧太大，或者虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出StackOverflowError 异常</p>
<p>​        不断地建立线程的方式会导致内存溢出。</p>
<p>​    解决方法：看看是否有方法递归，避免递归在代码中无限循环</p>
<p>方法区溢出</p>
<p>​    原因：方法区用于存放Class的相关信息，如类名、访问修饰符、返回值、常量池、变量名、方法名等。<strong>静态变量也存储在方法区</strong>，生成了大量的类，导致方法区被撑爆</p>
<p>​    解决方法：检查是否永久代空间设置得过小、检查是否使用CGLib生成了大量的代理类</p>
</blockquote>
<p>TLAB：<a href="https://mp.weixin.qq.com/s/Wws24Fhg1nH4dHvtcFYi2g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Wws24Fhg1nH4dHvtcFYi2g</a></p>
<p>JDK和CGLIB的区别：<a href="https://blog.csdn.net/yhl_jxy/article/details/80635012" target="_blank" rel="noopener">https://blog.csdn.net/yhl_jxy/article/details/80635012</a></p>
<h3 id="设计模式（15-23）"><a href="#设计模式（15-23）" class="headerlink" title="设计模式（15/23）"></a>设计模式（15/23）</h3><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><blockquote>
<p>开闭原则、单一职责原则、里氏替换原则、依赖倒置原则、迪米特原则、接口隔离原则、组合原则</p>
</blockquote>
<p>设计模式分类：创建型、结构型、行为型</p>
<h4 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h4><p>解释：省去New的过程</p>
<blockquote>
<p>单例、原型、工厂方法、抽象工厂、建造者</p>
</blockquote>
<h5 id="DCL单例"><a href="#DCL单例" class="headerlink" title="DCL单例"></a>DCL单例</h5><pre><code class="hljs java"><span class="hljs-comment">//单例四大原则：构造私有、静态方法或者枚举返回实例、确保实例只有一个、反序列时不会重构对象</span></code></pre>

<h5 id="静态内部类单例"><a href="#静态内部类单例" class="headerlink" title="静态内部类单例"></a>静态内部类单例</h5><pre><code class="hljs java"><span class="hljs-comment">//为何是线程安全的：https://blog.csdn.net/mnb65482/article/details/80458571   </span>
<span class="hljs-comment">//https://zhuanlan.zhihu.com/p/31046230</span>
<span class="hljs-comment">//优点：静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存</span>
<span class="hljs-comment">//首先，我们注意到，在第一次调用getInstance方法之前，SingletonWrapper类是没有被加载的，因为它是一个静态内部类。当有线程第一次调用getInstance的时候，SingletonWrapper就会被class loader加载进JVM，在加载的同时，执行instance的初始化。所以，这种写法，仍然是一种懒汉式的单例类。为什么这样写就是线程安全的呢？大家要记住，类的加载的过程是单线程执行的。它的并发安全是由JVM保证的。所以，这样写的好处是在instance初始化的过程中，由JVM的类加载机制保证了线程安全，而在初始化完成以后，不管后面多少次调用getInstance方法都不会再遇到锁的问题了。</span>



<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticSingle</span> </span>&#123;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton instance=<span class="hljs-keyword">new</span> Singleton();
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> StaticSingle.instance;
    &#125;
&#125;</code></pre>

<h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><p>根据一个已经创建好的实例，不断的克隆出其他对象，省去了复杂的new过程。</p>
<p>但是原型的克隆分为浅克隆和深克隆，Object类的Clone方法为浅克隆，要想实现深克隆必须我们自己动手实现</p>
<pre><code class="hljs java"><span class="hljs-comment">//原型设计模式的设计原则：实现Cloneable接口，重写Clone方法</span>
<span class="hljs-comment">//浅克隆，我们只需要重写Clone方法，但是方法内部方法体不需要改变</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prototype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Prototype</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age,String name)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>.age=age;
        <span class="hljs-keyword">this</span>.name=name;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Prototype&#123;"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'&#125;'</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();
    &#125;
&#125;

<span class="hljs-comment">//深克隆，需要重写Clone方法的方法体</span>
<span class="hljs-meta">@Date</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrototypeDeep</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;
    <span class="hljs-keyword">private</span> Date date;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrototypeDeep</span><span class="hljs-params">(Date date, String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.date = date;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"PrototypeDeep&#123;"</span> +
                <span class="hljs-string">"date="</span> + date +
                <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'&#125;'</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> PrototypeDeep <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        PrototypeDeep prototypeDeep= (PrototypeDeep) <span class="hljs-keyword">super</span>.clone();
        Date cloneDate= (Date) <span class="hljs-keyword">this</span>.date.clone();
        prototypeDeep.date=cloneDate;
        <span class="hljs-keyword">return</span> prototypeDeep;
    &#125;
&#125;</code></pre>

<h5 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h5><p>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”</p>
<pre><code class="hljs java"><span class="hljs-comment">//简单工厂，不属于设计模式，但是这里引入简单工厂是为了后面铺垫，简单工厂只有一个工厂类</span>
<span class="hljs-comment">//缺点是，如果要增加新的产品，就需要修改源代码</span>
<span class="hljs-comment">//产品接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProductA</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">introduce</span><span class="hljs-params">()</span></span>;
&#125;
<span class="hljs-comment">//实现类</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Buick</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProductA</span></span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">introduce</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"this is Buick"</span>);
    &#125;
&#125;
<span class="hljs-comment">//实现类</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WuLing</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProductA</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">introduce</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"this is WuLing"</span>);
    &#125;
&#125;
<span class="hljs-comment">//简单工厂</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> ProductA <span class="hljs-title">Factory</span><span class="hljs-params">(String product)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span>(product.equals(<span class="hljs-string">"Buick"</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Buick();
        <span class="hljs-keyword">if</span> (product.equals(<span class="hljs-string">"WuLing"</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WuLing();<span class="hljs-comment">//如果想要增加新产品，就需要修改源代码</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
&#125;</code></pre>

<h5 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h5><p>定义一个<strong>创建产品对象的工厂接口</strong>，将产品对象的实际创建工作推迟到<strong>具体子工厂类当中</strong>。这满足创建型模式中所要求的“<strong>创建与使用相分离</strong>”的特点</p>
<p>“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p>
<p>工厂方法模式的主要优点有：</p>
<ul>
<li><p>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</p>
</li>
<li><p>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</p>
</li>
</ul>
<p>缺点是：每增加一个<strong>产品</strong>就要增加一个具体<strong>产品类</strong>和一个对应的<strong>具体工厂类</strong>，这增加了系统的复杂度。</p>
<h5 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h5><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<p>结构为：抽象产品、抽象工厂、具体产品、具体工厂</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200628095822.png" srcset="/img/loading.gif" alt="image-20200628095817985"></p>
<p>使用抽象工厂模式一般要满足以下条件。</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。<br>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</li>
</ul>
<p>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</p>
<p>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</p>
<p>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>
<p>按照上面的图片来写一个抽象工厂设计模式代码</p>
<h5 id="建造者"><a href="#建造者" class="headerlink" title="建造者"></a>建造者</h5><p>买汽车，不需要管汽车零件的生产步骤，只需要去4S店提车就可以，每一个车由很多部件构成，部件可以灵活选择，组织部件的顺序也可以灵活选择，这类产品的创建无法用工厂模式描述，建造者模式就是用来描述这类产品的创建</p>
<p>定义：它是将<strong>一个复杂的对象分解为多个简单的对象</strong>，然后一步一步构建而成。它将<strong>变与不变相分离</strong>，即产品的<strong>组成部分是不变的</strong>，但<strong>每一部分是可以灵活选择的</strong>。</p>
<p>组成：</p>
<p>产品角色：包含多个组件</p>
<p>抽象建造者：包含创建产品各个组件的抽象方法的接口</p>
<p>具体建造者：实现接口，完成创建各个组件的方法</p>
<p>指挥者：按照一定顺序调用建造者的方法</p>
<h4 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h4><p>解释：将<strong>类和对象</strong>结合在一起成为一个更大的结构。分为类结构型和对象结构型模式。</p>
<p>​    类结构模型关心<strong>类的组合</strong>，由多个类可以组成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系；</p>
<p>​    对象结构型模式<strong>关心类与对象的组合</strong>，通过<strong>组合关系</strong>使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。根据“<strong>组合复用原则</strong>”，在系统中尽量使用组合关系来替代继承关系，因此大部分结构型模式都是对象结构型模式</p>
<blockquote>
<p>代理、适配器、桥接、装饰、享元、外观、组合</p>
</blockquote>
<h5 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h5><p>定义</p>
<blockquote>
<p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，<strong>访问对象</strong>不适合或者<strong>不能直接引用目标对象</strong>，<strong>代理对象作为访问对象和目标对象之间的中介。</strong></p>
</blockquote>
<p>你不想上课，找人替你去上课，那个人就是代理。</p>
<p>优点</p>
<blockquote>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>
</ul>
</blockquote>
<p>缺点</p>
<blockquote>
<ul>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度</li>
</ul>
</blockquote>
<p>组成</p>
<blockquote>
<p>抽象主题类：可以是接口也可以是抽象类，用来进行业务定义</p>
<p>真实主题类（被代理类）：用来实现真正的业务逻辑</p>
<p>代理类：它负责控制对真实主题类访问的控制，在真实主题类中的方法上实现一些增强功能</p>
<p>客户端：访问代理类实现某些业务</p>
</blockquote>
<h6 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h6><pre><code class="hljs java"><span class="hljs-comment">//静态代理，代理类实现增加功能</span>
<span class="hljs-comment">//下面以租房为例，中介是搭理，房东是真实角色，两人共同的业务是收房租</span>
<span class="hljs-comment">//接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Rent</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">price</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">//真实主题</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Landlord</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Rent</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"房屋价格是XXX"</span>);
    &#125;
&#125;
<span class="hljs-comment">//代理主题</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Rent</span></span>&#123;
    <span class="hljs-keyword">private</span> Landlord landlord;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StaticProxy</span><span class="hljs-params">(Landlord landlord)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.landlord = landlord;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"代理类实现XXXXX功能"</span>);
        landlord.price();
    &#125;
&#125;
<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        Landlord landlord=<span class="hljs-keyword">new</span> Landlord();
        StaticProxy staticProxy=<span class="hljs-keyword">new</span> StaticProxy(landlord);
        staticProxy.price();
    &#125;
&#125;</code></pre>

<h6 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h6><p>静态代理缺点是每一个真实对象都要生成一个代理对象，代码量翻倍</p>
<pre><code class="hljs java"><span class="hljs-comment">//实现一个代理类，然后从动态的生成代理对象</span>
<span class="hljs-comment">//代理类，Rent接口和Host类在上面的静态代理类中已经定义了，所以这里省略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;
    <span class="hljs-keyword">public</span> Rent rent;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Rent <span class="hljs-title">getRent</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> rent;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRent</span><span class="hljs-params">(Rent rent)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.rent = rent;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span>  Proxy.newProxyInstance(<span class="hljs-keyword">this</span>.getClass().getClassLoader(),rent.getClass().getInterfaces(),<span class="hljs-keyword">this</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
        Object invoke = method.invoke(rent, args);
        <span class="hljs-keyword">return</span> invoke;
    &#125;
&#125;

<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        Landlord landlord=<span class="hljs-keyword">new</span> Landlord();
        DynamicProxy dynamicProxy=<span class="hljs-keyword">new</span> DynamicProxy();
        dynamicProxy.setRent(landlord);
        Rent proxy = (Rent) dynamicProxy.getProxy();
        proxy.price();
    &#125;
&#125;</code></pre>

<h5 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h5><p>定义：<strong>将一个类的接口转换成客户希望的另外一个接口</strong>，<strong>使得原本由于接口不兼容而不能一起工作的那些类能一起工作</strong>。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<p>优点</p>
<blockquote>
<ul>
<li>客户端通过适配器可以透明地调用目标接口。</li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>
</ul>
</blockquote>
<p>缺点：</p>
<p>对类适配器来说，更换适配器的实现过程比较复杂</p>
<p>结构组成</p>
<blockquote>
<p>距离：去美国出差，手机没电了，但是只带了一个<strong>中国220V标准电压的充电头</strong>，美国插座是<strong>240V标准电压</strong>，所以需要一个<strong>转换头</strong>，把240V的交流电转成220V的，这样才可以给手机充电。这个过程中，目标就是220V接口，适配者类就是240V接口，适配器类就是转换头。</p>
<ol>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ol>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//目标接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Target</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;

&#125;

<span class="hljs-comment">//适配者------被适配的类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">"被适配者的方法---220V"</span>);
    &#125;
&#125;

<span class="hljs-comment">//适配器-----将被适配的类转成需要的类。继承被适配者、实现目标接口，在重写的方法中调用父类方法</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;
        function();
    &#125;
&#125;</code></pre>

<h5 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h5><p>比如手机有很多品牌，每一个品牌又有不同的内存，如果我们设计手机，有两种方案，一种是一个一个设计，比如小米4G、小米8G、华为4G、华为8G等，另外一种方案是：把手机品牌和手机内存分开设计，然后组合两者。这样降低了两者的耦合、也减少了代码量</p>
<p>定义</p>
<blockquote>
<p><strong>将抽象与实现分离，使它们可以独立变化</strong>。它是用<strong>组合关系代替继承关系来实现</strong>，从而降低了抽象和实现这两个可变维度的耦合度</p>
</blockquote>
<p>优点</p>
<blockquote>
<ul>
<li>由于抽象与实现分离，所以扩展能力强；</li>
<li>其实现细节对客户透明。</li>
</ul>
</blockquote>
<p>缺点</p>
<blockquote>
<p>由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度</p>
</blockquote>
<p>组成</p>
<blockquote>
<p>抽象类：手机抽象类，包含一个对实现化角色的引用</p>
<p>扩展抽象类：具体的品牌，小米、华为。实现抽象类中的业务方法，通过组合来调用实现类接口中的业务方法</p>
<p>实现类接口：内存。定义实现化角色的接口，光扩展抽象化角色调用</p>
<p>具体实现类：具体的内存型号，给出具体实现</p>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//抽象类</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;
    <span class="hljs-keyword">public</span> Memory memory;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemory</span><span class="hljs-params">(Memory memory)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>.memory=memory;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span></span>;

&#125;
<span class="hljs-comment">//扩展抽象类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Phone</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"Mi Phone memory:"</span>);
        memory.MemorySize();
        System.out.println(<span class="hljs-string">"======="</span>);
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuaWeiPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Phone</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"Hua Wei memory size:"</span>);
        memory.MemorySize();
    &#125;
&#125;

<span class="hljs-comment">//扩展类接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Memory</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MemorySize</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">//具体实现类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memory4G</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Memory</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MemorySize</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"4G内存"</span>);
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memory8G</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Memory</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MemorySize</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"8G内存"</span>);
    &#125;
&#125;
<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        Memory memory4G=<span class="hljs-keyword">new</span> Memory4G();
        Memory memory8G=<span class="hljs-keyword">new</span> Memory8G();
        Phone phone1=<span class="hljs-keyword">new</span> MiPhone();
        Phone phone2=<span class="hljs-keyword">new</span> HuaWeiPhone();
        phone1.setMemory(memory4G);
        phone2.setMemory(memory8G);
        phone1.info();
        phone2.info();
    &#125;
&#125;</code></pre>



<h5 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h5><p>去吃饭，你可以在面的基础上不断加料，这样就有了：牛肉面、鸡蛋牛肉面、番茄鸡蛋牛肉面等，也可以在米饭的基础上加牛肉、鸡蛋、蔬菜等配料</p>
<p>定义</p>
<blockquote>
<p>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来<strong>创建一个包装对象（即装饰对象）来包裹真实对象</strong>，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标</p>
</blockquote>
<p>组成</p>
<blockquote>
<ol>
<li><p>抽象被装饰者（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。——面的抽象接口</p>
</li>
<li><p>具体被装饰者（Concrete  Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。——具体的面：牛肉面、鸡蛋面等</p>
</li>
<li><p>抽象装饰者（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。—-各种料</p>
</li>
<li><p>具体装饰者（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。—-具体的料：鸡蛋、牛肉、蔬菜等</p>
</li>
</ol>
<p>要点：</p>
<p>  1 多种具体被装饰者（主体类）抽象出一个抽象被装饰类，后面通过多态，动态传递具体对象。</p>
<p>  2 抽象装饰类<strong>继承</strong>抽象被装饰者（保持接口）；要求传入被装饰者（使用父类应用、protected修饰）；</p>
<p>  3 多种具体装饰者抽象出一个抽象装饰类。</p>
<p>  4 具体装饰者中，可以添加新方法，可以重写方法；需要使用被装饰者方法的地方用传入的被装饰者引用。</p>
</blockquote>
<p>缺点</p>
<blockquote>
<p>装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//以吃面为例，普通面、牛肉面、鸡蛋牛肉面、蔬菜鸡蛋牛肉面，牛肉米饭、鸡蛋米饭</span>
<span class="hljs-comment">//抽象父类---食物</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">//实现类---面条</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Noodle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"面条"</span>);
    &#125;
&#125;
<span class="hljs-comment">//实现类----米饭</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"米饭"</span>);
    &#125;
&#125;
<span class="hljs-comment">//抽象装饰者类</span>
<span class="hljs-comment">/*</span>
<span class="hljs-comment">1.抽象装饰者类中继承该抽象类以保持接口规范</span>
<span class="hljs-comment">2.包含该抽象类的引用以通过多态的方式对多种被装饰者类进行装饰。</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span></span>&#123;
    <span class="hljs-keyword">protected</span> Food food;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Decorator</span><span class="hljs-params">(Food food)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.food = food;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> food.cal();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        food.display();
    &#125;
&#125;
<span class="hljs-comment">//具体装饰者类---牛肉</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeefDecoractor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decorator</span></span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BeefDecoractor</span><span class="hljs-params">(Food food)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(food);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.cal()+<span class="hljs-number">10</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">super</span>.display();
        System.out.println(<span class="hljs-string">"+牛肉"</span>);
    &#125;
&#125;

<span class="hljs-comment">//具体装饰者类---鸡蛋</span>
<span class="hljs-comment">//继承抽象的被装饰者类，并实现其中的抽象方法。</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EggDecoractor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decorator</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EggDecoractor</span><span class="hljs-params">(Food food)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(food);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.cal()+<span class="hljs-number">2</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">super</span>.display();
        System.out.println(<span class="hljs-string">"+鸡蛋"</span>);
    &#125;
&#125;
<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        Food food=<span class="hljs-keyword">new</span> Noodle();
        Decorator beefDecoractor=<span class="hljs-keyword">new</span> BeefDecoractor(<span class="hljs-keyword">new</span> EggDecoractor(<span class="hljs-keyword">new</span> BeefDecoractor(food)));<span class="hljs-comment">//面里面加两份牛肉，一份鸡蛋</span>
        System.out.println(beefDecoractor.cal());

    &#125;
&#125;</code></pre>

<p>类图：</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200628145900.png" srcset="/img/loading.gif" alt="image-20200628145855384"></p>
<h5 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h5><blockquote>
<p>是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>
<p>外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。</p>
<ol>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
</ol>
<p>外观（Facade）模式的主要缺点如下。</p>
<ol>
<li>不能很好地限制客户使用子系统类。</li>
<li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
</ol>
</blockquote>
<h5 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h5><blockquote>
<p>组合（Composite）模式的定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p>
<p>组合模式的主要优点有：</p>
<ol>
<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li>
<li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li>
</ol>
<p>其主要缺点是：</p>
<ol>
<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li>
<li>不容易限制容器中的构件；</li>
<li>不容易用继承的方法来增加构件的新功能；</li>
</ol>
</blockquote>
<h5 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h5><blockquote>
<p>运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
<p>享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p>
<p>其主要缺点是：</p>
<ol>
<li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li>
<li>读取享元模式的外部状态会使得运行时间稍微变长。</li>
</ol>
</blockquote>
<h4 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h4><p>解释描述程序在运行时复杂的流程控制，即描述<strong>多个类或对象之间怎样相互协作</strong>共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<blockquote>
<p><strong>模板方法</strong>、<strong>策略</strong>、命令、职责链、状态、<strong>观察者</strong>、中介者、迭代器、访问者、备忘录、解释器</p>
</blockquote>
<h5 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h5><p>定义</p>
<blockquote>
<p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p>
</blockquote>
<p>优点</p>
<blockquote>
<ol>
<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在父类中提取了公共的部分代码，便于代码复用。</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
<li>我们在定义行为时候都是由父类去定义，然后子类去实现即可。</li>
</ol>
</blockquote>
<p>缺点</p>
<blockquote>
<ol>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
</ol>
</blockquote>
<p>组成</p>
<blockquote>
<p>(1) 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。</p>
<p>① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p>
<p>② 基本方法：是整个算法中的一个步骤，包含以下几种类型。</p>
<ul>
<li>抽象方法：在抽象类中申明，由具体子类实现。</li>
<li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li>
<li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li>
</ul>
<p>(2) 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。</p>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//以做饭为例，小明和小红做饭，同样一道菜，相同的步骤，俩人做出来的菜味道就是不一样，因为每一个步骤的执行效果不同</span>
<span class="hljs-comment">//抽象类-----这道菜的正常执行步骤是1、2、3、4</span>
<span class="hljs-keyword">package</span> com.guo.TemplatePattern;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cook</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step3</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step4</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">executeStep3</span><span class="hljs-params">()</span><span class="hljs-comment">//钩子函数，由子类决定某一个函数是否要执行</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>.step1();
        <span class="hljs-keyword">this</span>.step2();
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.executeStep3())
        &#123;
            <span class="hljs-keyword">this</span>.step3();
        &#125;
        <span class="hljs-keyword">this</span>.step4();
    &#125;
&#125;


<span class="hljs-comment">//子类----XM做饭</span>
<span class="hljs-keyword">package</span> com.guo.TemplatePattern;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XMCook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cook</span></span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> executeStep3=<span class="hljs-keyword">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExecuteStep3</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> executeStep3)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.executeStep3 = executeStep3;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step1</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XM--1"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XM--2"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step3</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XM--3"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step4</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XM--4"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">executeStep3</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.executeStep3;
    &#125;
&#125;

<span class="hljs-comment">//子类---XH做饭</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XHCook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cook</span></span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> executeStep3=<span class="hljs-keyword">true</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExecuteStep3</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> executeStep3)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.executeStep3 = executeStep3;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step1</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XH=====1"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XH=====2"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step3</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XH=====3"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step4</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"XH=====4"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">executeStep3</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.executeStep3();
    &#125;
&#125;

<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        Cook xmCook=<span class="hljs-keyword">new</span> XMCook();
        xmCook.cook();
        XMCook xmCook=<span class="hljs-keyword">new</span> XMCook();
        xmCook.setExecuteStep3(<span class="hljs-keyword">false</span>);
        xmCook.cook();
    &#125;
&#125;</code></pre>

<h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><p>在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，购物，有不同的折扣，商家根据用户的不同级别打不同的折扣，普通人不打折，会员打9折，超级会员打6折等。</p>
<p>定义</p>
<blockquote>
<p><strong>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换</strong>，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
</blockquote>
<p>组成</p>
<blockquote>
<ol>
<li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。———购买东西的抽象</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。———-不同会员实现不同的打折（普通会员8折、超级会员6折等）</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。———-收银台</li>
</ol>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//抽象策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Buyer</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">calPrice</span><span class="hljs-params">(BigDecimal price)</span></span>;
&#125;


<span class="hljs-comment">//具体实现---针对普通人的计算价格策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrdinaryPeople</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Buyer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">calPrice</span><span class="hljs-params">(BigDecimal price)</span> </span>&#123;
        <span class="hljs-keyword">return</span> price;
    &#125;
&#125;
<span class="hljs-comment">//针对VIP的策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VIP</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Buyer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">calPrice</span><span class="hljs-params">(BigDecimal price)</span> </span>&#123;
        <span class="hljs-keyword">return</span> price.multiply(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">0.8</span>));
    &#125;
&#125;
<span class="hljs-comment">//针对SVIP的策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SVIP</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Buyer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">calPrice</span><span class="hljs-params">(BigDecimal price)</span> </span>&#123;
        <span class="hljs-keyword">return</span> price.multiply(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">0.5</span>));
    &#125;
&#125;
<span class="hljs-comment">//环境类---这里是收银台</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cashier</span> </span>&#123;
    <span class="hljs-keyword">private</span> Buyer buyer;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cashier</span><span class="hljs-params">(Buyer buyer)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.buyer = buyer;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">quote</span><span class="hljs-params">(BigDecimal price)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.buyer.calPrice(price);
    &#125;
&#125;

<span class="hljs-comment">//测试</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
    Buyer strategy1=<span class="hljs-keyword">new</span> OrdinaryPeople();
    Buyer strategy2=<span class="hljs-keyword">new</span> VIP();
    Buyer strategy3=<span class="hljs-keyword">new</span> SVIP();
    Cashier cashier1=<span class="hljs-keyword">new</span> Cashier(strategy1);
    BigDecimal quote=cashier1.quote(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">300</span>));
    System.out.println(<span class="hljs-string">"普通人购买价格"</span>+quote.doubleValue());
    Cashier cashier2=<span class="hljs-keyword">new</span> Cashier(strategy2);
    BigDecimal quote2=cashier2.quote(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">300</span>));
    System.out.println(<span class="hljs-string">"VIP购买价格"</span>+quote2.doubleValue());
    Cashier cashier3=<span class="hljs-keyword">new</span> Cashier(strategy3);
    BigDecimal quote3=cashier3.quote(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">300</span>));
    System.out.println(<span class="hljs-string">"SVIP购买价格"</span>+quote3.doubleValue());

&#125;</code></pre>



<h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><p>举例：明星发微博，粉丝自动收到提示，这就是观察者模式的一种体现。明星是被观察者，粉丝是观察者</p>
<p>定义</p>
<blockquote>
<p>指多个对象间存<strong>在一对多的依赖关系</strong>，<strong>当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</strong>。这种模式有时<strong>又称作发布-订阅模式</strong>、模型-视图模式，它是对象行为型模式。</p>
</blockquote>
<p>优点</p>
<blockquote>
<ol>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li>
<li>目标与观察者之间建立了一套触发机制。</li>
</ol>
</blockquote>
<p>缺点</p>
<blockquote>
<ol>
<li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li>
<li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li>
</ol>
</blockquote>
<p>组成</p>
<blockquote>
<p>主题：主题是观察者观察的对象，一个主题必须具备下面三个特征。</p>
<ul>
<li>持有监听的观察者的引用（以微博明星和粉丝为例，明星有自己的粉丝列表）</li>
<li>支持增加和删除观察者（明星可以拉黑自己的粉丝，也可以增加自己的粉丝—比如取消拉黑）</li>
<li>主题状态改变，通知观察者（明星有动态后，自动提醒粉丝）</li>
</ul>
<p>观察者：当主题发生变化，收到通知进行具体的处理是观察者必须具备的特征。（粉丝收到明星动态更新后，可以去查看具体动态）</p>
</blockquote>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">//抽象主题----明星</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Star</span> </span>&#123;
    <span class="hljs-comment">//add Fans</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFans</span><span class="hljs-params">(Fan fan)</span></span>;
    <span class="hljs-comment">//delete Fans</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteFan</span><span class="hljs-params">(Fan fan)</span></span>;
    <span class="hljs-comment">//notify Fans</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyFan</span><span class="hljs-params">(String msg)</span></span>;
&#125;

<span class="hljs-comment">//具体主题---具体的一个明星</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Star</span></span>&#123;
    <span class="hljs-keyword">public</span> List&lt;Fan&gt; list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFans</span><span class="hljs-params">(Fan fan)</span> </span>&#123;
        list.add(fan);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteFan</span><span class="hljs-params">(Fan fan)</span> </span>&#123;
        list.remove(fan);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyFan</span><span class="hljs-params">(String msg)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (Fan fan : list) &#123;
            fan.receive(msg);
        &#125;
    &#125;
&#125;

<span class="hljs-comment">//抽象观察者----粉丝</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Fan</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(String msg)</span></span>;
&#125;

<span class="hljs-comment">//具体观察者----某一个粉丝，具体的粉丝</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Fan</span> </span>&#123;
    <span class="hljs-keyword">public</span> String name;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteFan</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(String msg)</span> </span>&#123;
        System.out.println(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">"收到了动态"</span>+msg);
    &#125;
&#125;
<span class="hljs-comment">//测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
        ConcreteStar star=<span class="hljs-keyword">new</span> ConcreteStar();
        ConcreteFan fan1=<span class="hljs-keyword">new</span> ConcreteFan(<span class="hljs-string">"qq"</span>);
        ConcreteFan fan2=<span class="hljs-keyword">new</span> ConcreteFan(<span class="hljs-string">"ww"</span>);
        ConcreteFan fan3=<span class="hljs-keyword">new</span> ConcreteFan(<span class="hljs-string">"ss"</span>);
        ConcreteFan fan4=<span class="hljs-keyword">new</span> ConcreteFan(<span class="hljs-string">"aa"</span>);
        star.addFans(fan1);
        star.addFans(fan2);
        star.addFans(fan3);
        star.addFans(fan4);
        star.notifyFan(<span class="hljs-string">"Hello World"</span>);
    &#125;
&#125;</code></pre>



<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p>跳表可以理解为可以使用二分法的数组。就是在链表上加多层索引。</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200628183828.png" srcset="/img/loading.gif" alt="image-20200628183825168"></p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>组成：由多个哈希函数+二进制的位向量。</p>
<p>可以判断一个元素是否存在，但是有误判率</p>
<p>假设输入对象个数为n，bitarray大小（也就是布隆过滤器大小）为m，所容忍的误判率p和哈希函数的个数k。计算公式如下：（<strong>小数向上取整</strong>）</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200628184001.png" srcset="/img/loading.gif" alt="image-20200628183958868"></p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>一致性哈希：<a href="https://zhuanlan.zhihu.com/p/34985026" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34985026</a> （一个圆环、缺点是查询慢、优点是只影响局部数据或服务器）</p>
<h3 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h3><p>线程池：<a href="https://zhuanlan.zhihu.com/p/73990200" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73990200</a></p>
<p>两个线程轮流打印奇偶数：<a href="https://blog.csdn.net/qq_28619473/article/details/90722878" target="_blank" rel="noopener">https://blog.csdn.net/qq_28619473/article/details/90722878</a></p>
<p>介绍ReentrantLock：类似于synchronized，特点：公平锁、可中断、唤醒指定现场</p>
<h3 id="JVM-1"><a href="#JVM-1" class="headerlink" title="JVM"></a>JVM</h3><p>如何打破双亲委派机制：想打破双亲委派模型，那么就重写整个loadClass方法。如果不想打破双亲委派模型，那么只需要重写findClass方法即可</p>
<p>.class和getClass()的区别：.class用于类名，getClass()是一个final native的方法，因此用于类实例。。.class在编译期间就确定了一个类的java.lang.Class对象，但是getClass()方法在运行期间确定一个类实例的java.lang.Class对象</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>cookie和session的区别：<a href="https://www.cnblogs.com/l199616j/p/11195667.html" target="_blank" rel="noopener">https://www.cnblogs.com/l199616j/p/11195667.html</a></p>
<p>浏览器输入<a href="http://www.baicu.com发生了什么：https://www.cnblogs.com/tylerdonet/p/11613455.html">www.baicu.com发生了什么：https://www.cnblogs.com/tylerdonet/p/11613455.html</a></p>
<h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><p>TCP如何保证可靠传输：<a href="https://blog.csdn.net/QEcode/article/details/90339162" target="_blank" rel="noopener">https://blog.csdn.net/QEcode/article/details/90339162</a></p>
<p>如何设计一个可靠的UDP：<a href="https://blog.csdn.net/weixin_42388901/article/details/102477507" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42388901/article/details/102477507</a></p>
<p>TCP问题：<a href="https://zhuanlan.zhihu.com/p/108822858" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/108822858</a></p>
<p>TCP三次握手：为什么需要三次，SYN攻击</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><h3 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h3><p>幂等性：指一次和多次请求某一个资源应该具有同样的副作用</p>
<blockquote>
<p>传统的HTTP协议通信：传统的HTTP报文是直接将报文信息传输到TCP然后TCP再通过TCP套接字发送给目的主机上。</p>
<p>HTTPS协议通信：HTTPS是HTTP报文直接将报文信息传输给SSL套接字进行加密，SSL加密后将加密后的报文发送给TCP套接字，然后TCP套接字再将加密后的报文发送给目的主机，目的主机将通过TCP套接字获取加密后的报文给SSL套接字，SSL解密后交给对应进程</p>
</blockquote>
<p>CA：</p>
<p>SSL握手：</p>
<blockquote>
<p>第一步：客户端发送给服务端自己所支持的<strong>秘钥算法和一个随机数R1</strong></p>
<p>第二步：服务端从秘钥算法中选择三种加密算法（对称加密算法、MCA算法、公钥加密算法），<strong>生成一个随机数R2</strong>，把这<strong>三种加密算法和证书+随机数R2</strong>发送给客户端</p>
<p>第三步：客户端验证证书是否合法，然后从证书中取出<strong>公钥</strong>，自己再生成一个<strong>随机数R3</strong>，利用公钥对这个随机数加密，生成<strong>PreMasterKey</strong>，把它发送给服务端</p>
<p>第四步：客户端收到<strong>PreMasterKey</strong>后，利用自己的私钥解密后得到随机数R3，至此双方都知道了加密算法和三个随机数。</p>
<p>第五步：两边根据加密算法和三个随机数，生成秘钥<strong>Key</strong>，握手结束。以后的应用层数据都使用这个秘钥进行对称加密。</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/e30a8c4fa329" target="_blank" rel="noopener">https://www.jianshu.com/p/e30a8c4fa329</a></p>
<p><a href="https://www.bilibili.com/video/BV1EK4y1b7Mu/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1EK4y1b7Mu/?spm_id_from=333.788.videocard.0</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/32513816" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32513816</a></p>
<p><a href="https://juejin.im/post/584b76d3a22b9d0058d5036f" target="_blank" rel="noopener">https://juejin.im/post/584b76d3a22b9d0058d5036f</a></p>
<p>TCP如何保证可靠传输：<a href="https://www.jianshu.com/p/6aac4b2a9fd7" target="_blank" rel="noopener">https://www.jianshu.com/p/6aac4b2a9fd7</a></p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>常用命令：<a href="https://blog.csdn.net/xulong_08/article/details/81463054" target="_blank" rel="noopener">https://blog.csdn.net/xulong_08/article/details/81463054</a></p>
<blockquote>
<p>创建文件夹 nkdir  创建文件 touch  </p>
<p>查询CPU占用最多的十个进程：ps（报告当前系统的进程状态） top（类似于windows的任务管理器）  free（显示当前系统未使用的和已使用的内存数目）</p>
<p>top命令下，按M是把结果安装内存大小排序，按P是按照CPU占用率排序</p>
<p>查询日期：Date</p>
<p>删除文件 rm -f</p>
<p>搜索文件 find / -name file1</p>
<p>创建用户和群组 groupadd group_name   usedadd user_name</p>
<p>查看文件 cat   tail</p>
<p>显示当前java进程pid</p>
<p>查看硬盘情况：df -lh</p>
</blockquote>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>大纲：<a href="https://www.bilibili.com/video/BV1YE411D7nH?p=29" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YE411D7nH?p=29</a></p>
<p>进程和线程的区别：<a href="https://www.zhihu.com/question/25532384/answer/81152571" target="_blank" rel="noopener">https://www.zhihu.com/question/25532384/answer/81152571</a>   <a href="https://www.cnblogs.com/ConstXiong/p/11680304.html" target="_blank" rel="noopener">https://www.cnblogs.com/ConstXiong/p/11680304.html</a></p>
<p>用户线程和守护线程：<a href="https://www.cnblogs.com/myseries/p/12078413.html" target="_blank" rel="noopener">https://www.cnblogs.com/myseries/p/12078413.html</a></p>
<p>进程间通信（IPC）的方式：<a href="https://www.bilibili.com/video/BV1YE411D7nH?p=10" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YE411D7nH?p=10</a>  (管道、套接字、信号交互、共享内存、消息队列)   <a href="https://blog.csdn.net/qq_32534441/article/details/89639985" target="_blank" rel="noopener">https://blog.csdn.net/qq_32534441/article/details/89639985</a></p>
<p>线程间通信的方式：wait和notify、volatile、ReentLock <a href="https://blog.csdn.net/jisuanji12306/article/details/86363390" target="_blank" rel="noopener">https://blog.csdn.net/jisuanji12306/article/details/86363390</a></p>
<p>进程互斥：<a href="https://www.bilibili.com/video/BV1YE411D7nH?p=18" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YE411D7nH?p=18</a></p>
<blockquote>
<p>单标志法：只检查，不上锁。缺点：违背空闲让进原则</p>
<p>双标志先检查法：先检查后上锁吗，缺点：同时访问临界资源，<strong>因为检查和上锁不是一气呵成的</strong></p>
<p>双标志后检查法：上锁在前，检查在后。缺点：两个进程都进不去</p>
<p>Peterson算法：双标志后检查法+礼让。如果两个线程都想进入，就礼让。缺点：CPU忙等—&gt;不遵守让权等待</p>
<p>信号量：PV原语</p>
</blockquote>
<p>避免死锁：银行家算法：<a href="https://www.bilibili.com/video/BV1YE411D7nH?p=30" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YE411D7nH?p=30</a></p>
<blockquote>
<p>四个矩阵</p>
<p>最大需求</p>
<p>已分配</p>
<p>最多还需要</p>
<p>剩余可用资源</p>
<p>通过计算，剩余可分配资源是否大于最多还需要资源，来决定是否分配资源</p>
</blockquote>
<p>局部性原理：<a href="https://www.zhihu.com/question/25142664" target="_blank" rel="noopener">https://www.zhihu.com/question/25142664</a></p>
<p>虚拟内存：<a href="https://juejin.im/post/59f8691b51882534af254317" target="_blank" rel="noopener">https://juejin.im/post/59f8691b51882534af254317</a>      <a href="https://zhuanlan.zhihu.com/p/82746153" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/82746153</a></p>
<p>虚拟内存,共享内存和常驻内存的区别：<a href="https://www.cnblogs.com/yangtze736-2013-3-6/p/3449090.html" target="_blank" rel="noopener">https://www.cnblogs.com/yangtze736-2013-3-6/p/3449090.html</a></p>
<p>虚拟地址，逻辑地址和物理地址的区别：<a href="https://www.jianshu.com/p/42a4c21bcef4" target="_blank" rel="noopener">https://www.jianshu.com/p/42a4c21bcef4</a></p>
<p>内存页的置换算法：<a href="https://blog.csdn.net/csdn_dwk/article/details/96869413" target="_blank" rel="noopener">https://blog.csdn.net/csdn_dwk/article/details/96869413</a> （LRU、LFU）</p>
<h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>一条SQL执行流程：<a href="https://zhuanlan.zhihu.com/p/95082274" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/95082274</a> （缓存、解析器、预处理器、查询优化器、执行、查询执行引擎）</p>
<p>char和varchar的区别：<a href="https://www.cnblogs.com/canger/p/9845969.html" target="_blank" rel="noopener">https://www.cnblogs.com/canger/p/9845969.html</a></p>
<p>左连接、右连接、内连接：<a href="https://www.cnblogs.com/wanglijun/p/8916790.html" target="_blank" rel="noopener">https://www.cnblogs.com/wanglijun/p/8916790.html</a></p>
<p>Delete、Drop、Ttuncate区别：<a href="https://blog.csdn.net/fzy198926/article/details/78190633" target="_blank" rel="noopener">https://blog.csdn.net/fzy198926/article/details/78190633</a></p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>联合索引失效问题：<a href="https://mp.weixin.qq.com/s/COpOB4JJa0Tj4aFn2EawRQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/COpOB4JJa0Tj4aFn2EawRQ</a></p>
<blockquote>
<ol>
<li>联合索引的最左前缀匹配指的是where条件一定要有联合索引的第一个字段</li>
<li>是否走联合索引与where条件的顺序无关，只与字段有关</li>
</ol>
</blockquote>
<p>聚簇索引和非聚簇索引：<a href="https://blog.csdn.net/u013132035/article/details/82193763" target="_blank" rel="noopener">https://blog.csdn.net/u013132035/article/details/82193763</a></p>
<p>explain：<a href="https://blog.csdn.net/wuseyukui/article/details/71512793" target="_blank" rel="noopener">https://blog.csdn.net/wuseyukui/article/details/71512793</a></p>
<blockquote>
<p>type：<a href="https://www.cnblogs.com/chancy/p/10684452.html" target="_blank" rel="noopener">https://www.cnblogs.com/chancy/p/10684452.html</a>        一种数据库引擎查找表的一种方式</p>
</blockquote>
<p>SQL调优：</p>
<p>唯一索引和普通索引选择问题：<a href="https://www.cnblogs.com/lamp01/p/10752100.html" target="_blank" rel="noopener">https://www.cnblogs.com/lamp01/p/10752100.html</a></p>
<p>B树和B+树的时间复杂度：logN  <a href="http://m.elecfans.com/article/662237.html" target="_blank" rel="noopener">http://m.elecfans.com/article/662237.html</a></p>
<p>为什么用B+树不用B树：</p>
<blockquote>
<pre><code class="hljs txt">&gt;数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。
&gt;B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作</code></pre>
</blockquote>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>死锁：<a href="https://www.cnblogs.com/xinruyi/p/11109058.html" target="_blank" rel="noopener">https://www.cnblogs.com/xinruyi/p/11109058.html</a></p>
<p>悲观锁：通过加锁实现，比如 for update</p>
<p>乐观锁：CAS+版本号</p>
<p>读锁：加读锁：Lock Table XX read 。解锁 unlock tables</p>
<p>写锁：加写锁：Lock Table XX write。解锁：unlock tables</p>
<p>共享锁（读锁）：Lock in share mode（<strong>当前读</strong>）。只允许其他人读，不允许其他人写</p>
<p>排它锁（写锁）：for update。其他事务既不能读，也不能写</p>
<p>表锁：锁住整个表</p>
<p>行锁：锁住一行，就是给索引上的索引项加锁。如果没有就是表锁</p>
<p>临建锁（Next-Key）和 间隙锁：<a href="https://blog.csdn.net/WSYW126/article/details/105324239/" target="_blank" rel="noopener">https://blog.csdn.net/WSYW126/article/details/105324239/</a></p>
<p>测试了一个下午，发现也和他的结果不一样，草：<a href="https://blog.csdn.net/WSYW126/article/details/105324239/" target="_blank" rel="noopener">https://blog.csdn.net/WSYW126/article/details/105324239/</a></p>
<p>区间问题：</p>
<blockquote>
<p>根据检索条件向下寻找最靠近检索条件的记录值X作为左区间，向上寻找最靠近检索条件的记录值Y作为右区间，即锁定的间隙为（X，Y）。</p>
</blockquote>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务：<a href="https://zhuanlan.zhihu.com/p/148035779" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/148035779</a></p>
<p>不可重复读和幻读的区别：<a href="https://blog.csdn.net/jdnicky/article/details/91493719" target="_blank" rel="noopener">https://blog.csdn.net/jdnicky/article/details/91493719</a></p>
<p>MVCC：<a href="https://blog.csdn.net/DILIGENT203/article/details/100751755" target="_blank" rel="noopener">https://blog.csdn.net/DILIGENT203/article/details/100751755</a></p>
<p>MVCC和RR、RC的关系：<a href="https://www.zhihu.com/question/279538775/answer/1298076200" target="_blank" rel="noopener">https://www.zhihu.com/question/279538775/answer/1298076200</a></p>
<p>Redolog：<a href="https://blog.csdn.net/wanbin6470398/article/details/81941586" target="_blank" rel="noopener">https://blog.csdn.net/wanbin6470398/article/details/81941586</a></p>
<p>乐观锁和MVCC的区别：<a href="https://www.zhihu.com/question/27876575" target="_blank" rel="noopener">https://www.zhihu.com/question/27876575</a></p>
<p>隔离级别：<a href="https://www.bilibili.com/video/BV1yt411A7hp?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1yt411A7hp?p=2</a></p>
<pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> @@tx_isolation
<span class="hljs-keyword">SET</span> tx_isolation=<span class="hljs-string">'read-committed'</span>;
<span class="hljs-keyword">SET</span> tx_isolation=<span class="hljs-string">'repeatable-read'</span>;<span class="hljs-comment">----处于RR级别下的事务，不会受其他事务影响</span></code></pre>

<p>可重复读</p>
<blockquote>
<p>实现可重复读的隔离级别，只需要在事务开始的时候创建一致性视图，也叫做快照，之后的查询里都共用这个一致性视图，后续的事务对数据的更改是对当前事务是不可见的，这样就实现了可重复读</p>
</blockquote>
<p>读已经提交</p>
<blockquote>
<p>而读提交，每一个语句执行前都会重新计算出一个新的视图，这个也是可重复读和读提交在MVCC实现层面上的区别。</p>
</blockquote>
<p>感觉RP可以解决幻读：<a href="https://www.zhihu.com/question/372905832/answer/1106544250" target="_blank" rel="noopener">https://www.zhihu.com/question/372905832/answer/1106544250</a> 下@yangsoon的回答，RP下读的是快照</p>
<p>脏读： 加排它锁</p>
<p>不可重复读：加排它锁</p>
<p>幻读：临建锁。锁住了间隙，所以解决了幻读的插入</p>
<p>三大范式：<a href="https://zhuanlan.zhihu.com/p/63146817" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/63146817</a></p>
<p>串行化隔离级别的问题：<a href="https://blog.csdn.net/weixin_38553453/article/details/83037979" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38553453/article/details/83037979</a> （读读是允许的，但是读写不允许，所以就会导致死锁。解决方法：直接加写锁）</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>binlog、redolog、undolog：<a href="https://blog.csdn.net/lzhcoder/article/details/88814364" target="_blank" rel="noopener">https://blog.csdn.net/lzhcoder/article/details/88814364</a></p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>IOC：IOC（Inversion of Control）控制反转，将创建对象和对象之间的依赖关系交给了spring容器。借助于“第三方”实现具有依赖关系的对象之间的解耦</p>
<p><strong>Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制</strong></p>
<p><strong>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的</strong></p>
<blockquote>
<p>优点</p>
<p>实现了组件之间的解耦，提高了代码的灵活性和可维护性</p>
<p>缺点</p>
<p>由于IOC容器生成对象是通过反射方式，在运行效率上有一定的损耗。如果你要追求运行效率的话，就必须对此进行权衡。</p>
<p><strong>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</strong></p>
</blockquote>
<p>Spring的原型和 GOF 的原型的区别： GoF通过用原型实例指定创建对象的种类，而Spring容器用Bean定义指定创建对象的种类；GoF通过拷贝这些原型创建新的对象，而Spring容器根据Bean定义创建新对象。</p>
<p>Spring容器组成：单例池、三级缓存、beanFactory、beanDefinition、后置处理器等组件</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>Spring注解</p>
<blockquote>
<p>@Component：把这个<strong>类</strong>交给Spring容器管理 </p>
<p>@Configuration：定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器</p>
<p>​    要求：@Configuration不可以是final类型；@Configuration不可以是匿名类；嵌套的configuration必须是静态类。</p>
<p>@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。SpringIOC 容器管理一个或者多个bean，这些bean都需要在<strong>@Configuration</strong>注解下进行创建</p>
<p>用<strong>@Configuration</strong>注解标注的类表明其主要目的是作为bean定义的<strong>源</strong>，@Configuration和@Bean搭配，生成的bean是经过CGLIB增强的</p>
<p>@Configuration 和 @Component 区别： <code>@Configuration</code> 中所有带 <code>@Bean</code> 注解的方法都会被动态代理，因此调用该方法返回的都是同一个实例。<a href="https://blog.csdn.net/isea533/article/details/78072133" target="_blank" rel="noopener">https://blog.csdn.net/isea533/article/details/78072133</a>  <a href="https://www.cnblogs.com/CodeBear/p/10304605.html" target="_blank" rel="noopener">https://www.cnblogs.com/CodeBear/p/10304605.html</a></p>
<p>@postConstruct：<a href="https://www.cnblogs.com/cherishforchen/p/11330832.html。执行顺序：Constructor" target="_blank" rel="noopener">https://www.cnblogs.com/cherishforchen/p/11330832.html。执行顺序：Constructor</a> &gt;&gt; @Autowired &gt;&gt; @PostConstruct</p>
</blockquote>
<p>SpringBoot的自动配置原理：<a href="https://juejin.im/post/5ea2593f6fb9a03c73799bf4" target="_blank" rel="noopener">https://juejin.im/post/5ea2593f6fb9a03c73799bf4</a></p>
<p>Spring Bean的生命周期：<a href="https://me.csdn.net/java_lyvee" target="_blank" rel="noopener">https://me.csdn.net/java_lyvee</a>   <a href="https://juejin.im/post/5e4791a7f265da5715630629" target="_blank" rel="noopener">https://juejin.im/post/5e4791a7f265da5715630629</a></p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200716160636" srcset="/img/loading.gif" alt="img"></p>
<blockquote>
<p>下面是一种说法</p>
<p>1：实例化一个ApplicationContext的对象；———&gt;初始化Spring容器<br>2：调用bean工厂后置处理器（beanFactoryPostProcessor）完成<strong>扫描</strong>；—&gt;初始化容器时，Spring会new一个对象ClassPathBeanDefinitionScanner。这个对象会去扫描包。<br>3：循环<strong>解析</strong>扫描出来的类信息（ConfigurationClassPostProcessor：会解析加了@Configuration的配置类，还会解析@ComponentScan、@ComponentScans注解扫描的包，以及解析@Import等注解）；====&gt;判断这个类是不是符合标准的类、或者要不要立刻实例化（单例需要，原型不需要）<br>4：实例化一个BeanDefinition对象来<strong>存储解析</strong>出来的信息（调用AnnotatedBeanDefinitionReader去把class变成BD对象，但是仅作用于加了注解的类）；<br>5：把<strong>实例化好的</strong>beanDefinition对象put到beanDefinitionMap当中<strong>缓存起来</strong>，以便后面实例化bean；（调用BeanDefinitionRegistry去把bd对象放到Map中，因为这个Map是私有的，所以无法直接put进去，需要调用BDR对象）<br>6：再次调用bean工厂后置处理器；<br>7：当然spring还会干很多事情，比如国际化，比如注册BeanPostProcessor等等，如果我们只关心如何实例化一个bean的话那么<strong>这一步就是</strong>spring调用finishBeanFactoryInitialization方法来<strong>实例化单例的bean</strong>，<strong>实例化之前spring要做验证</strong>，需要遍历所有扫描出来的类，依次判断这个bean是否Lazy，是否prototype，是否abstract等等；<br>8：如果<strong>验证完成</strong>，spring在实例化一个bean之前需要<strong>推断构造方法</strong>，因为spring实例化对象是通过构造方法反射，故而需要知道用哪个构造方法；<br>9：推断完构造方法之后spring调用构造方法<strong>反射实例化一个对象</strong>；注意我这里说的是对象、对象、对象；这个时候对象已经实例化出来了，但是并不是一个完整的bean，最简单的体现是这个时候实例化出来的对象属性是没有注入，所以不是一个完整的bean；</p>
<p>10：spring处理合并后的beanDefinition(合并？是spring当中非常重要的一块内容，后面的文章我会分析)；<br>11：判断是否支持<strong>循环依赖</strong>，如果支持则提前<strong>把一个工厂（存的是当前bean，产生对这个bean加工后的产品）存入singletonFactories——map</strong>；（<strong>提前暴露工厂</strong>）<br>12：判断是否需要<strong>完成属性注入</strong><br>13：如果需要完成属性注入，则<strong>开始注入属性</strong><br>14：判断bean的类型<strong>回调Aware接口</strong><br>15：调用*<em>生命周期回调方法 *</em>   @PostConstruct和@PreDestroy是当前Bean声明周期的初始化回调和销毁时回调<br>16：如果需要代理则完成代理<br>17：put到单例池——bean完成——存在spring容器当中</p>
<p>如何控制属性注入：实现InstantiationAwareBeanPostProcessor，重写postProcessAfterInstantiation方法</p>
</blockquote>
<p>BeanFactoryPostProcessor的执行时机：<a href="https://blog.csdn.net/java_lyvee/article/details/102633067" target="_blank" rel="noopener">https://blog.csdn.net/java_lyvee/article/details/102633067</a></p>
<blockquote>
<p>BeanFactoryPostProcessor：可以干扰beanFactory的初始化过程</p>
<p>如果是直接实现<code>BeanFactoryPostProcessor</code>的类：spring扫描类之后、实例化bean之前</p>
<p>程序员一般提供BeanFactoryPostProcessor是为了对beanFactory做修改或者叫做干预他的初始化</p>
</blockquote>
<p>Spring的循环依赖怎么解决？：<a href="https://blog.csdn.net/java_lyvee/article/details/101793774" target="_blank" rel="noopener">https://blog.csdn.net/java_lyvee/article/details/101793774</a> （核心是三级缓存）</p>
<p>Spring为什么不支持构造器注入：Spring解决循环依赖依靠的是Bean的“中间态”这个概念，而这个中间态指的是已经实例化，但还没初始化的状态。而构造器是完成实例化的东东，所以构造器的循环依赖无法解决</p>
<p><strong>Java之所以没有循环依赖</strong>，是因为Java一旦new出来对象，这个对象就可以用了，而Spring不同，new出来的对象，不是完整的bean，不可用。从Spring容器中拿不到</p>
<blockquote>
<p>Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（<code>singletonObjects</code>）,二级缓存为早期曝光对象<code>earlySingletonObjects</code>，三级缓存为早期曝光对象工厂（<code>singletonFactories</code>）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！</p>
</blockquote>
<p>为什么要使用三级缓存呢？二级缓存能解决循环依赖吗</p>
<blockquote>
<ol>
<li><code>singletonObjects</code>，一级缓存，存储的是所有创建好了的单例Bean</li>
<li><code>earlySingletonObjects</code>，完成实例化，但是还未进行属性注入及初始化的对象</li>
<li><code>singletonFactories</code>，提前暴露的一个单例工厂，二级缓存中存储的就是从这个工厂中获取到的对象</li>
</ol>
<p>三次缓存存在的必要性？如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过<code>AnnotationAwareAspectJAutoProxyCreator</code>这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。</p>
<p>三级缓存的作用：防止工厂重复创建相同的对象</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200713105509.png" srcset="/img/loading.gif" alt="image-20200713105507256"></p>
</blockquote>
<blockquote>
</blockquote>
<p>BeanFactory和FactoryBean的区别：<a href="https://zhuanlan.zhihu.com/p/87382038" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/87382038</a> （前者是接口，Spring容器都是它的具体实现，后者是一个工厂bean，生成Bean，典型应用时创建AOP代理对象）</p>
<p>Spring依赖注入的方式：构造器注入和setter注入（使用反射）</p>
<p>注入模型：在xml文件里面注入、byName, byType（这两个就是找set方法）, constructor(后面三种是自动注入)</p>
<p>动态代理：JDK接口代理（为接口动态生成代理类、切面织入到代理类中）、CGLIB类代理（运行期间，目标类加载后，生成子类，将切面逻辑加入到子类中）</p>
<p>AOP：<a href="https://www.cnblogs.com/joy99/p/10941543.html" target="_blank" rel="noopener">https://www.cnblogs.com/joy99/p/10941543.html</a></p>
<blockquote>
<p>Spring AOP在容器初始化的时候完成了代理。bean工厂：默认是DefaultListableBeanFactory</p>
</blockquote>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>SpringMVC的请求过程：<a href="http://www.tianxiaobo.com/2018/06/29/Spring-MVC-%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A7%98-%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%85%E8%A1%8C%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">http://www.tianxiaobo.com/2018/06/29/Spring-MVC-%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A7%98-%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%85%E8%A1%8C%E8%BF%87%E7%A8%8B/</a></p>
<blockquote>
<p>首先，用户的浏览器发出了一个请求，这个请求经过互联网到达了我们的服务器。Servlet 容器首先接待了这个请求，并将该请求委托给 DispatcherServlet 进行处理。接着 DispatcherServlet 将该请求传给了处理器映射组件 HandlerMapping，并获取到适合该请求的拦截器和处理器。在获取到处理器后，DispatcherServlet 还不能直接调用处理器的逻辑，需要进行对处理器进行适配。处理器适配成功后，DispatcherServlet 通过处理器适配器 HandlerAdapter 调用处理器的逻辑，并获取返回值 ModelAndView。之后，DispatcherServlet 需要根据 ModelAndView 解析视图。解析视图的工作由 ViewResolver 完成，若能解析成功，ViewResolver 会返回相应的视图对象 View。在获取到具体的 View 对象后，最后一步要做的事情就是由 View 渲染视图，并将渲染结果返回给用户。</p>
</blockquote>
<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p>SpringBoot的自动配置：<a href="https://blog.csdn.net/u014745069/article/details/83820511" target="_blank" rel="noopener">https://blog.csdn.net/u014745069/article/details/83820511</a></p>
<blockquote>
<p>Spring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，它能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性如：server.port，而XxxxProperties类是通过@ConfigurationProperties注解与全局配置文件中对应的属性进行绑定的。</p>
</blockquote>
<h2 id="Mabitis"><a href="#Mabitis" class="headerlink" title="Mabitis"></a>Mabitis</h2><p>#{}和${}的区别：<a href="https://blog.csdn.net/qq_24916847/article/details/83501199" target="_blank" rel="noopener">https://blog.csdn.net/qq_24916847/article/details/83501199</a>   <a href="https://blog.csdn.net/weixin_44863976/article/details/100626051" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44863976/article/details/100626051</a></p>
<p><a href="https://blog.csdn.net/m0_37732829/article/details/91489766" target="_blank" rel="noopener">https://blog.csdn.net/m0_37732829/article/details/91489766</a></p>
<blockquote>
<p><strong>#相当于对数据 加上 双引号，$相当于直接显示数据</strong></p>
<p>#{}是<strong>预编译处理</strong>，${}是字符串替换</p>
<p>mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</p>
<p>mybatis在处理后者时，会把把${}替换成变量的值。</p>
<p>前者会被预编译成一个占位符，后者是一个字符串替换。前者会对解析后的string自动加引号、后者不做处理。</p>
<p>前者防止sql注入，后者防止</p>
<p>某些场合只可以用后者，例如：在使用排序时ORDER BY ${id}，如果使用#{id}，则会被解析成ORDER BY “id”</p>
</blockquote>
<p>SQL注入：把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。它是将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>大纲：</p>
<blockquote>
<p>redis为什么单线程、IO多路复用、redis和memcached的缺点、redis五种数据类型的底层数据结构、布隆过滤器、redis持久化、redis的过期删除机制、淘汰机制、redis主从、哨兵、集群、分布式锁、大key拆分</p>
<p><a href="https://juejin.im/post/5dccf260f265da0bf66b626d" target="_blank" rel="noopener">https://juejin.im/post/5dccf260f265da0bf66b626d</a></p>
</blockquote>
<p>Redis为什么是单线程：<a href="https://blog.csdn.net/AAA821/article/details/82930679" target="_blank" rel="noopener">https://blog.csdn.net/AAA821/article/details/82930679</a></p>
<p>Redis的跳表：<a href="https://blog.csdn.net/zlx_code/article/details/90581451" target="_blank" rel="noopener">https://blog.csdn.net/zlx_code/article/details/90581451</a></p>
<blockquote>
<p>每个事情都是非常简单的（能在极短时间内完成）</p>
</blockquote>
<p>Redis和Memcached的对比：<a href="https://zhuanlan.zhihu.com/p/65013389" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/65013389</a></p>
<p>基本数据类型的应用场景：<a href="https://zhuanlan.zhihu.com/p/81455096" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/81455096</a></p>
<p>基本数据类型的底层原理：<a href="https://mp.weixin.qq.com/s/MT1tB2_7f5RuOxKhuEm1vQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/MT1tB2_7f5RuOxKhuEm1vQ</a></p>
<p>set类型实现交集、并集、差集：<a href="https://blog.csdn.net/oGuiGui12345/article/details/89634131" target="_blank" rel="noopener">https://blog.csdn.net/oGuiGui12345/article/details/89634131</a></p>
<p>Redis分布式锁：<a href="https://www.bilibili.com/video/BV1TE411q7Jd?p=3" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1TE411q7Jd?p=3</a>  使用分布式锁控制多个线程对一个资源的访问</p>
<blockquote>
<p>使用redis分布锁主要注意三个问题：加锁、解锁、锁超时</p>
<p>这三个问题又会衍生出其他问题：UUID、ThreadLocal、超时时间、异步线程续命</p>
<p>注意：key是共享资源，value是UUID+线程ID</p>
<p>版本一：</p>
<p>setnx设值key，用变量flag记录返回值，如果flag为1，就知道获得了锁，如果为0，就没有获得锁。</p>
<p>如果线程A获得了锁，就执行对资源的操作A。操作完毕后，删除这个key。</p>
<p>存在问题1：如果操作A出现异常，程序会中断，也就<strong>没有执行删除key操作</strong>，其他线程也就拿不到锁</p>
<p>解决方法：try catch finally。在finally里面执行删除key</p>
<p>问题2：线程A因为意外阻塞在操作A那里，原因可能是停电，或者被kill了。那么删除key操作也不会执行</p>
<p>解决方法：加一个超时机制setnx</p>
<p>问题3：setnx和setex不是原子性，先执行完setnx后，可能没有执行setex就阻塞在那里了</p>
<p>解决方法：把这两个操作封装到LUA脚本中，成为一个原子性操作</p>
<p>问题4：线程A对key加锁，如何防止其他线程对key解锁</p>
<p>解决方法：使用UUID生成一个随机字符串str，共享资源作为key，str作为value。释放锁的时候判断一下，如果UUID生成的字符串和value相等，再进行删除key操作</p>
<p>问题5：当前线程如何去拿自己独有的UUID（也就是该线程下商品ID对应的value）？</p>
<p>解决方法：ThreadLocal。</p>
<p>问题6：假如说我线程A的任务还没有执行完，但是超时时间到了，假如说线程B得到了锁，B再去执行任务，此时就出现了<strong>锁失效</strong>问题，也就是说锁没有用了</p>
<p>解决方法：注册一个定时任务监听这个锁，每隔10秒就去查看这个锁，如果还持有锁，就对过期时间进行续期。默认过期时间30秒。这个机制也被叫做：“看门狗”</p>
<p>问题7：如果这个方法内部，多次调用自己，怎么实现一个<strong>可重入锁</strong></p>
<p>解决方法：使用ThreadLocal获取value，判断进来的value和ThreadLocal存的value是否相等，如果相等，就用一个变量记录，重入一次+1，释放一次-1。</p>
<p>setnx（如果key存在，就会返回0，不存在返回1）和setex（设置key的失效时间，覆盖value）。 </p>
</blockquote>
<p>渐进式rehash：<a href="https://blog.csdn.net/belalds/article/details/93713491" target="_blank" rel="noopener">https://blog.csdn.net/belalds/article/details/93713491</a></p>
<p>使用Redis实现消息队列：<a href="https://segmentfault.com/q/1010000010777585" target="_blank" rel="noopener">https://segmentfault.com/q/1010000010777585</a></p>
<p>redis和mysql数据不一致如何解决：<a href="https://www.bbsmax.com/A/gVdnqXWQ5W/" target="_blank" rel="noopener">https://www.bbsmax.com/A/gVdnqXWQ5W/</a></p>
<blockquote>
<ol>
<li>一般缓存是这样的：</li>
<li>#读的顺序是先读缓存，后读数据库</li>
<li>#写的顺序是先写数据库，然后写缓存</li>
<li>#每次更新了相关的数据，都要把该缓存清理掉</li>
<li>#为了避免极端条件下造成的缓存与数据库之间的数据不一致，缓存需要设置一个失效时间。时间到了，缓存自动被清理，达到缓存和数据库数据的“最终一致性”</li>
</ol>
<p>这个问题是：数据库有100台MAC，有人买了一台，那我去数据库修改数据，如果我数据库修改了数据变成了99，但是Redis里面还是100台，那这就是不一致</p>
<p>解决方法：请求进来时，先删除缓存，再去修改数据库，但是这样也有一个问题，高并发下，假如说缓存删了，进来一个请求查询数据，但是数据库还没有及时更新，此时还是100，那么这个请求读的数据还是100，读了以后把100再写回Redis中，这又会产生不一致。</p>
<p>解决方法：消息队列，如果我要修改一个MAC库存，那么我就把这个商品ID放入消息队列，修改结束再从队列中移出。请求进来时，先去缓存查，缓存没有再去消息队列看看，有就进入消息队列等待，直到商品从消息队列移出，再进去数据库查。</p>
<p>最终解决方法：先删除缓存、再把要修改的商品ID放入消息队列、请求先查缓存、再查消息队列、再查数据库。</p>
<p>问题：队列可能积累了大量更新操作，</p>
<p>最终极解决方法：不用Redis，只用数据库（比如银行）</p>
</blockquote>
<p>REDIS缓存穿透，缓存击穿，缓存雪崩原因+解决方案：<a href="https://www.cnblogs.com/xichji/p/11286443.html" target="_blank" rel="noopener">https://www.cnblogs.com/xichji/p/11286443.html</a></p>
<blockquote>
<p>缓存穿透：布隆过滤器</p>
<p>缓存击穿：热点key永不失效、互斥锁</p>
<p>缓存雪崩：key随机设置过期值</p>
</blockquote>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列的优缺点：<a href="https://zhuanlan.zhihu.com/p/84007327" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/84007327</a></p>
<p>如何保证消息队列的可靠传输：<a href="https://zhuanlan.zhihu.com/p/59759422" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59759422</a></p>
<p>RabbitMQ和其他队列相比较的优缺点：</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>正向代理和反向代理：<a href="https://www.zhihu.com/question/24723688" target="_blank" rel="noopener">https://www.zhihu.com/question/24723688</a>   <strong>正向代理</strong>代理的对象是客户端，<strong>反向代理</strong>代理的对象是服务端</p>
<p>负载均衡算法：<a href="https://zhuanlan.zhihu.com/p/68733507（轮询、IP_Hash" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68733507（轮询、IP_Hash</a>, url_Hash，fair（响应时间最短）、weight（指定轮询记录））</p>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="Java秒杀"><a href="#Java秒杀" class="headerlink" title="Java秒杀"></a>Java秒杀</h3><p>秒杀项目介绍：<a href="https://blog.csdn.net/NIUBILISI/article/details/90174526" target="_blank" rel="noopener">https://blog.csdn.net/NIUBILISI/article/details/90174526</a></p>
<p>秒杀问题总结：<a href="https://blog.csdn.net/NIUBILISI/article/details/89890716" target="_blank" rel="noopener">https://blog.csdn.net/NIUBILISI/article/details/89890716</a>  </p>
<p>秒杀流程：<a href="https://blog.csdn.net/niubilisi/article/details/89786480。" target="_blank" rel="noopener">https://blog.csdn.net/niubilisi/article/details/89786480。</a></p>
<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>TopK：<a href="https://blog.csdn.net/djrm11/article/details/87924616" target="_blank" rel="noopener">https://blog.csdn.net/djrm11/article/details/87924616</a></p>
<p>两个人取石头 每次最少1个，最多a个，共有n个 有必胜策略吗？：</p>
<p>1000瓶水，1瓶有毒，最少要多少只老鼠才能试出这瓶水？二进制解决，混合后复用给老鼠</p>
<p>25匹马，5个赛道，怎么用最少的次数决出前三名：先选出来第一名、再选第二名、再选第三名。8次</p>
<p>生产者和消费者：<a href="https://www.jianshu.com/p/25e243850bd2?appinstall" target="_blank" rel="noopener">https://www.jianshu.com/p/25e243850bd2?appinstall</a></p>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>Spring、Redis原理</p>
<p>nginx</p>
<p>dubbo</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>深入理解JVM说：Class对象作为方法区这个类的各种数据访问的入口，那为什么new关键字是去方法区上找符号引用呢？不应该是去找Class对象，然后按照方法区的数据结构生成类吗？</p>
<h2 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h2><p><a href="https://mp.weixin.qq.com/s/nzvg3e-RgM59zs9WSeUpLg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nzvg3e-RgM59zs9WSeUpLg</a></p>
<p>Shopee面经：<a href="https://www.cnblogs.com/Jun10ng/p/12616416.html" target="_blank" rel="noopener">https://www.cnblogs.com/Jun10ng/p/12616416.html</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Spring：<a href="https://blog.csdn.net/java_lyvee/article/details/102633067" target="_blank" rel="noopener">https://blog.csdn.net/java_lyvee/article/details/102633067</a>  （循环依赖）</p>
<p>​                <a href="https://www.cnblogs.com/CodeBear/p/10867707.html" target="_blank" rel="noopener">https://www.cnblogs.com/CodeBear/p/10867707.html</a>   （子路学生写的文章）</p>
<p>​            <a href="https://mp.weixin.qq.com/s/RFxoVMeW5Mx9kzzFGhpyKA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/RFxoVMeW5Mx9kzzFGhpyKA</a>  （循环依赖）</p>
<p>美团String的intern方法：<a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></p>
<blockquote>
<p>AnnotationConfigApplicationContext</p>
<p>refresh</p>
<p>finishBeanFactoryInitialization(beanFactory)</p>
<p>preInstantiateSingletons</p>
<p><code>getBean(beanName)</code></p>
<p><code>doGetBean</code></p>
<p>createBean</p>
<p>doCreateBean</p>
<p>addSingletonFactory</p>
<p>getSingleton</p>
</blockquote>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%A7%8B%E6%8B%9B/">秋招</a>
                    
                      <a class="hover-with-bg" href="/categories/%E7%A7%8B%E6%8B%9B/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%A7%8B%E6%8B%9B/">秋招</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "简历问题&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
