<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>MySQL - 郭寰宇</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>郭寰宇的个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-06-19 18:35">
      2020年6月19日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      141
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="MySQL面试问题"><a href="#MySQL面试问题" class="headerlink" title="MySQL面试问题"></a>MySQL面试问题</h1><ol>
<li>事务描述，ACID讲解。</li>
<li>事务隔离级别描述，脏读、不可重复读、幻读区别，MVCC机制讲解。</li>
<li>Innodb如何解决幻读，间隙锁实现详细描述。</li>
<li>left join和inner join的区别，嵌套子查询如何优化。</li>
<li>如果线上出现慢sql，如何定位和解决，有实际动手优化过慢sql吗。</li>
<li>binlog机制描述，binlog日志格式有哪些。</li>
<li>MySQL主从架构(读写分离)，主从数据复制过程，数据复制过程丢失如何处理。</li>
<li>分库分表如何实现，用过哪些分库分表插件，底层原理是怎样的。</li>
<li>索引有哪些种类，建立索引的原则，聚簇索引和非聚簇索引实现区别，联合索引如何使用。</li>
<li>mysql写入数据的时候，是先把数据写到缓冲区，然后再flush到磁盘的，如何在flush过程中发生了宕机，数据如何恢复。</li>
</ol>
<p>事务四大特性（ACID）原子性、一致性、隔离性、持久性？</p>
<p>事务的并发？事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？</p>
<p>MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？</p>
<p>MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景？</p>
<p>查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序</p>
<p>索引为什么要用B+树，B+树和B-树的区别是什么</p>
<p>mysql的默认事务级别，一共有哪些事务级别</p>
<p>mysql的一些语句，这些肯定需要掌握的</p>
<blockquote>
<p><a href="https://www.cnblogs.com/bchjazh/p/5997728.html" target="_blank" rel="noopener">https://www.cnblogs.com/bchjazh/p/5997728.html</a></p>
<pre><code class="hljs sql">&gt;选择：select *   from table1   where 范围
&gt;插入：insert into table1(field1,field2)   values  (value1,value2)
&gt;删除：delete from table1   where 范围
&gt;更新：update table1   set field1=value1   where 范围
&gt;查找：select *   from table1   where field1   like ’%value1%’   ---like的语法很精妙，查资料!
&gt;排序：select *   from table1   order by field1,field2 [  desc  ]
&gt;总数：select count as totalcount   from table1
&gt;求和：select sum  (field1)   as sumvalue   from table1
&gt;平均：select avg  (field1)   as avgvalue   from table1
&gt;最大：select max  (field1)   as maxvalue   from table1
&gt;最小：select min  (field1)   as minvalue   from table1</code></pre>


</blockquote>
<p>mysql锁，行锁，表锁 ，什么时候发生锁，怎么锁，原理</p>
<p>数据库优化，最左原则啊，水平分表，垂直分表</p>
<p>什么是临时表，临时表什么时候删除?</p>
<p>sql查询语句确定创建哪种类型的索引？如何优化查询？</p>
<p>聚集索引和非聚集索引区别？</p>
<blockquote>
<p>聚集索引（主键索引）：</p>
<p>​      聚集索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的记录数据。</p>
<p>​      聚集索引的叶子节点称为数据页，聚集索引的这个特性决定了索引组织表中的数据也是索引的一部分。</p>
<p>​    辅助索引（二级索引）：普通索引也叫二级索引，除聚簇索引外的索引，即非聚簇索引</p>
<p>​      非主键索引，叶子节点=键值+书签。Innodb存储引擎的书签就是相应行数据的主键索引值。</p>
<p>聚簇索引查询会比非聚集索引查询更快</p>
<p>因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询。</p>
<p>刚刚你提到主键索引查询只会查一次，而非主键索引需要回表查询多次。（后来我才知道，原来这个过程叫做回表）是所有情况都是这样的吗？非主键索引一定会查询多次吗？</p>
<p>覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。 如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = ‘keytest’;的时候，就可以通过覆盖索引查询，无需回表。</p>
<p><strong>如何实现覆盖索引</strong></p>
<p>将被查询的字段，建立到联合索引里去</p>
</blockquote>
<p>explain解析：</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200620164822.png" srcset="/img/loading.gif" alt="image-20200620164819166"></p>
<blockquote>
<p>id:选择标识符——- id相同时，执行顺序由上至下，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执，id值越大，优先级越高，越先执行<br>select_type:表示查询的类型———-表示查询中每个select子句的类型</p>
<p>​    (1) SIMPLE(简单SELECT，不使用UNION或子查询等)</p>
<p>​    (2) PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</p>
<p>​    (3) UNION(UNION中的第二个或后面的SELECT语句)</p>
<p>​    (4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p>
<p>​    (5) UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)</p>
<p>​    (6) SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)</p>
<p>​    (7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)</p>
<p>​    (8) DERIVED(派生表的SELECT, FROM子句的子查询)</p>
<p>​    (9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p>
<p>table:输出结果集的表——–显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的）<br>partitions:匹配的分区<br><strong>type:表示表的连接类型</strong>——–对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。常用的类型有： <strong>ALL、index、range、 ref、eq_ref、const、system、**</strong>NULL（从左到右，性能从差到好）**</p>
<p>​    ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</p>
<p>​    index: Full Index Scan，index与ALL区别为index类型只遍历索引树</p>
<p>​    range:只检索给定范围的行，使用一个索引来选择行</p>
<p>​    ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<p>​    eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</p>
<p>​    const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</p>
<p>​    NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成</p>
<p>possible_keys:表示查询时，可能使用的索引<br>key:表示实际使用的索引<br>key_len:索引字段的长度<br>ref:列与索引的比较——<strong>即哪些列或常量被用于查找索引列上的值</strong><br>rows:扫描出的行数(估算的行数)<br>filtered:按表条件过滤的行百分比<br>Extra:执行情况的描述和说明</p>
<p>​    Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p>
<p>​    Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by</p>
<p>​    Using filesort：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”</p>
<p>​    Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p>
<p>​    Impossible where：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。</p>
<p>​    Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p>
<p>​    No tables used：Query语句中使用from dual 或不含任何from子句</p>
</blockquote>
<p><strong>联合索引的最左前缀匹配</strong></p>
<blockquote>
<p>MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。</p>
</blockquote>
<p>MySQL的事务的隔离级别</p>
<blockquote>
<p>未提交读RU：一个事务可以读取到，另外一个事务尚未提交的变更。<br>已提交读RR：一个事务提交后，其变更才会被另一个事务读取到。<br>可重复读RC：在一个事务执行的过程中所读取到的数据，和事务启动时所看到的一致。 即事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。<br>串行化S：当操作一行数据时，读写分别都会加锁。当出现读写锁互斥时，会排队串行执行</p>
</blockquote>
<p><strong>MVCC</strong></p>
<blockquote>
<p>​    <strong>MVCC主要适用于Mysql的RC,RR隔离级别</strong></p>
<p>InnoDB在每行记录后面保存两个隐藏的列来，分别保存了当前行创建时的版本号和删除时的版本号。这里存储的并不是实际的时间值,而是系统版本号，当数据被修改时，版本号加1<br>　　在读取事务开始时，系统会给当前读事务一个版本号，事务会读取版本号&lt;=当前版本号的数据<br>　　此时如果其他写事务修改了这条数据，那么这条数据的版本号就会加1，从而比当前读事务的版本号高，读事务自然而然的就读不到更新后的数据了</p>
<p><a href="https://blog.csdn.net/w2064004678/article/details/83012387" target="_blank" rel="noopener">https://blog.csdn.net/w2064004678/article/details/83012387</a></p>
</blockquote>
<p>有哪些锁（乐观锁悲观锁），select 时怎么加排它锁？</p>
<p>非关系型数据库和关系型数据库区别，优势比较？</p>
<p>数据库三范式，根据某个场景设计数据表？</p>
<p>数据库的读写分离、主从复制，主从复制分析的 7 个问题？</p>
<p>使用explain优化sql和索引？</p>
<p>MySQL慢查询怎么解决？</p>
<p>什么是 内连接、外连接、交叉连接、笛卡尔积等？</p>
<p>mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决？</p>
<p>varchar和char的使用场景？</p>
<p>mysql 高并发环境解决方案？</p>
<p>数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）？</p>
<p><strong>Mysql中有哪几种锁？</strong></p>
<blockquote>
<p>1.表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
<p>2.行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<ol start="3">
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ol>
</blockquote>
<p><strong>简述在MySQL数据库中MyISAM和InnoDB的区别</strong></p>
<blockquote>
<p><strong>MyISAM：</strong></p>
<p>不支持事务，但是每次查询都是原子的；</p>
<p>支持表级锁，即每次操作是对整个表加锁；</p>
<p>存储表的总行数；</p>
<p>一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；</p>
<p>采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。</p>
<p><strong>InnoDb：</strong></p>
<p>支持ACID的事务，支持事务的四种隔离级别；</p>
<p>支持行级锁及外键约束：因此可以支持写并发；</p>
<p>不存储总行数；</p>
<p>一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；</p>
<p>主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。</p>
<p>如果没有特别的需求，使用默认的Innodb即可。</p>
<p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p>
<p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p>
</blockquote>
<p><strong>Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</strong></p>
<blockquote>
<p>SQL标准定义的四个隔离级别为：</p>
<ol>
<li>read uncommited ：读到未提交数据</li>
<li>read committed：读已经提交，大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”，但不能避免“幻读”和“不可重复读取”。该级别适用于大多数系统。</li>
<li>repeatable read：重复读：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但不能避免“幻读”，但是带来了更多的性能损失。</li>
<li>serializable ：最严格的级别，事务串行执行，资源消耗最大</li>
</ol>
<p>不可重复读和幻读比较：<br>两者有些相似，但是前者针对的是update或delete，后者针对的insert。</p>
</blockquote>
<p><strong>CHAR和VARCHAR的区别？</strong></p>
<blockquote>
<p>1.CHAR和VARCHAR类型在存储和检索方面有所不同<br>2.CHAR列长度固定为创建表时声明的长度，长度值范围是1到255<br>3.当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。</p>
</blockquote>
<p><strong>列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？</strong></p>
<blockquote>
<p>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</p>
</blockquote>
<p><strong>LIKE声明中的％和_是什么意思？</strong></p>
<blockquote>
<p>％对应于0个或更多字符，_只是LIKE语句中的一个字符。</p>
</blockquote>
<p><strong>什么情况下设置了索引但无法使用</strong></p>
<blockquote>
<p>1.以“%”开头的LIKE语句，模糊匹配</p>
<ol start="2">
<li><p>OR语句前后没有同时使用索引</p>
</li>
<li><p>数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）</p>
</li>
</ol>
</blockquote>
<p><strong>数据库中的事务是什么?</strong></p>
<blockquote>
<p>事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。</p>
</blockquote>
<p><strong>ACID</strong></p>
<blockquote>
<p>（1）原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。</p>
<p>（2）一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态</p>
<p>（3）隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，</p>
<p>（4） 持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。</p>
</blockquote>
<p><strong>SQL注入漏洞产生的原因？如何防止？</strong></p>
<blockquote>
<p>SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。</p>
<p>防止SQL注入的方式：<br>开启配置文件中的magic_quotes_gpc 和 magic_quotes_runtime设置</p>
<p>执行sql语句时使用addslashes进行sql语句转换</p>
<p>Sql语句书写尽量不要省略双引号和单引号</p>
<p>过滤掉sql语句中的一些关键词：update、insert、delete、select、 * </p>
<p>提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。</p>
</blockquote>
<p>索引</p>
<blockquote>
<p>索引的目的是什么？<br>快速访问数据表中的特定信息，提高检索速度<br>创建唯一性索引，保证数据库表中每一行数据的唯一性。<br>加速表和表之间的连接<br>使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间</p>
<p>索引对数据库系统的负面影响是什么？<br>负面影响：<br>创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。</p>
<p>为数据表建立索引的原则有哪些？<br>在最频繁使用的、用以缩小查询范围的字段上建立索引。</p>
<p>什么情况下不宜建立索引？<br>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。</p>
<p>交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。</p>
<p>内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。<br>外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。</p>
<p>左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL目前还不支持全外连接。</p>
</blockquote>
<p><strong>SQL语言包括哪几部分？每部分都有哪些操作关键字？</strong></p>
<blockquote>
<p>SQL语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）四个部分。</p>
<p>数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index等</p>
<p>数据操纵：Select ,insert,update,delete,</p>
<p>数据控制：grant,revoke</p>
<p>数据查询：select</p>
</blockquote>
<p><strong>什么是锁？</strong></p>
<blockquote>
<p>数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。</p>
<p>加锁是<strong>实现数据库并发控制</strong>的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。</p>
<p><strong>锁包括行级锁和表级锁</strong></p>
</blockquote>
<p><strong>如何通俗地理解三个范式？</strong></p>
<blockquote>
<p>第一范式：每个列都不可以再拆分。</p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
</blockquote>
<p><strong>主键、外键和索引的区别？</strong></p>
<blockquote>
<p>主键–唯一标识一条记录，不能有重复的，不允许为空</p>
<p>外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值</p>
<p>索引–该字段没有重复值，但可以有一个空值</p>
<p><strong>作用：</strong></p>
<p>主键–用来保证数据完整性</p>
<p>外键–用来和其他表建立联系用的</p>
<p>索引–是提高查询排序的速度</p>
</blockquote>
<p><strong>你可以用什么来确保表格里的字段只接受特定范围里的值?</strong></p>
<blockquote>
<p>Check限制，它在数据库表格里被定义，用来限制输入该列的值。</p>
</blockquote>
<p><strong>对SQL语句优化有哪些方法？（选择几条）</strong></p>
<blockquote>
<p>Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。</p>
<p>（2）用EXISTS替代IN、用NOT EXISTS替代NOT IN。</p>
<p>（3） 避免在索引列上使用计算</p>
<p>（4）避免在索引列上使用IS NULL和IS NOT NULL</p>
<p>（5）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 </p>
<p>（6）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p>
<p>（7）应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</p>
</blockquote>
<p><strong>为什么要使用数据库</strong></p>
<blockquote>
<ul>
<li>数据保存在内存</li>
</ul>
<p>优点：存取速度快</p>
<p>缺点：数据不能永久保存</p>
<ul>
<li>数据保存在文件</li>
</ul>
<p>优点：数据永久保存</p>
<p>缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便</p>
<ul>
<li>数据保存在数据库</li>
</ul>
<p>1）数据永久保存</p>
<p>2）使用SQL语句，查询方便效率高。</p>
<p>3）管理数据方便</p>
</blockquote>
<p><strong>创建索引的原则（重中之重）</strong></p>
<blockquote>
<p>1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
<p>2）较频繁作为查询条件的字段才去创建索引</p>
<p>3）更新频繁字段不适合创建索引</p>
<p>4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p>
<p>5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p>
<p>6）定义有外键的数据列一定要建立索引。</p>
<p>7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p>
<p>8）对于定义为text、image和bit的数据类型的列不要建立索引。</p>
</blockquote>
<p><strong>创建索引的三种方式，删除索引</strong></p>
<blockquote>
<p>第一种方式：在执行CREATE TABLE时创建索引</p>
<p>第二种方式：使用ALTER TABLE命令去增加索引</p>
<p>第三种方式：使用CREATE INDEX命令创建</p>
<p>删除索引</p>
<p>根据索引名删除普通索引、唯一索引、全文索引：alter table 表名 drop KEY 索引名</p>
<p>alter table 表名 drop primary key（因为主键只有一个）</p>
</blockquote>
<p><strong>创建索引时需要注意什么？</strong></p>
<blockquote>
<p>非空字段</p>
<p>取值离散大的字段</p>
<p>索引字段越小越好</p>
</blockquote>
<p> <strong>使用索引查询一定能提高查询的性能吗？为什么</strong></p>
<blockquote>
<p>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p>
<p>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</p>
<p>基于非唯一性索引的检索</p>
</blockquote>
<p><strong>百万级别或以上的数据如何删除</strong></p>
<blockquote>
<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
</blockquote>
<p><strong>前缀索引</strong></p>
<blockquote>
<p>index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引</p>
</blockquote>
<p><strong>什么是最左前缀原则？什么是最左匹配原则</strong></p>
<blockquote>
<p>在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边</p>
<p>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
</blockquote>
<p><strong>使用B树的好处</strong></p>
<blockquote>
<p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p>
</blockquote>
<p><strong>使用B+树的好处</strong></p>
<blockquote>
<p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p>
</blockquote>
<p><strong>Hash索引和B+树所有有什么区别或者说优劣呢?</strong></p>
<blockquote>
<p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p>
</blockquote>
<p>InnoDB<strong>聚集索引和普通索引</strong></p>
<blockquote>
<p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</p>
<p>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</p>
<p>innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p>
<p>innodb存储引擎表是索引组织表，表中数据按照主键顺序存放。其聚集索引就是按照每张表的主键顺序构造一颗B+树，其叶子结点中存放的就是整张表的行记录数据，这些叶子节点成为数据页。</p>
<p>在Innodb中，聚簇索引默认就是主键索引。如果没有主键，则按照下列规则来建聚簇索引:</p>
<ul>
<li>没有主键时，会用一个非空并且唯一的索引列做为主键，成为此表的聚簇索引;</li>
<li>如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。</li>
</ul>
<p>由于主键使用了聚簇索引，如果主键是自增id，那么对应的数据也会相邻地存放在磁盘上，写入性能较高。如果是uuid等字符串形式，频繁的插入会使innodb频繁地移动磁盘块，写入性能就比较低了。</p>
</blockquote>
<p><strong>innodb引擎索引why使用了B+树结构，那么为什么不是其他类型树结构，例如二叉树呢？</strong></p>
<blockquote>
<p>计算机在存储数据的时候，有最小存储单元，这就好比人民币流通最小单位是分一样。文件系统的最小单元是块，一个块的大小是4k（这个值根据系统不同并且可设置），InnoDB存储引擎也有自己的最小储存单元—页（Page），一个页的大小是16K（这个值也是可设置的）。</p>
<p>文件系统中一个文件大小只有1个字节，但不得不占磁盘上4KB的空间。同理，innodb的所有数据文件的大小始终都是16384（16k）的整数倍。</p>
<p>所以在MySQL中，存放索引的一个块节点占16k，mysql每次IO操作会利用系统的预读能力一次加载16K。这样，如果这一个节点只放1个索引值是非常浪费的，因为一次IO只能获取一个索引值，所以不能使用二叉树。</p>
<p>B+树是多路查找树，一个节点能放n个值，n = 16K / 每个索引值的大小。<br>例如索引字段大小1Kb，这时候每个节点能放的索引值理论上是16个，这种情况下，二叉树一次IO只能加载一个索引值，而B+树则能加载16个。</p>
<p>B+树的路数为n+1，n是每个节点存在的值数量，例如每个节点存放16个值，那么这棵树就是17路。</p>
<p>从这里也能看出，B+树节点可存储多个值，所以B+树索引并不能找到一个给定键值的具体行。B+树只能找到存放数据行的具体页，然后把页读入到内存中，再在内存中查找指定的数据。</p>
<p>附：B树和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。</p>
</blockquote>
<p><strong>辅助索引</strong></p>
<blockquote>
<p>也称为非聚集索引，其叶子节点不包含行记录的全部数据，叶子结点除了包含键值以外，每个叶子结点中的索引行还包含一个书签，该书签就是相应行的聚集索引键。</p>
<p>创建的索引，如联合索引、唯一索引等，都属于非聚簇索引</p>
<p>联合索引是指对表上的多个列进行索引。联合索引也是一颗B+树，不同的是联合索引的键值数量不是1，而是大于等于2。联合索引的另一个好处已经对第二个键值进行了排序处理，有时候可以避免多一次的排序操作。</p>
<pre><code class="hljs sql">&gt;create index idx_age_name on user(age, name)</code></pre>

<p>覆盖索引，即从辅助索引中就可以得到查询所需要的所有字段值，而不需要查询聚集索引中的记录。覆盖索引的好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。</p>
<p>联合索引中如果不是按照索引最左列开始查找，无法使用索引；</p>
<p>必须把字段定义为NOT NULL并且提供默认值</p>
<p>禁止在更新十分频繁、区分度不高的属性上建立索引——更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能</p>
<p>禁止使用OR条件，必须改为IN查询</p>
</blockquote>
<p><strong>非聚簇索引一定会回表查询吗？</strong></p>
<blockquote>
<p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p>
<p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询</p>
</blockquote>
<p> <strong>联合索引是什么？为什么需要注意联合索引中的顺序？</strong></p>
<blockquote>
<p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p>
<p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p>
</blockquote>
<p><strong>ACID</strong></p>
<blockquote>
<p>原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p>
<p>一致性：执行事务前后，数据保持一致，事务前后数据的完整性必须保持一致。如果做一个财务系统，账户A转钱到账户B，那么账户A中减少的钱与账户B中增加的钱必须相等。</p>
<p>隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p>
<p>持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p>
</blockquote>
<p><strong>脏读？幻读？不可重复读？</strong></p>
<blockquote>
<p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>
<p>不可重复读(Non-repeatable read)：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。</p>
<p>幻读(Phantom Read):幻读是指一个<strong>事务内多次根据同一条件查询出来的记录行数</strong>不一致。，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
<p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
</blockquote>
<p><strong>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</strong></p>
<blockquote>
<p>数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable</p>
<p>READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
<p>READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p>
<p>REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p>
<p>SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
<p>Mysql 默认采用的 REPEATABLE_READ隔离级别</p>
<p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p>
</blockquote>
<p><strong>隔离级别与锁的关系</strong></p>
<blockquote>
<p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p>
<p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p>
<p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p>
<p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p>
</blockquote>
<p><strong>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</strong></p>
<blockquote>
<p>在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p>
<p>MyISAM和InnoDB存储引擎使用的锁：</p>
<ul>
<li>MyISAM采用表级锁(table-level locking)。</li>
<li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li>
</ul>
<p>行级锁 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p>
<p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<p>表级锁 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p>
<p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>
<p>页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p>
<p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
</blockquote>
<p>为何行级锁比表级锁开销大?</p>
<blockquote>
<p>可能是因为要判断每一行是否加锁？？</p>
</blockquote>
<p>MVCC</p>
<blockquote>
<p>MVCC定义：多版并发控制系统。可认为是行级锁的一个变种，它能够避免更多情况下的加锁操作。</p>
<p>作用：避免一些加锁操作，提升并发性能。</p>
<p>实现：通过在每行记录的后面保存行的创建时间和过期时间或删除时间（它们是隐藏的），这两个时间实际都是系统的版本号。每开始一个新的事务，版本号都会自动增加。</p>
<p>具体原理<br>select：innoBD查询时会检查以下两个条件：一个是数据行的版本号早于当前事务的版本号；另一个是行的删除版本号，要么没有，要么大于当前事务的版本号。</p>
<p>insert/delete：innoDB将当前的系统版本号作为新插入(删除)的数据行的版本号。</p>
<p>update：先新插入一行数据，并将当前系统版本号作为行的版本号，同时将当前系统版本号作为原来行的删除版本号。更新主键时，聚集索引和普通索引都会产生两个版本；而更新非主键时，只要普通索引会产生两个版本。</p>
<p>注意：MVCC只在read committed和repeatable read两个隔离级别下工作。</p>
<p>MVCC通过保存数据的历史版本，根据比较版本号来处理数据的是否显示，从而达到读取数据的时候不需要加锁就可以保证事务隔离性的效果</p>
</blockquote>
<p><strong>从锁的类别上分MySQL都有哪些锁呢？</strong></p>
<blockquote>
<p>从锁的类别上来讲，有共享锁和排他锁。</p>
<p>共享锁: 又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p>
<p>排他锁: 又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p>
<p>锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p>
</blockquote>
<p><strong>什么是死锁？怎么解决？</strong></p>
<blockquote>
<p>锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p>
<p>常见的解决死锁的方法</p>
<p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p>
<p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p>
<p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p>
<p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p>
</blockquote>
<p><strong>数据库的乐观锁和悲观锁是什么？怎么实现的？</strong></p>
<blockquote>
<p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p>
<p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p>
</blockquote>
<p> <strong>SQL 约束有哪几种</strong></p>
<blockquote>
<p>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</p>
<p>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</p>
<p>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</p>
<p>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p>
<p>CHECK: 用于控制字段的值范围。</p>
</blockquote>
<p><strong>mysql中 in 和 exists 区别</strong></p>
<blockquote>
<p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询</p>
<p>如果查询的两个表大小相当，那么用in和exists差别不大。</p>
<p>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</p>
<p>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快</p>
</blockquote>
<p><strong>varchar与char的区别</strong></p>
<blockquote>
<p>char的特点</p>
<ul>
<li>char表示定长字符串，长度是固定的；</li>
<li>如果插入数据的长度小于char的固定长度时，则用空格填充；</li>
<li>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li>
<li>对于char来说，最多能存放的字符个数为255，和编码无关</li>
</ul>
<p>varchar的特点</p>
<ul>
<li>varchar表示可变长字符串，长度是可变的；</li>
<li>插入的数据是多长，就按照多长来存储；</li>
<li>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li>
<li>对于varchar来说，最多能存放的字符个数为65532</li>
</ul>
<p>总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</p>
<p><strong>varchar(50)中50的涵义</strong>：最多存放50个字符</p>
</blockquote>
<p> <strong>FLOAT和DOUBLE的区别是什么？</strong></p>
<blockquote>
<ul>
<li>FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</li>
<li>DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</li>
</ul>
</blockquote>
<p> <strong>drop、delete与truncate的区别</strong></p>
<blockquote>
<p>在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p>
</blockquote>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200620154955.jpg" srcset="/img/loading.gif" alt="img"></p>
<p> <strong>UNION与UNION ALL的区别？</strong></p>
<blockquote>
<ul>
<li>如果使用UNION ALL，不会合并重复的记录行</li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
</blockquote>
<p><strong>如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</strong></p>
<blockquote>
<p>使用explain命令来查看语句的执行计划</p>
<p>type(非常重要，可以看到有没有走索引) 访问类型</p>
</blockquote>
<p><strong>为什么要尽量设定一个主键？</strong></p>
<blockquote>
<p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p>
</blockquote>
<p><strong>主键使用自增ID还是UUID？</strong></p>
<blockquote>
<p>推荐使用自增ID，不要使用UUID。</p>
<p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p>
<p>总之，在数据量大一些的情况下，用自增主键性能会好一些。</p>
<p>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</p>
</blockquote>
<p><strong>字段为什么要求定义为not null？</strong></p>
<blockquote>
<p>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p>
</blockquote>
<p><strong>SQL语句优化的一些方法？</strong></p>
<blockquote>
<ul>
<li>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</li>
<li>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>5.in 和 not in 也要慎用，否则会导致全表扫描，</li>
</ul>
</blockquote>
<p><strong>数据库优化</strong></p>
<blockquote>
<h3 id="1-为什么要优化"><a href="#1-为什么要优化" class="headerlink" title="1. 为什么要优化"></a><strong>1. 为什么要优化</strong></h3><ul>
<li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li>
<li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li>
<li>数据是存放在磁盘上的，读写速度无法和内存相比</li>
</ul>
<p>优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p>
</blockquote>
<p><strong>分库分表</strong></p>
<blockquote>
<p>主要有垂直分表和水平分表</p>
<p>垂直分区：<br>根据数据库里面数据表的相关性进行拆分。例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。<br>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。如下图所示，这样来说大家应该就更容易理解了。</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200620155905.jpg" srcset="/img/loading.gif" alt="img"></p>
<p>垂直拆分的优点：可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p>
<p>垂直拆分的缺点：主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p>
<p><strong>水平分表：</strong></p>
<p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p>
</blockquote>
<p><strong>一些常见的主键生成策略</strong></p>
<blockquote>
<p>UUID 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。</p>
</blockquote>
<p><strong>MySQL的复制原理以及流程</strong></p>
<blockquote>
<p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p>
</blockquote>
<p><strong>主从复制的作用</strong></p>
<blockquote>
<ol>
<li>主数据库出现问题，可以切换到从数据库。</li>
<li>可以进行数据库层面的读写分离。</li>
<li>可以在从数据库上进行日常备份。</li>
</ol>
</blockquote>
<p>MySQL<strong>主从复制解决的问题</strong></p>
<blockquote>
<ul>
<li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li>
<li>负载均衡：降低单个服务器的压力</li>
<li>高可用和故障切换：帮助应用程序避免单点失败</li>
<li>升级测试：可以用更高版本的MySQL作为从库</li>
</ul>
</blockquote>
<p><strong>读写分离有哪些解决方案？</strong></p>
<blockquote>
<p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读</p>
</blockquote>
<p> <strong>数据表损坏的修复方式有哪些？</strong></p>
<blockquote>
<p>使用 myisamchk 来修复，具体步骤：</p>
<ul>
<li>1）修复前将mysql服务停止。</li>
<li>2）打开命令行方式，然后进入到mysql的/bin目录。</li>
<li>3）执行myisamchk –recover 数据库所在路径/*.MYI</li>
<li></li>
</ul>
</blockquote>
<p>问题+答案来源：</p>
<p>知乎：<a href="https://zhuanlan.zhihu.com/p/59838091" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59838091</a></p>
<p>​        <a href="https://zhuanlan.zhihu.com/p/114993399" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/114993399</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/107125866" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/107125866</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%A4%8D%E4%B9%A0%E5%A4%A7%E7%BA%B2/">复习大纲</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%A4%8D%E4%B9%A0/">复习</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/06/19/Redis/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Redis</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/06/19/ssm/">
                        <span class="hidden-mobile">ssm</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "MySQL&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
