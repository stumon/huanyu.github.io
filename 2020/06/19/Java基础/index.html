<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>Java基础 - 郭寰宇</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>郭寰宇的个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-06-19 18:37">
      2020年6月19日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      14.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      157
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="Java面试问题"><a href="#Java面试问题" class="headerlink" title="Java面试问题"></a>Java面试问题</h1><h2 id="为什么String定义为final"><a href="#为什么String定义为final" class="headerlink" title="为什么String定义为final"></a>为什么String定义为final</h2><blockquote>
<p>为了安全性和效率</p>
<p>用final就是<strong>拒绝继承</strong>,防止其内部的方法被重写，乱改。为了线程安全(字符串自己便是线程安全的)。比如我们使用string作为hash的键，如果string是可变的，那么键也是可变的。</p>
<p><strong>字符串常量池</strong>,  在大量使用字符串的情况下，可以节省内存空间，提高效率。但之所以能实现这个特性，String的不可变性是最基本的一个必要条件</p>
<p>final修饰的对象只是引用地址不可变，内容还是能变的</p>
<p>执行效率可以这么解释，面向对象有一个多态的性质，如果可以改变，就可以被复写，子类如果复写了某个方法，虚函数表就被用上了；如果是final型的，jvm就直接去用了，根本不用去虚函数表里面找</p>
<p>​      ———-只要声明成final ，JVM才不用对相关方法在虚函数表中查询，而直接定位到string类的相关方法上，提高了执行效率。基础类以保证执行效率为第一要素。</p>
</blockquote>
<h2 id="描述下java集合，项目中用到哪些。"><a href="#描述下java集合，项目中用到哪些。" class="headerlink" title="描述下java集合，项目中用到哪些。"></a>描述下java集合，项目中用到哪些。</h2><blockquote>
<ul>
<li><p>Collection</p>
</li>
<li><ul>
<li><p>List</p>
</li>
<li><p><strong>ArrayList</strong></p>
</li>
<li><p>LinkedList</p>
</li>
<li><p>Vector(了解，已过时)</p>
</li>
</ul>
</li>
<li><p>Set</p>
<ul>
<li><p><strong>HashSet</strong></p>
<ul>
<li>LinkedHashSet</li>
</ul>
</li>
<li><p>TreeSet</p>
</li>
</ul>
</li>
<li><p>Map</p>
<ul>
<li><p><strong>HashMap</strong></p>
</li>
<li><p>LinkedHashMap</p>
</li>
</ul>
</li>
<li><p>TreeMap</p>
</li>
<li><p>ConcurrentHashMap</p>
</li>
<li><p>Hashtable(了解，，已过时)</p>
</li>
</ul>
</blockquote>
<h2 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h2><blockquote>
<p>这两个类都实现了List接口，它们都是<strong>有序</strong>的集合(存储有序)，<strong>底层是数组</strong>。我们可以按位置索引号取出某个元素，<strong>允许元素重复和为null</strong>。</p>
<ul>
<li>ArrayList是非同步的</li>
<li>Vector是同步的</li>
<li>Vector增长原来的一倍，ArrayList增长原来的0.5倍</li>
</ul>
</blockquote>
<h3 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h3><blockquote>
<ul>
<li><p><strong>同步性：</strong></p>
</li>
<li><p>HashMap是非同步的</p>
</li>
<li><p>Hashtable是同步的</p>
</li>
<li><p>需要同步的时候，我们往往不使用，而使用ConcurrentHashMap</p>
</li>
</ul>
<ul>
<li><p><strong>是否允许为null：</strong></p>
</li>
<li><p>HashMap允许为null</p>
</li>
<li><p>Hashtable不允许为null</p>
</li>
</ul>
<p>HashMap把Hashtable的contains方法去掉了，改成了containsValue和containsKey</p>
</blockquote>
<h2 id="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢"><a href="#Set里的元素是不能重复的，那么用什么方法来区分重复与否呢" class="headerlink" title="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢"></a>Set里的元素是不能重复的，那么用什么方法来区分重复与否呢</h2><blockquote>
<p>Set集合如果添加的元素相同时，<strong>是根本没有插入的(仅修改了一个无用的value值)</strong></p>
</blockquote>
<h2 id="Collection和Collections的区别"><a href="#Collection和Collections的区别" class="headerlink" title="Collection和Collections的区别"></a>Collection和Collections的区别</h2><blockquote>
<ol>
<li>Collection是集合的上级<strong>接口</strong>，继承它的有Set和List接口</li>
<li>Collections是集合的<strong>工具类</strong>，提供了一系列的静态方法对集合的搜索、查找、同步等操作</li>
</ol>
</blockquote>
<h2 id="ArrayList-LinkedList的存储性能和特性"><a href="#ArrayList-LinkedList的存储性能和特性" class="headerlink" title="ArrayList,LinkedList的存储性能和特性"></a>ArrayList,LinkedList的存储性能和特性</h2><blockquote>
<p>rrayList的底层是数组，LinkedList的底层是双向链表。</p>
<ul>
<li>ArrayList它支持以角标位置进行索引出对应的元素(随机访问)，而LinkedList则需要遍历整个链表来获取对应的元素。因此<strong>一般来说ArrayList的访问速度是要比LinkedList要快的</strong></li>
<li>ArrayList由于是数组，对于删除和修改而言消耗是比较大(复制和移动数组实现)，LinkedList是双向链表删除和修改只需要修改对应的指针即可，消耗是很小的。因此<strong>一般来说LinkedList的增删速度是要比ArrayList要快的</strong></li>
</ul>
</blockquote>
<h2 id="Java中HashMap的key值要是为类对象则该类需要满足什么条件？"><a href="#Java中HashMap的key值要是为类对象则该类需要满足什么条件？" class="headerlink" title="Java中HashMap的key值要是为类对象则该类需要满足什么条件？"></a>Java中HashMap的key值要是为类对象则该类需要满足什么条件？</h2><blockquote>
<p><strong>需要同时重写该类的hashCode()方法和它的equals()方法</strong>。</p>
<ul>
<li>在插入元素的时候是<strong>先算出该对象的hashCode</strong>。如果hashcode相等话的。那么表明该对象是存储在同一个位置上的。</li>
<li>如果调用equals()方法，<strong>两个key相同</strong>，则<strong>替换元素</strong></li>
<li>如果调用equals()方法，<strong>两个key不相同</strong>，则说明该<strong>hashCode仅仅是碰巧相同</strong>，此时是散列冲突，将新增的元素放在桶子上</li>
</ul>
<p>一般来说，我们会认为：<strong>只要两个对象的成员变量的值是相等的，那么我们就认为这两个对象是相等的</strong>！因为，Object底层比较的是两个对象的地址，而对我们开发来说这样的意义并不大~这也就为什么我们要重写<code>equals()</code>方法</p>
<p>重写了equals()方法，就要重写hashCode()的方法。因为<strong>equals()认定了这两个对象相同</strong>，而<strong>同一个对象调用hashCode()方法时</strong>，是应该返回相同的值的！</p>
</blockquote>
<h2 id="StringBuilder和StringBuffer的区别。"><a href="#StringBuilder和StringBuffer的区别。" class="headerlink" title="StringBuilder和StringBuffer的区别。"></a>StringBuilder和StringBuffer的区别。</h2><blockquote>
<p>StringBuilder是线程不安全，StringBuffer是线程安全。这是因为源代码中StringBuffer的很多方法都被关键字<strong>synchronized</strong> 修饰了，而StringBuilder没有。</p>
<p>StringBuffer、StringBuilder和String一样，也用来代表字符串。String类是不可变类，任何对String的改变都 会引发新的String对象的生成；StringBuffer则是可变类，任何对它所指代的字符串的改变都不会产生新的对象。</p>
<p>三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String</p>
</blockquote>
<h2 id="HashMap中常用的方法有哪些，什么时候会触发树化，jdk1-7和1-8实现的差异，1-7的实现为什么会出现死锁，画图说明下。HashMap和TreeMap的区别。"><a href="#HashMap中常用的方法有哪些，什么时候会触发树化，jdk1-7和1-8实现的差异，1-7的实现为什么会出现死锁，画图说明下。HashMap和TreeMap的区别。" class="headerlink" title="HashMap中常用的方法有哪些，什么时候会触发树化，jdk1.7和1.8实现的差异，1.7的实现为什么会出现死锁，画图说明下。HashMap和TreeMap的区别。"></a>HashMap中常用的方法有哪些，什么时候会触发树化，jdk1.7和1.8实现的差异，1.7的实现为什么会出现死锁，画图说明下。HashMap和TreeMap的区别。</h2><blockquote>
<p>HashMap通过hashcode对其内容进行快速查找，而 TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap.</p>
<p>存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，会按照排序后的顺序迭代元素，两个相比较的key不得抛出classCastException。主要用于存入元素的时候对元素进行自动排序，迭代输出的时候就按排序顺序输出</p>
<p><strong>为什么HashMap需要加载因子？</strong></p>
<p>必须在“冲突的机会”与“空间利用率”之间，寻找一种平衡与折衷。</p>
<p>那么为什么选择了0.75作为HashMap的加载因子呢？这个跟一个统计学里很重要的原理——泊松分布有关。</p>
<p>在理想情况下，使用随机哈希码，在扩容阈值（加载因子）为0.75的情况下，节点出现在频率在Hash桶（表）中遵循参数平均为0.5的泊松分布。忽略方差，即X = λt，P(λt = k)，其中λt = 0.5的情况</p>
</blockquote>
<h2 id="说下枚举类型，底层实现原理，项目中是如何使用的。"><a href="#说下枚举类型，底层实现原理，项目中是如何使用的。" class="headerlink" title="说下枚举类型，底层实现原理，项目中是如何使用的。"></a>说下枚举类型，底层实现原理，项目中是如何使用的。</h2><blockquote>
<p>枚举是可以防止反序列化的，以及反射</p>
<p>枚举是一种特殊类。一个枚举在经过编译器编译过后，变成了一个抽象类，它继承了java.lang.Enum；而枚举中定义的枚举常量，变成了相应的public static final属性，而且其类型就是抽象类的类型，名字就是枚举常量的名字</p>
</blockquote>
<h2 id="详细描述Error和Exception-运行期和编译期-的区别。"><a href="#详细描述Error和Exception-运行期和编译期-的区别。" class="headerlink" title="详细描述Error和Exception(运行期和编译期)的区别。"></a>详细描述Error和Exception(运行期和编译期)的区别。</h2><blockquote>
<p>Error是一般不可处理的，由jvm抛出的严重性的问题。<br>Exception可以处理的。常见的Exception有</p>
<p>IOException:</p>
<p>RuntimeException:</p>
<pre><code class="hljs angelscript"> ClassNotFoundException找不到对应类因此
 NullPointerException空指针异常类
 llegalArgumentException参数异常
 ClassCastException类型强制转换异常
ArithmeticException算术异常类---<span class="hljs-built_in">int</span> a=<span class="hljs-number">5</span>/<span class="hljs-number">0</span>;
&gt;ArrayIndexOutOfBoundsException数组下标越界异常</code></pre>
</blockquote>
<h2 id="创建线程的方式，线程的生命周期。"><a href="#创建线程的方式，线程的生命周期。" class="headerlink" title="创建线程的方式，线程的生命周期。"></a>创建线程的方式，线程的生命周期。</h2><blockquote>
<p>新建状态（New）: 当线程对象创建后，即进入新建状态，如：Thread t = new MyThread();</p>
<p>就绪状态（Runnable）: 当调用线程对象的start()方法时，线程即进入就绪状态。处于就绪状态的线程只是说明此线程已经做好准备，随时等待CPU调度执行，并不是说执行了start()方法就立即执行。</p>
<p>运行状态（Running）: 当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。</p>
<p>阻塞状态（Blocked）: 处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。</p>
<p>死亡状态: 线程执行完毕或者是异常退出，该线程结束生命周期。</p>
</blockquote>
<p>ThrealLocal实现原理，为什么会出现内存泄漏。</p>
<p>volatile关键字原理，项目中是如何使用的。</p>
<p>synchronized和lock的区别，底层实现原理。AQS队列实现原理，用了哪些设计模式。公平锁和非公平锁、独占锁和共享锁、读写锁分别是如何实现的，为什么说非公平锁比公平锁性能高。</p>
<h2 id="序列化和反序列化。"><a href="#序列化和反序列化。" class="headerlink" title="序列化和反序列化。"></a>序列化和反序列化。</h2><blockquote>
<p>Java序列化就是指就是将内存中的对象转换为字节序列，方便持久化到磁盘或者网络传输。</p>
<p>步骤：第一: 将对象转换为字节数组  第二: 将字节数组存储到磁盘</p>
<p>Java反序列化就是将字节序列转换为内存中的对象</p>
<p>序列化最重要的作用：在传递和保存对象时.保证对象的完整性和可传递性。对象转换为有序字节流,以便在网络上传输或者保存在本地文件中。</p>
<p>反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。</p>
</blockquote>
<h2 id="深拷贝和浅拷贝区别。"><a href="#深拷贝和浅拷贝区别。" class="headerlink" title="深拷贝和浅拷贝区别。"></a>深拷贝和浅拷贝区别。</h2><blockquote>
<p>深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用</p>
<p>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝</p>
<p>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝</p>
</blockquote>
<h2 id="java内部类的区别-成员内部类、静态嵌套类、方法内部类、匿名内部类-。"><a href="#java内部类的区别-成员内部类、静态嵌套类、方法内部类、匿名内部类-。" class="headerlink" title="java内部类的区别(成员内部类、静态嵌套类、方法内部类、匿名内部类 )。"></a>java内部类的区别(成员<em>内部类<em>、静态嵌套类、方法</em>内部类<em>、匿名</em>内部类</em> )。</h2><blockquote>
<p>成员内部类与实例变量、实例方法一样，属于外部类对象</p>
<p>静态内部类是使用<code>static</code>修饰的成员内部类，属于外部类—-非静态内部类中不能含有静态内部类</p>
<p>局部内部类是在方法体中定义的内部类</p>
<p>匿名内部类是没有类名的内部类，匿名内部类的定义与对象创建时一起的，一般时给接口的引用或抽象类的引用赋值匿名内部类对象</p>
<pre><code class="hljs haxe">&gt;<span class="hljs-keyword">new</span> <span class="hljs-type"></span>实现接口（）
&gt;&#123;
   <span class="hljs-comment">//匿名内部类类体部分</span>
&gt;&#125;
&gt;<span class="hljs-keyword">new</span> <span class="hljs-type"></span>父类构造器（实参列表）
&gt;&#123;
 <span class="hljs-comment">//匿名内部类类体部分</span>
&gt;&#125;</code></pre>



<p>管什么类编译后都会生成独立的字节码文件</p>
</blockquote>
<h2 id="java线程池参数描述，线程池工作原理，线程池如何调优。"><a href="#java线程池参数描述，线程池工作原理，线程池如何调优。" class="headerlink" title="java线程池参数描述，线程池工作原理，线程池如何调优。"></a>java线程池参数描述，线程池工作原理，线程池如何调优。</h2><blockquote>
<p>使用线程池大致有3个好处</p>
<p><strong>第一：降低资源消耗。</strong>通过重复利用已创建的线程降低线程创建和销毁造成的消耗，减少了每次创建线程、销毁线程的开销。<br><strong>第二：提高响应速度。</strong>当任务到达时，任务可以不需要等到线程创建就能立即执行。<br><strong>第三：提高线程的可管理性。</strong>线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源</p>
<p><strong>线程池创建</strong></p>
<p>ThreadPoolExecutor是线程池的真正实现,通过构造方法的一系列参数,来构成不同配置的线程池</p>
<p>七大参数+四大拒绝策略：</p>
<pre><code class="hljs axapta">&gt;<span class="hljs-keyword">public</span> ThreadPoolExecutor(<span class="hljs-keyword">int</span> corePoolSize, <span class="hljs-meta">#核心线程数</span>
               <span class="hljs-keyword">int</span> maximumPoolSize, <span class="hljs-meta">#最大线程数</span>
               <span class="hljs-keyword">long</span> keepAliveTime,, <span class="hljs-meta">#该线程池中非核心线程闲置超时时长</span>
               TimeUnit unit,<span class="hljs-meta">#keepAliveTime单位</span>
               BlockingQueue&lt;Runnable&gt; workQueue, <span class="hljs-meta">#阻塞队列</span>
               ThreadFactory threadFactory,<span class="hljs-meta">#创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</span>
               RejectedExecutionHandler handler) <span class="hljs-meta">#饱和策略</span>
&gt;corePoolSize：线程池新建线程的时候，如果当前线程总数小于corePoolSize，则新建的是核心线程，如果超过corePoolSize，则新建的是非核心线程核心线程默认情况下会一直存活在线程池中，即使这个核心线程啥也不干(闲置状态)。                     
&gt;<span class="hljs-keyword">int</span> maximumPoolSize： 该线程池中线程总数最大值，线程总数 = 核心线程数 + 非核心线程数。  
&gt;keepAliveTime：一个非核心线程，如果不干活(闲置状态)的时长超过这个参数所设定的时长，就会被销毁掉，如果设置allowCoreThreadTimeOut = <span class="hljs-keyword">true</span>，则会作用于核心线程。
&gt;BlockingQueue workQueue：该线程池中的任务队列：维护着等待执行的Runnable对象，当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务。
&gt;常用的workQueue类型：
SynchronousQueue：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;线程数达到了maximumPoolSize而不能新建线程&gt;的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大
LinkedBlockingQueue：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize
ArrayBlockingQueue：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误
DelayQueue：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务

&gt;RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常
&gt;AbortPolicy：不处理，直接抛出异常。
&gt;CallerRunsPolicy：若线程池还没关闭，调用当前所在线程来运行任务，r.run()执行。
&gt;DiscardOldestPolicy：LRU策略，丢弃队列里最近最久不使用的一个任务，并执行当前任务。
&gt;DiscardPolicy：不处理，丢弃掉，不抛出异常。</code></pre>
<p><strong>向线程池提交任务</strong></p>
<p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法</p>
<p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功</p>
<p>submit()方法用于提交需要返回值的任务。</p>
<p>线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get(long timeout，TimeUnit unit)，在指定的时间内会等待任务执行，超时则抛出超时异常，等待时候会阻塞当前线程<br><strong>关闭线程池</strong></p>
<p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，它们的原理是遍历线<br>程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程</p>
<p>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</p>
<p>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</p>
<p><strong>线程池状态</strong></p>
<p>1、RUNNING</p>
<p>(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。<br>(2) 状态切换：线程池的初始化状态是RUNNING。线程池被一旦被创建，就处于RUNNING状态，且线程池中的任务数为0</p>
<p>2、 SHUTDOWN</p>
<p>(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。<br>(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p>
<p>3、STOP</p>
<p>(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。<br>(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p>
<p>4、TIDYING</p>
<p>(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。<br>(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</p>
<p>5、 TERMINATED</p>
<p>(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。<br>(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p>
</blockquote>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200619212551.png" srcset="/img/loading.gif" alt="image-20200619212548437"></p>
<p>主线程到达一个条件，需要多个子线程去执行任务，等子任务都执行完后再往下走，如何编写代码(CountDownLatch)。</p>
<h2 id="写个程序，两个线程交叉打印1到100的数字，需要多种实现方式。"><a href="#写个程序，两个线程交叉打印1到100的数字，需要多种实现方式。" class="headerlink" title="写个程序，两个线程交叉打印1到100的数字，需要多种实现方式。"></a>写个程序，两个线程交叉打印1到100的数字，需要多种实现方式。</h2><pre><code class="hljs java">
<span class="hljs-comment">//https://blog.csdn.net/u013760665/article/details/88805644</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPrint</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">private</span> Thread t1,t2;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runThread</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        t1=<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread1());
        t2=<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread2());
        t1.start();
        t2.start();

    &#125;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>
<span class="hljs-class">    </span>&#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">100</span>)
            &#123;
                <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)
                &#123;
                    System.out.println(i);
                    i++;
                    flag=<span class="hljs-number">2</span>;
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>
<span class="hljs-class">    </span>&#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">100</span>)
            &#123;
                <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">2</span>)
                &#123;
                    System.out.println(i);
                    i++;
                    flag=<span class="hljs-number">1</span>;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>



<h2 id="Hashmap-源码级掌握，扩容，红黑树，最小树化容量，hash冲突解决，有些面试官会提出发自灵魂的审问，比如为什么是红黑树，别的树不可以吗；为什么8的时候树化，4不可以吗，等等"><a href="#Hashmap-源码级掌握，扩容，红黑树，最小树化容量，hash冲突解决，有些面试官会提出发自灵魂的审问，比如为什么是红黑树，别的树不可以吗；为什么8的时候树化，4不可以吗，等等" class="headerlink" title="Hashmap 源码级掌握，扩容，红黑树，最小树化容量，hash冲突解决，有些面试官会提出发自灵魂的审问，比如为什么是红黑树，别的树不可以吗；为什么8的时候树化，4不可以吗，等等"></a>Hashmap 源码级掌握，扩容，红黑树，最小树化容量，hash冲突解决，有些面试官会提出发自灵魂的审问，比如为什么是红黑树，别的树不可以吗；为什么8的时候树化，4不可以吗，等等</h2><blockquote>
<p>为啥使用红黑树：</p>
<p>AVL树和红黑树有几点比较和区别：<br>（1）AVL树是更加严格的平衡，因此可以提供更快的查找速度，一般读取查找密集型任务，适用AVL树。<br>（2）红黑树更适合于插入修改密集型任务。<br>（3）通常，AVL树的旋转比红黑树的旋转更加难以平衡和调试。</p>
</blockquote>
<h2 id="concureentHashMap，段锁，如何分段，和hashmap在hash上的区别，性能，等等"><a href="#concureentHashMap，段锁，如何分段，和hashmap在hash上的区别，性能，等等" class="headerlink" title="concureentHashMap，段锁，如何分段，和hashmap在hash上的区别，性能，等等"></a>concureentHashMap，段锁，如何分段，和hashmap在hash上的区别，性能，等等</h2><blockquote>
<p>JDK7：ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。默认情况下，initialCapacity等于16，loadFactor等于0.75，concurrencyLevel等于16.</p>
<p>JDK8：在JDK1.7之前，ConcurrentHashMap是通过分段锁机制来实现的，所以其最大并发度受Segment的个数限制。因此，在JDK1.8中，ConcurrentHashMap的实现原理摒弃了这种设计，而是选择了与HashMap类似的数组+链表+红黑树的方式实现，而加锁则采用CAS和synchronized实现。<br><a href="https://blog.csdn.net/bill_xiang_/article/details/81122044" target="_blank" rel="noopener">https://blog.csdn.net/bill_xiang_/article/details/81122044</a></p>
</blockquote>
<h2 id="HashTable-，同步锁，这块可能会问你synchronized关键字-1-6之后提升了什么，怎么提升的这些"><a href="#HashTable-，同步锁，这块可能会问你synchronized关键字-1-6之后提升了什么，怎么提升的这些" class="headerlink" title="HashTable ，同步锁，这块可能会问你synchronized关键字 1.6之后提升了什么，怎么提升的这些"></a>HashTable ，同步锁，这块可能会问你synchronized关键字 1.6之后提升了什么，怎么提升的这些</h2><blockquote>
<p>在Hashtable中的绝大部分方法都是使用synchronized进行修饰的。比如Hashtable 提供的几个主要方法，包括 get(), put(), remove() 等。不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性，但是也大大的降低了执行效率。</p>
</blockquote>
<blockquote>
<p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong></p>
</blockquote>
<blockquote>
<p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p>
<p>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<p><strong>偏向锁</strong>的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p>
<p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为<strong>轻量级锁</strong>的优化手段(1.6之后加入的)。轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作…..轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</p>
<p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为<strong>自旋锁</strong>的优化手段。</p>
<p>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</p>
<p>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。<strong>在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了</strong>。</p>
<p><strong>锁消除</strong></p>
<p>锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。</p>
<p><strong>锁粗化:</strong>就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁</p>
<p><strong>适应性自旋</strong> 当前锁处于膨胀，会进行自旋。自旋是需要消耗CPU的，如果一直获取不到锁的话，那线程一直处在自旋状态，消耗CPU资源。为了解决这个问题JDK采用—<strong>适应性自旋</strong>，线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。另外自旋虽然会占用CPU资源，但不会一直占用CPU资源，每隔一段时间会通过<strong>os::NakedYield方法</strong>放弃CPU资源，或通过<strong>park方法</strong>挂起；如果其他线程完成锁的膨胀操作，则退出自旋并返回</p>
</blockquote>
<h2 id="Synchronized-和-ReenTrantLock-的对比"><a href="#Synchronized-和-ReenTrantLock-的对比" class="headerlink" title="Synchronized 和 ReenTrantLock 的对比"></a>Synchronized 和 ReenTrantLock 的对比</h2><blockquote>
<p><strong>两者都是可重入锁</strong></p>
<p>​    “可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<p><strong>synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API</strong></p>
<p>​    synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<p><strong>ReenTrantLock 比 synchronized 增加了一些高级功能</strong></p>
<p>​    主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p>
<p>​    <strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<p>​    ReenTrantLock可以<strong>指定是公平锁还是非公平锁</strong>。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。</p>
<p>​    synchronized关键字与wait()和notify/notifyAll()方法相结合可以<strong>实现等待/通知机制</strong>，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</p>
</blockquote>
<h2 id="ArrayList-优势，扩容，什么时候用"><a href="#ArrayList-优势，扩容，什么时候用" class="headerlink" title="ArrayList 优势，扩容，什么时候用"></a>ArrayList 优势，扩容，什么时候用</h2><blockquote>
<p>ArrayList的底层是一个动态数组，ArrayList首先会对传进来的初始化参数initalCapacity进行判断，如果参数等于0，则将数组初始化为一个空数组，如果不等于0，将数组初始化为一个容量为10的数组。初始容量也可以自定义指定。随着不断添加元素，数组大小增加，当数组的大小大于初始容量的时候(比如初始为10，当添加第11个元素的时候)，就会进行扩容，新的容量为旧的容量的1.5倍。<br>扩容的时候，会以新的容量建一个原数组的拷贝，修改原数组，指向这个新数组，原数组被抛弃，会被GC回收。</p>
</blockquote>
<h2 id="LinkedList-优势，什么时候用，和arraylist的区别-等等"><a href="#LinkedList-优势，什么时候用，和arraylist的区别-等等" class="headerlink" title="LinkedList 优势，什么时候用，和arraylist的区别 等等"></a>LinkedList 优势，什么时候用，和arraylist的区别 等等</h2><blockquote>
<p>​    ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</p>
<p>  对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</p>
<p>  对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</p>
</blockquote>
<h2 id="基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理"><a href="#基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理" class="headerlink" title="基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理"></a>基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理</h2><blockquote>
<p>自动装箱就是Java自动将原始类型值转换成对应的包装类型，如将int的变量转换成Integer对象，这个过程叫做装箱。反之将Integer引用类型转换成int类型值，这个过程叫做拆箱。因为装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。</p>
<p>自动装箱时编译器调用valueOf将基本类型值转换成引用类型。</p>
<p>自动拆箱时，编译器通过调用类似intValue()，doubleValue()这类的方法将对象转换成原始类型值。</p>
</blockquote>
<h2 id="String-，StringBuffer，StringBuilder哪个是安全的"><a href="#String-，StringBuffer，StringBuilder哪个是安全的" class="headerlink" title="String ，StringBuffer，StringBuilder哪个是安全的"></a>String ，StringBuffer，StringBuilder哪个是安全的</h2><blockquote>
<p><strong>String 字符串常量<br>StringBuffer 字符串变量（线程安全）<br>StringBuilder 字符串变量（非线程安全）</strong></p>
<p>String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</p>
</blockquote>
<h2 id="什么是泛型，怎么用泛型"><a href="#什么是泛型，怎么用泛型" class="headerlink" title="什么是泛型，怎么用泛型"></a>什么是泛型，怎么用泛型</h2><blockquote>
<p>“泛型” 意味着编写的代码可以被不同类型的对象所重用。泛型的提出是为了编写重用性更好的代码。泛型的本质是<strong>参数化类型</strong>，也就是说所操作的<strong>数据类型</strong>被指定为一个<strong>参数</strong>。实现一个通用的、可以处理不同类型的方法</p>
</blockquote>
<h2 id="static能不能修饰threadLocal，为什么，这道题我当时一听到其实挺懵逼的"><a href="#static能不能修饰threadLocal，为什么，这道题我当时一听到其实挺懵逼的" class="headerlink" title="static能不能修饰threadLocal，为什么，这道题我当时一听到其实挺懵逼的"></a>static能不能修饰threadLocal，为什么，这道题我当时一听到其实挺懵逼的</h2><blockquote>
<p>ThreadLocal并不是一个Thread，而是Thread的局部变量。ThreadLocal的作用是提供线程范围内的局部变量，这种变量在<strong>线程的生命周期内起作用</strong>。作用：提供一个线程内公共变量，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度，或者为线程提供一个私有的变量副本，这样每一个线程都可以<strong>随意修改自己的变量副本，而不会对其他线程产生影响</strong>，真正诠释了“Local”的含义。</p>
</blockquote>
<h2 id="Comparable和Comparator接口是干什么的，其区别"><a href="#Comparable和Comparator接口是干什么的，其区别" class="headerlink" title="Comparable和Comparator接口是干什么的，其区别"></a>Comparable和Comparator接口是干什么的，其区别</h2><blockquote>
<p>Comparable &amp; Comparator 都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序</p>
<p>java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明已经存在的对象小于，等于，大于输入对象。</p>
<p>Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。</p>
<ol>
<li><p>Comparable 自然排序。（实体类实现，需要继承这个接口才可以调用）</p>
</li>
<li><p>Comparator 是定制排序。（不想实现Comparable接口的集合排序，不需要继承接口）</p>
<pre><code class="hljs java">
Collections.sort(list,<span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;()&#123;
			<span class="hljs-meta">@Override</span>
			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;
				<span class="hljs-keyword">return</span> o2 - o1;
			&#125;
		&#125;);</code></pre>

</li>
</ol>
<p>Comparable:  内部比较器，一个类如果想要使用    Collections.sort(list) 方法进行排序，则需要实现该接口</p>
<p>Comparator:  外部比较器用于对那些没有实现Comparable接口或者对已经实现的Comparable中的排序规则不满意进行排序.无需改变类的结构，更加灵活。（策略模式）</p>
</blockquote>
<h2 id="多态的原理是什么"><a href="#多态的原理是什么" class="headerlink" title="多态的原理是什么"></a>多态的原理是什么</h2><blockquote>
<ol>
<li><p>编译时多态（又称静态多态）</p>
<p>重载（overload）就是编译时多态的一个例子，编译时多态在编译时就已经确定，运行时运行的时候调用的是确定的方法。</p>
</li>
<li><p>运行时多态（又称动态多态）</p>
<p>常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定。这也是为什么有时候多态方法又被称为延迟方法的原因。</p>
</li>
</ol>
<p><strong>多态通常有两种实现方法：</strong></p>
<ol>
<li>子类继承父类（extends）</li>
<li>类实现接口（implements）</li>
</ol>
<p>其核心之处就在于对父类方法的改写或对接口方法的实现，以取得在运行时不同的执行效果。</p>
<p>要使用多态，在声明对象时就应该遵循一条法则：父类引用指向子类对象：<code>List list =　newArrayList();</code></p>
<p>定义方法参数时也通常总是应该优先使用父类类型或接口类型</p>
<p>最大的好处在于结构的灵活性：假如某一天我认为ArrayList的特性无法满足我的要求，我希望能够用LinkedList来代替它，那么只需要在对象创建的地方把new ArrayList()改为new LinkedList即可，其它代码一概不用改动。</p>
<p>多态最大的用途我认为在于对设计和架构的复用，更进一步来说，《设计模式》中提倡的针对接口编程而不是针对实现编程就是充分利用多态的典型例子。</p>
</blockquote>
<h2 id="接口和抽象类，面试官问我是怎么理解的，我说接口对应功能，抽象类对应属性，然后面试官给我说了他的看法，说抽象类更偏向于一种模板-然后又交流了一下各自的想法"><a href="#接口和抽象类，面试官问我是怎么理解的，我说接口对应功能，抽象类对应属性，然后面试官给我说了他的看法，说抽象类更偏向于一种模板-然后又交流了一下各自的想法" class="headerlink" title="接口和抽象类，面试官问我是怎么理解的，我说接口对应功能，抽象类对应属性，然后面试官给我说了他的看法，说抽象类更偏向于一种模板~ 然后又交流了一下各自的想法"></a>接口和抽象类，面试官问我是怎么理解的，我说接口对应功能，抽象类对应属性，然后面试官给我说了他的看法，说抽象类更偏向于一种模板~ 然后又交流了一下各自的想法</h2><blockquote>
<p>继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如狗是否能钻火圈，能则可以实现这个接口，不能就不实现这个接口。</p>
</blockquote>
<h2 id="如何通过反射和设置对象私有字段的值"><a href="#如何通过反射和设置对象私有字段的值" class="headerlink" title="如何通过反射和设置对象私有字段的值"></a>如何通过反射和设置对象私有字段的值</h2><blockquote>
<p>通过类对象的getDeclaredField()方法获取字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了</p>
</blockquote>
<h2 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)的区别是什么"></a>快速失败(fail-fast)和安全失败(fail-safe)的区别是什么</h2><blockquote>
<p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p>
<p>快速失败（fail—fast）</p>
<p>​     在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</p>
<p>​     原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p>  注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p>
<p>  场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p>
<p>安全失败（fail—safe）</p>
<p>  采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>  原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p>
<p>  缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>
<p>​     场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
</blockquote>
<h2 id="synchronized-的实现原理以及锁优化？"><a href="#synchronized-的实现原理以及锁优化？" class="headerlink" title="synchronized 的实现原理以及锁优化？"></a>synchronized 的实现原理以及锁优化？</h2><blockquote>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ol>
<li><strong>普通同步方法，锁是当前实例对象；</strong></li>
<li><strong>静态同步方法，锁是当前类的class对象；</strong></li>
<li><strong>同步方法块，锁是括号里面的对象。</strong></li>
</ol>
<p><strong>同步代码块：</strong></p>
<p>　　monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；</p>
<p><strong>同步方法</strong></p>
<p>　　synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在JVM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的<strong>accessflags字段中的synchronized标志位置1</strong>，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示class做为锁对象。</p>
</blockquote>
<p>Java对象头</p>
<blockquote>
<p>对象在内存中存储分为三块区域：对象头、实例数据和对齐填充 HotSpot虚拟机的对象头(Object Header)包括两部分信息: 第一部分<strong>“Mark Word”:</strong> 用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等.</p>
<p>第二部分<strong>“Klass Pointer”:</strong> 对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。(数组，对象头中还须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。 )</p>
<p>什么是Monitor？</p>
<p>　　我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。 </p>
<p>　　与一切皆对象一样，所有的Java对象是天生的Monitor，<strong>每一个Java对象都有成为Monitor的潜质</strong>，因为在Java的设计中 ，每一个Java对象自打娘胎里出来<strong>就带了一把看不见的锁，它叫做内部锁或者Monitor锁</strong>。 </p>
<p>　　Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），<strong>同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用</strong>。　　</p>
</blockquote>
<p>volatile 的实现原理？</p>
<blockquote>
<p>特性:</p>
<p>​    保证了不同线程对该变量操作的内存可见性——–如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值<br>​    禁止指令重排序</p>
<p><strong>内存可见性</strong></p>
<p>​    JMM规定所有变量都是存在主存中的，类似于上面提到的普通内存，每个线程又包含自己的工作内存，方便理解就可以看成CPU上的寄存器或者高速缓存。所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值在同步回主内存。</p>
<p>在线程执行时，首先会从主存中read变量值，再load到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。</p>
<p>禁止指令重排序</p>
<p>​    顾名思义：禁止编译器优化，指令执行代码的顺序。</p>
<p>​    加入volatile关键字的代码会多出一个lock前缀指令。<br><strong>lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</strong><br><strong>① 重排序时不能把后面的指令重排序到内存屏障之前的位置</strong><br><strong>② 使得本CPU的Cache写入内存</strong><br><strong>③ 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。</strong></p>
<p><strong>volatile不能保证原子性</strong></p>
</blockquote>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><blockquote>
<p>JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。</p>
<p><strong>原子性</strong></p>
<p>​    Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。</p>
<p><strong>可见性</strong></p>
<p>​    <strong>Java就是利用volatile来提供可见性的。</strong><br>当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。<br>其实通过synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是synchronized和Lock的开销都更大。</p>
<p><strong>有序性（Ordering）</strong><br>   JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段：</p>
</blockquote>
<h2 id="synchronized-在静态方法和普通方法的区别？"><a href="#synchronized-在静态方法和普通方法的区别？" class="headerlink" title="synchronized 在静态方法和普通方法的区别？"></a>synchronized 在静态方法和普通方法的区别？</h2><blockquote>
<p>synchronized修饰不加static的方法，锁是加在单个对象上，不同的对象没有竞争关系；修饰加了static的方法，锁是加载类上，这个类所有的对象竞争一把锁。</p>
</blockquote>
<h2 id="怎么实现所有线程在等待某个事件的发生才会去执行？"><a href="#怎么实现所有线程在等待某个事件的发生才会去执行？" class="headerlink" title="怎么实现所有线程在等待某个事件的发生才会去执行？"></a>怎么实现所有线程在等待某个事件的发生才会去执行？</h2><blockquote>
<p>java里面实现这个有两个办法，countdownlatch和cyclicbarrier。</p>
</blockquote>
<p>countdownlatch和cyclicbarrier</p>
<blockquote>
<p>countDownLatch是在java1.5被引入，跟它一起被引入的工具类还有CyclicBarrier、Semaphore、concurrentHashMap和BlockingQueue。</p>
<p>存在于java.util.cucurrent包下。</p>
<p>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</p>
<p>是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</p>
<pre><code class="hljs java">&gt;<span class="hljs-comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span>
&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123; &#125;;   
&gt;<span class="hljs-comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span>
&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123; &#125;;  
&gt;<span class="hljs-comment">//将count值减1</span>
&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countDown</span><span class="hljs-params">()</span> </span>&#123; &#125;;  </code></pre>

<p><strong>CyclicBarrier——–循环栅栏</strong></p>
<p>举个例子，就像生活中我们会约朋友们到某个餐厅一起吃饭，有些朋友可能会早到，有些朋友可能会晚到，但是这个餐厅规定必须等到所有人到齐之后才会让我们进去。这里的朋友们就是各个线程，餐厅就是 CyclicBarrier。</p>
<p>作用就是会让所有线程都等待完成后才会继续下一步行动。</p>
<pre><code class="hljs java">&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException</span>
<span class="hljs-function">&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException</span></code></pre>

<p><a href="https://www.jianshu.com/p/333fd8faa56e" target="_blank" rel="noopener">https://www.jianshu.com/p/333fd8faa56e</a></p>
<p><strong>CountDownLatch和CyclicBarrier区别：</strong><br>1.countDownLatch是一个计数器，线程完成一个记录一个，计数器递减，只能只用一次<br>2.CyclicBarrier的计数器更像一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供reset功能，可以多次使用</p>
<p>CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现的</p>
</blockquote>
<p>CAS？CAS 有什么缺陷，如何解决？</p>
<blockquote>
<p>Compare And Swap</p>
<p>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力</p>
<p>ABA问题====解决方法加版本号或者时间戳</p>
</blockquote>
<p>List，Map，Set接口在取元素时，各有什么特点</p>
<blockquote>
<p>List和set具有相似性质，它们都是单列的元素的集合，所以它们有一个共同的父接口，叫做Collection</p>
<p>Set里面不允许有重复的元素，所谓重复，即是不能有两个相等(注意，不是仅仅是相同)的对象</p>
<p>List表示有先后顺序的集合</p>
<p>Map与List和Set不同，它是双列的集合</p>
</blockquote>
<p>如何线程安全的实现一个计数器</p>
<h2 id="生产者消费者模式，要求手写过代码，还是要知道的"><a href="#生产者消费者模式，要求手写过代码，还是要知道的" class="headerlink" title="生产者消费者模式，要求手写过代码，还是要知道的"></a>生产者消费者模式，要求手写过代码，还是要知道的</h2><blockquote>
<p>（1）生产者生产数据到缓冲区中，消费者从缓冲区中取数据。<br>（2）如果缓冲区已经满了，则生产者线程阻塞；<br>（3）如果缓冲区为空，那么消费者线程阻塞。</p>
<p>Step:</p>
<p>（1）定义一个缓存队列，选择一个集合当做缓存，给予缓存上限，缓存队列只有两种行为（生产数据和消费数据）；<br>（2）定义一个生产者线程，调用缓存队列中的生产行为；<br>（3）定义一个消费者线程，调用缓存队列中的消费行为；</p>
<p>定义一个缓冲区</p>
<pre><code class="hljs java">&gt;<span class="hljs-keyword">package</span> test;

&gt;<span class="hljs-keyword">import</span> java.util.Iterator;
&gt;<span class="hljs-keyword">import</span> java.util.LinkedHashMap;
&gt;<span class="hljs-keyword">import</span> java.util.Map;

&gt;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PublicQueue</span> &lt;<span class="hljs-title">T</span>&gt;</span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> putIndex=<span class="hljs-number">0</span>;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxCount=<span class="hljs-number">50</span>;
   <span class="hljs-keyword">private</span> LinkedHashMap&lt;Integer,T&gt; linkedHashMap=<span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T msg)</span></span>
<span class="hljs-function">   </span>&#123;
       <span class="hljs-keyword">if</span>(linkedHashMap.size()==maxCount)
       &#123;
           <span class="hljs-keyword">try</span> &#123;
               wait();
           &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
               e.printStackTrace();
           &#125;
       &#125;<span class="hljs-keyword">else</span> &#123;
           notify();
       &#125;
       linkedHashMap.put(putIndex,msg);
       System.out.println(<span class="hljs-string">"生产一个产品，当前商品角标为："</span>+putIndex+<span class="hljs-string">"===文本为："</span>+msg+<span class="hljs-string">"===缓存长度为："</span>+linkedHashMap.size());
       putIndex = (putIndex + <span class="hljs-number">1</span> &gt;= maxCount) ? (putIndex + <span class="hljs-number">1</span>) % maxCount : putIndex + <span class="hljs-number">1</span>;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> T <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;
       <span class="hljs-keyword">if</span> (maxCount == <span class="hljs-number">0</span>) &#123;
           <span class="hljs-keyword">try</span> &#123;
               wait();
           &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
               e.printStackTrace();
           &#125;
       &#125; <span class="hljs-keyword">else</span> &#123;
           notifyAll();
       &#125;
       Iterator it=linkedHashMap.entrySet().iterator();
       T t=<span class="hljs-keyword">null</span>;
       <span class="hljs-keyword">if</span>(it.hasNext())
       &#123;
           Map.Entry&lt;Integer,T&gt; entry= (Map.Entry&lt;Integer, T&gt;) it.next();
           t=entry.getValue();
           <span class="hljs-keyword">int</span> index=entry.getKey();
           linkedHashMap.remove(index);
           System.out.println(<span class="hljs-string">"消费一个产品，当前商品角标为："</span>+index+<span class="hljs-string">"===文本为："</span>+ t +<span class="hljs-string">"===缓存长度为："</span>+linkedHashMap.size());
       &#125;
       <span class="hljs-keyword">return</span> t;
   &#125;

&gt;&#125;
</code></pre>

<p>定义生产者和消费者</p>
<pre><code class="hljs java">&gt;<span class="hljs-keyword">package</span> test;



&gt;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProduceThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;
   <span class="hljs-keyword">private</span> PublicQueue publicQueue;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProduceThread</span><span class="hljs-params">(PublicQueue publicQueue)</span> </span>&#123;
       <span class="hljs-keyword">this</span>.publicQueue = publicQueue;
   &#125;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;
           publicQueue.add(String.valueOf(i));
       &#125;
   &#125;
&gt;&#125;

&gt;<span class="hljs-keyword">package</span> test;

&gt;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;
   <span class="hljs-keyword">private</span> PublicQueue publicQueue;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConsumerThread</span><span class="hljs-params">(PublicQueue publicQueue)</span> </span>&#123;
       <span class="hljs-keyword">this</span>.publicQueue = publicQueue;
   &#125;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;
           publicQueue.remove();
       &#125;
   &#125;
&gt;&#125;
</code></pre>

<p>测试类</p>
<pre><code class="hljs java">&gt;<span class="hljs-keyword">package</span> test;

&gt;<span class="hljs-keyword">import</span> java.util.ArrayList;
&gt;<span class="hljs-keyword">import</span> java.util.HashMap;
&gt;<span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;
&gt;<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;
&gt;<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;


&gt;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
       PublicQueue publicQueue=<span class="hljs-keyword">new</span> PublicQueue();
       ConsumerThread consumerThread=<span class="hljs-keyword">new</span> ConsumerThread(publicQueue);
       ProduceThread produceThread=<span class="hljs-keyword">new</span> ProduceThread(publicQueue);
       Thread t1=<span class="hljs-keyword">new</span> Thread(consumerThread);
       Thread t2=<span class="hljs-keyword">new</span> Thread(produceThread);
       t1.start();
       t2.start();
   &#125;
&gt;&#125;</code></pre>



<p><a href="https://blog.csdn.net/Virgil_K2017/article/details/89283946?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/Virgil_K2017/article/details/89283946?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
</blockquote>
<p>sleep 和yeild方法有什么区别</p>
<blockquote>
<p>① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br>② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；<br>③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；</p>
<p>sleep() 方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是 <strong>sleep() 方法不会释放“锁标志”</strong>，也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。</p>
<p>wait() 方法需要和 notify() 及 notifyAll() 两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在 synchronized 语句块内使用，也就是说，调用 wait()，notify() 和 notifyAll() 的任务在调用这些方法前必须拥有对象的锁。</p>
<p><strong>wait() 方法与 sleep() 方法的不同之处在于，wait() 方法会释放对象的“锁标志”</strong></p>
<p>yield() 方法和 sleep() 方法类似，也不会释放“锁标志”，区别在于，它没有参数，即 yield() 方法只是使当前线程重新回到可执行状态</p>
<p>join() 方法会使当前线程等待调用 join() 方法的线程结束后才能继续执行</p>
</blockquote>
<p>乐观锁和悲观锁的使用场景</p>
<blockquote>
<p>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。</p>
<p>乐观锁的常见实现方式：CAS+版本号/时间戳</p>
<p>悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。</p>
<p><strong>读取频繁使用乐观锁，写入频繁使用悲观锁</strong></p>
</blockquote>
<h2 id="悲观锁的常见实现方式：lock-synchronized-retreentlock"><a href="#悲观锁的常见实现方式：lock-synchronized-retreentlock" class="headerlink" title="悲观锁的常见实现方式：lock synchronized retreentlock"></a>悲观锁的常见实现方式：lock synchronized retreentlock</h2><h2 id="乐观锁：CAS-MVCC"><a href="#乐观锁：CAS-MVCC" class="headerlink" title="乐观锁：CAS MVCC"></a>乐观锁：CAS MVCC</h2><p>MVCC</p>
<blockquote>
<p>Multi-Version Concurrency Control,翻译为中文即 多版本并发控制</p>
<p>MVCC通过保存数据的历史版本，根据比较版本号来处理数据的是否显示，从而达到读取数据的时候不需要加锁就可以保证事务隔离性的效果</p>
</blockquote>
<p>读写锁的实现方式，16位int的前八位和后八位分别作为读锁和写锁的标志位</p>
<p>死锁的条件，怎么解除死锁，怎么观测死锁。</p>
<blockquote>
<ol>
<li>互斥条件：一个资源一次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因为请求资源而阻塞时，对已经获得的资源保持不放</li>
<li>不剥夺条件：进程已经获得的资源，在未使用完之前，不能被强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ol>
<p>死锁的检测：</p>
<p>一个简单的死锁检测方法，准备两张表。</p>
<p>一张记录当前资源的分配，记录线程和它占有的资源的对应。</p>
<p>另一张记录当前等待资源的线程，记录等待的线程和它请求的资源的对应。</p>
<p>当能够检测到环路时，表示发生了死锁。</p>
<p>死锁的解除：</p>
<p>有两种方法，对应不同的操作。</p>
<p>第一种方法：进程终止，简单地终止一个或多个进程以打破循环等待。</p>
<ul>
<li>撤销所有死锁线程</li>
<li>一次终止一个线程直到取消死循环为止</li>
</ul>
<p>第二种方法：抢占资源，从一个或多个死锁进程中抢占一个或多个资源</p>
<ul>
<li>选择一个牺牲品</li>
<li>回滚</li>
<li>饥饿（在代价因素中加上回滚次数，回滚的越多则越不可能被作为牺牲品）</li>
</ul>
</blockquote>
<p>希望大家能够好好看一下反射的原理，怎么确定类，怎么调方法</p>
<blockquote>
<p>Class类就是Java 反射机制的入口，它封装了一个类或接口的运行时信息，通过调用Class类的方法可以获取这些信息</p>
</blockquote>
<p>RPC框架，同步异步，响应时间，这些都被问到过，还让设计过</p>
<p>同步，异步，阻塞，非阻塞 在深信服的面试中遇到过，最好再找一些应用场景加以理解</p>
<blockquote>
<p>同步和异步关注的是<strong>消息通信机制</strong> </p>
<p>所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由<em>调用者</em>主动等待这个<strong>调用</strong>的结果。</p>
<p>异步则是相反，<strong>调用\在发出之后，这个调用就直接返回了，所以没有返回结果</strong>。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>举个通俗的例子：<br>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。<br>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
<p>阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
</blockquote>
<p>问题+答案来源：</p>
<p><a href="https://zhuanlan.zhihu.com/p/35723259" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35723259</a></p>
<p>线程池：<a href="https://blog.csdn.net/lzxlfly/article/details/83904032" target="_blank" rel="noopener">https://blog.csdn.net/lzxlfly/article/details/83904032</a></p>
<p>锁：<a href="https://blog.csdn.net/qq_34337272/article/details/83409990" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/83409990</a></p>
<p>生产者和消费者：<a href="https://blog.csdn.net/Virgil_K2017/article/details/89283946?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/Virgil_K2017/article/details/89283946?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
<p>反射：<a href="https://blog.csdn.net/qq_34598667/article/details/99653905" target="_blank" rel="noopener">https://blog.csdn.net/qq_34598667/article/details/99653905</a></p>
<p>异步和同步：<a href="https://www.zhihu.com/question/19732473/answer/20851256" target="_blank" rel="noopener">https://www.zhihu.com/question/19732473/answer/20851256</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%A4%8D%E4%B9%A0%E5%A4%A7%E7%BA%B2/">复习大纲</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%A4%8D%E4%B9%A0/">复习</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/06/19/Java%E5%B9%B6%E5%8F%91/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java并发</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/06/19/Redis/">
                        <span class="hidden-mobile">Redis</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Java基础&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
