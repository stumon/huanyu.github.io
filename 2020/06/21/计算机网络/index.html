<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>计算机网络 - 郭寰宇</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>郭寰宇的个人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-06-21 08:42">
      2020年6月21日 早上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      211
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="1-五层网络模型"><a href="#1-五层网络模型" class="headerlink" title="1 五层网络模型"></a>1 五层网络模型</h3><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200527223109.png" srcset="/img/loading.gif" alt=""></p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528101732.png" srcset="/img/loading.gif" alt="image-20200528101728248"></p>
<p>作用</p>
<blockquote>
<ul>
<li><strong>1. 应用层</strong></li>
</ul>
<p>应用层（application-layer）的任务是通过<strong>应用进程间的交互来完成特定网络应用</strong>。应用层协议定义的是<strong>应用进程（进程：主机中正在运行的程序）间的通信和交互的规则</strong>。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为<strong>报文</strong>。</p>
<ul>
<li><strong>2. 运输层</strong></li>
</ul>
<p>运输层（transport layer）的主要任务就是负责<strong>向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。<strong>运输层为它上面的应用层提供通信服务。</strong></p>
<p>传输层两大重要的功能：复用 和 分用。<br>1.<strong>复用</strong>：在发送端，多个应用进程公用一个传输层；<br>2.<strong>分用</strong>：在接收端，传输层会根据端口号将数据分派给不同的应用进程。</p>
<ul>
<li><strong>3. 网络层</strong></li>
</ul>
<p>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， <strong>确保数据及时传送</strong>。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP / IP 体系结构中，由于<strong>网络层使用 IP</strong> 协议，因此分组也叫 <strong>IP 数据报</strong>，简称数据报。</p>
<ul>
<li><strong>4. 数据链路层</strong></li>
</ul>
<p>数据链路层（data link layer）链路是一个结点到另一个结点之间的<strong>物理线路</strong>，而中间没有其他交换结点。当传输数据时，还需要一些必要的<strong>通信协议</strong>来控制数据传输。因此，<strong>链路</strong>加上<strong>通信协议</strong>就是数据链路。</p>
<p>帧：数据链路层的协议数据单元为<strong>帧</strong>。数据链路层将网络层下发的<strong>IP数据报</strong>封装成帧。</p>
<ul>
<li><strong>5. 物理层</strong></li>
</ul>
<p>在物理层上所传送的数据单位是比特。物理层（physical layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
</blockquote>
<h4 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h4><p>应用层的任务是通过应用程序间的交互完成特定网络应用。</p>
<p>应用层协议定义的是应用进程之间的通信和交互规则，对于<strong>不同的网络应用需要不同的应用层协议</strong>。</p>
<p>常见的应用层协议有：DNS,HTTP,HTTPS,SMTP等</p>
<h5 id="1-1-1-DNS"><a href="#1-1-1-DNS" class="headerlink" title="1.1.1 DNS"></a>1.1.1 DNS</h5><p>DNS：域名解析系统，可以将域名映射成IP地址，使人更加方便的访问互联网</p>
<h5 id="1-1-2-HTTP（1-1）"><a href="#1-1-2-HTTP（1-1）" class="headerlink" title="1.1.2 HTTP（1.1）"></a>1.1.2 HTTP（1.1）</h5><p>HTTP：<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol，超文本传输协议。</p>
<h6 id="1-1-2-1-超文本"><a href="#1-1-2-1-超文本" class="headerlink" title="1.1.2.1 超文本"></a>1.1.2.1 超文本</h6><blockquote>
<p>早期文本指的是简单的字符文字，现在文本的含义已经扩展到图片、视频、压缩包等</p>
<p>超文本顾名思义：用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。HTML就是最常见的超文本，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等链接，经过浏览器解释，最终呈现出一个网页</p>
</blockquote>
<h6 id="1-1-2-2-传输"><a href="#1-1-2-2-传输" class="headerlink" title="1.1.2.2 传输"></a>1.1.2.2 传输</h6><blockquote>
<p>HTTP是一个专门在两点之间传输数据的<strong>双向协议</strong>。</p>
<p>这个两点可以是从互联网服务器到本地浏览器，也可以是服务器到服务器</p>
</blockquote>
<h6 id="1-1-2-3-状态码"><a href="#1-1-2-3-状态码" class="headerlink" title="1.1.2.3 状态码"></a>1.1.2.3 状态码</h6><blockquote>
<p>1XX：提示信息，目前是协议处理的中间状态，还需要后续操作</p>
<p>​        100：请求者应当<strong>继续</strong>提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</p>
<p>​        101：请求者已要求服务器<strong>切换协议</strong>，服务器已确认并准备切换</p>
<p>​        102：由WebDAV（RFC 2518）扩展的状态码，代表处理将被<strong>继续执行</strong>。</p>
<p>2XX：成功，报文已经收到并被正确处理</p>
<p>​        200 OK：最常见的成功状态码，表示一切正常</p>
<p>​        201：请求成功并且服务器创建了新的资源。</p>
<p>​        202：服务器已接受请求，但尚未处理。</p>
<p>​        203：服务器已成功处理了请求，但返回的信息可能来自另一来源。</p>
<p>​        204 No Content：服务器成功处理了请求，但没有返回任何内容</p>
<p>​        205：服务器成功处理了请求，但没有返回任何内容。</p>
<p>​        206 Partial Content：服务器成功处理了部分 GET 请求。。应用于HTTP分块下载或断电续传，表示响应返回的body数据并不是资源的全部，而是其中的一部分</p>
<p>3XX：重定向，资源发生变动，需要客户端重新发送请求。后续的请求地址（重定向目标）在本次响应的 Location 域中指明</p>
<p>​        301 Moved Permanently：永久重定向，说明请求的资源已经不存在了，需要用新的URL来再次访问</p>
<p>​        302 Found：临时重定向，说明请求的资源还在，但暂时需要用另一个URL来访问</p>
<p>​        304 Not Modified：不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称之为缓存重定向，用于缓存控制</p>
<p>​        301和302都会在响应头里使用字段Location，指明后续要跳转的URL，浏览器会自动重定向新的URL</p>
<p>4XX：客户端错误，请求的报文有误，服务器无法处理</p>
<p>​        400 Bad Request：表示客户端请求的报文有错误，服务器不理解请求的语法。</p>
<p>​        401：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p>
<p>​        403 Forbidden：表示服务器禁止访问资源，并不是客户端的请求出错</p>
<p>​        404 Not Found：请求的资源在服务器上不存在或者找不到，所以无法提供给客户端</p>
<p>​        405：禁用请求中指定的方法。</p>
<p>​        408：服务器等候请求时发生超时</p>
<p>​        410：如果请求的资源已永久删除，服务器就会返回此响应</p>
<p>​        414：请求的 URI（通常为网址）过长，服务器无法处理       </p>
<p>5XX：服务器错误，服务器处理请求时内部发生了错误</p>
<p>​        500 Internal Server Error：与400类似，一个笼统的错误码，具体原因不清楚</p>
<p>​        501 Not Implemented：客户端请求的功能还不支持</p>
<p>​        502 Bad GateWay：服务器自身工作正常，访问后端服务器发生了错误。通常是服务器作为网关或代理时返回的错误码</p>
<p>​        503 Service Unavailable：服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</p>
<p>​        504：服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p>
<p>​        505：服务器不支持请求中所用的 HTTP 协议版本。</p>
</blockquote>
<h6 id="1-1-2-4-常见字段"><a href="#1-1-2-4-常见字段" class="headerlink" title="1.1.2.4 常见字段"></a>1.1.2.4 常见字段</h6><p>Host</p>
<blockquote>
<p>客户端发送请求时，用来指定服务器的域名。如：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
</blockquote>
<p>Content-Length</p>
<blockquote>
<p>本次回应的数据长度（单位是字节）</p>
</blockquote>
<p>Connection</p>
<blockquote>
<p>最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。</p>
<p>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code></p>
<p>一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。</p>
</blockquote>
<p>Content-Type</p>
<blockquote>
<p>用于服务器回应时，告诉客户端，本次数据是什么格式</p>
<p>Content-Type: text/html; charset=utf-8</p>
<p>发送的是网页，编码格式是UTF-8</p>
<p>客户端请求时，可以使用Accept字段声明自己可以接受哪些数据格式</p>
</blockquote>
<p>Content-Encoding</p>
<blockquote>
<p>说明数据的压缩方法，表示服务器返回的数据使用了什么压缩格式</p>
<p>Content-Encoding: gzip</p>
<p>客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法。</p>
<p>Accept-Encoding: gzip, deflate</p>
</blockquote>
<h6 id="1-1-2-5-Get和Post的区别"><a href="#1-1-2-5-Get和Post的区别" class="headerlink" title="1.1.2.5 Get和Post的区别"></a>1.1.2.5 Get和Post的区别</h6><p>Get和Post都是HTTP协议中的两种发送请求的方法</p>
<blockquote>
<p><strong>GET 和 POST 方法没有实质区别</strong>，只是报文格式不同</p>
<p>GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议，无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。</p>
</blockquote>
<p>Get</p>
<blockquote>
<p>对数据长度有限制，发送数据时，GET方法向URL添加数据，URL的长度是受限制的（最大2048个字节）</p>
<ul>
<li>HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。</li>
</ul>
<p>对数据的类型有限制，只允许ASCII字符</p>
<p>安全性较差，以明文的方式发送数据。</p>
<p>发送的数据在URL中，所有人都可见</p>
</blockquote>
<p>Post</p>
<blockquote>
<p>对数据长度无限制</p>
<p>对数据的类型没有限制</p>
<p>比GET安全，发送的数据不会被保存在浏览器历史或web服务器日志中</p>
<p>发送的数据不会显示在URL中</p>
</blockquote>
<p>从标准上看，区别是：</p>
<blockquote>
<p>GET 用于获取信息，是无副作用的，是幂等的，且可缓存</p>
<ul>
<li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</li>
</ul>
<p>POST 用于修改服务器上的数据，有副作用，非幂等，不可缓存</p>
<ul>
<li><p><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。</p>
</li>
<li><p>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</p>
</li>
<li><p>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的</p>
</li>
</ul>
</blockquote>
<p>参数</p>
<blockquote>
<p>GET 方法参数写法：在约定中，我们的参数是写在 <code>?</code> 后面，用 <code>&amp;</code> 分割</p>
</blockquote>
<p>安全性</p>
<blockquote>
<p>按照网上大部分文章的解释，POST 比 GET 安全，因为数据在地址栏上不可见。</p>
<p>然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。</p>
<p>要想安全传输，就只有加密，也就是 HTTPS。</p>
</blockquote>
<h6 id="1-1-2-6-特性"><a href="#1-1-2-6-特性" class="headerlink" title="1.1.2.6 特性"></a>1.1.2.6 特性</h6><p>HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。</p>
<p>简单</p>
<blockquote>
<p>HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，<strong>易于理解</strong>，降低了学习和使用的门槛。</p>
</blockquote>
<p>灵活和易于扩展</p>
<blockquote>
<p>HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</p>
<p>同时 HTTP 由于是工作在应用层（ <code>OSI</code> 第七层），则它<strong>下层可以随意变化</strong>。</p>
<p>HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC。</p>
</blockquote>
<p>应用广泛和跨平台</p>
<blockquote>
<p>HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，HTTP 的应用<strong>片地开花</strong>，同时天然具有<strong>跨平台</strong>的优越性。</p>
</blockquote>
<p>缺点是无状态、明文传输，不安全。</p>
<p>无状态</p>
<blockquote>
<p>服务器不需要记录HTTP的状态，减轻了服务器的负担。但是另一方面，服务器没有记录状态，导致后续在关联性操作时会很麻烦</p>
<p>解决方法：Cookie技术</p>
<p>Cookie通过在请求和响应报文中加入Cookie信息来控制客户端的状态</p>
</blockquote>
<p>明文传输</p>
<blockquote>
<p>明文传输导致信息很容易被窃取，如果有账号和密码等重要信息，被窃取后会产生巨大损失</p>
</blockquote>
<p>不安全</p>
<blockquote>
<p>通信使用明文：内容会被窃取</p>
<p>不验证通信方的身份：可能遇到虚假的通信方</p>
<p>无法证明报文的完整性：报文可能会被篡改</p>
<p>解决方案：HTTPS，引入SSL/TLS层</p>
</blockquote>
<h6 id="1-1-2-7-性能"><a href="#1-1-2-7-性能" class="headerlink" title="1.1.2.7 性能"></a>1.1.2.7 性能</h6><p>HTTP 协议是基于 <strong>TCP/IP</strong>，并且使用了「<strong>请求 - 应答</strong>」的通信模式，所以性能的关键就在这<strong>两点</strong>里。</p>
<p>长连接</p>
<blockquote>
<p>早起的HTTP(1.0)主要的性能问题就是每发起一次请求，都会建立起一次TCP连接，服务器响应完毕后立即断开连接。多了很多额外的TCP连接建立和断开，增加通信开销</p>
<p>解决方法：HTTP（1.1）提出了长连接的概念，好处是减少了多余的TCP建立的重复建立和断开造成的额外开销，降低了服务器的负担</p>
<p>长连接（持久连接）特点：如果任意一方没有明确要求断开连接，则会一直保持连接状态</p>
</blockquote>
<p>管道网络传输</p>
<blockquote>
<p>长连接的建立，使得管道网络传输成为可能。即在同一个TCP连接中，客户端可以发起多个请求，只要第一个请求发出去了，不必等待其回来，就可以发送第二请求，减少了整体响应时间</p>
<p>但是可能会产生对头阻塞：因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据。</p>
</blockquote>
<h6 id="1-1-2-8-方法"><a href="#1-1-2-8-方法" class="headerlink" title="1.1.2.8 方法"></a>1.1.2.8 方法</h6><blockquote>
<p>GET：获取资源，当前网络中绝大部分使用的都是 GET；</p>
<p>HEAD：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分；</p>
<p>POST：传输实体主体</p>
<p>PUT：上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p>
<p>PATCH：对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p>
<p>OPTIONS：查询指定的 URL 支持的方法；</p>
<p>CONNECT：要求在与代理服务器通信时建立隧道。使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<p>TRACE：追踪路径。服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p>
</blockquote>
<h5 id="1-1-3-HTTPS"><a href="#1-1-3-HTTPS" class="headerlink" title="1.1.3 HTTPS"></a>1.1.3 HTTPS</h5><h6 id="1-1-3-1-与HTTP的区别"><a href="#1-1-3-1-与HTTP的区别" class="headerlink" title="1.1.3.1 与HTTP的区别"></a>1.1.3.1 与HTTP的区别</h6><blockquote>
<p>安全上：HTTPS在TCPHTTP网络层直接加了SSL/TLS安全协议，使得报文能够加密传输</p>
<p>连接建立：HTTP只需要TCP三次握手建立连接后就可以传输，而HTTPS在TCP三次握手之后，还需要进行SSL/TLS握手，才可以进行加密报文传输</p>
<p>端口号：HTTP是80，HTTPS是443</p>
<p>HTTPS还需要向CA申请数字证书，保证服务器的身份</p>
</blockquote>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528092612.png" srcset="/img/loading.gif" alt="image-20200528092605901"></p>
<p>HTTP 由于是明文传输，所以安全上存在以下三个风险</p>
<blockquote>
<ul>
<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li><strong>篡改风险</strong>，比如强制入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li>
</ul>
</blockquote>
<p>HTTPS解决了这三个问题</p>
<blockquote>
<ul>
<li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li>
<li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li>
<li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li>
</ul>
</blockquote>
<p>解决方法</p>
<blockquote>
<ul>
<li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li>
<li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li>
</ul>
</blockquote>
<h6 id="1-1-3-2-混合加密"><a href="#1-1-3-2-混合加密" class="headerlink" title="1.1.3.2 混合加密"></a>1.1.3.2 混合加密</h6><p>HTTPS采用的是对称加密和非对称加密结合的混合加密</p>
<ul>
<li><p>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</p>
</li>
<li><p>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据</p>
</li>
</ul>
<p>采用「混合加密」的方式的原因：</p>
<ul>
<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>
</ul>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528093256.png" srcset="/img/loading.gif" alt="image-20200528093251931"></p>
<h6 id="1-1-3-3-摘要算法"><a href="#1-1-3-3-摘要算法" class="headerlink" title="1.1.3.3 摘要算法"></a>1.1.3.3 摘要算法</h6><p><strong>摘要算法</strong>用来实现<strong>完整性</strong>，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528093357.png" srcset="/img/loading.gif" alt="image-20200528093353346"></p>
<p>用户在发送前，先用摘要算法编码一下明文，得到摘要，然后把明文和摘要一起发送过去，客户端得到明文和摘要后，再用相同的摘要算法，编码一下明文，得到的摘要和发送过来的摘要进行对比，两者相同，就说明数据是完整的</p>
<h6 id="1-1-3-4-数字证书"><a href="#1-1-3-4-数字证书" class="headerlink" title="1.1.3.4 数字证书"></a>1.1.3.4 数字证书</h6><p>客户端先向服务端索取公钥，然后用公钥加密信息，服务器收到信息后，再用私钥解密。但是公钥可能被篡改。</p>
<p>解决方法是将服务器公钥放在数字证书中（由CA颁发），只要证书是可信的，公钥就是可信的</p>
<h6 id="1-1-3-5-建立连接"><a href="#1-1-3-5-建立连接" class="headerlink" title="1.1.3.5 建立连接"></a>1.1.3.5 建立连接</h6><p>SSL/TLS协议基本流程</p>
<blockquote>
<p>客户端向服务器索要并验证服务器的公钥</p>
<p>双方协商产生会话秘钥</p>
<p>双方采用会话秘钥进行加密通信</p>
</blockquote>
<h6 id="1-1-3-6-HTTP的演变"><a href="#1-1-3-6-HTTP的演变" class="headerlink" title="1.1.3.6 HTTP的演变"></a><strong>1.1.3.6 HTTP的演变</strong></h6><p><strong>HTTP/1.1相较于HTTP/1.0的改进</strong></p>
<blockquote>
<p>使用了长连接，改善了1.0的短连接造成的性能开销</p>
<p>支持管道网络传输</p>
</blockquote>
<p><strong>HTTP/1.1的缺点</strong></p>
<blockquote>
<p><strong>请求/响应头未经压缩就发送，信息越多，延迟越大</strong></p>
<p><strong>发送冗长的首部，每次发送相同的首部浪费资源</strong></p>
<p><strong>服务器是按照请求的顺序响应的，容易发生对头阻塞</strong></p>
<p><strong>没有请求优先级控制</strong></p>
<p><strong>请求只能从客户端开始，服务端只能被动响应</strong></p>
</blockquote>
<p><strong>HTTP/2相较于HTTP/1.1的改进</strong></p>
<blockquote>
<p><strong>HTTP/2 协议是基于 HTTPS 的，所以HTTP/2保证了安全性</strong></p>
<p>头部压缩：如果<strong>同时发出多个请求，头是一样的，那么协议会帮助你相除重复部</strong>分（HPACK算法，客户端和服务端会维护一个头信息表，字段都会存入这个表中，并且生成一个索引号，以后就不送相同的字段了，只发送索引号，提高了速度）</p>
<p>二进制格式：HTTP/2采用了二进制格式，头信息和数据体都是二进制，并且统称为帧：头信息帧和数据帧。收到报文后无需转成二进制，直接解析二进制即可，提高传输效率</p>
<p><em>数据流</em>：HTTP/2的数据包不是按照顺序发送的，所以需要对数据包做标记，指出属于哪个响应。客户端发出的数据包编号为奇数，服务端为偶数。<strong>客户端可以指定数据流的优先级，优先级高的请求，服务端优先响应</strong></p>
<p>多路复用：HTTP/2可以<strong>在一个连接中并发多个请求或者回应</strong>，而不用按照顺序一一对应，<strong>解决了HTTP/1.1的对头阻塞，降低了延迟。</strong></p>
<p><strong>服务器推送</strong>：服务器不再是被动的响应，也可以主动向客户端发送消息。举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送（Server Push，也叫 Cache Push）。</p>
</blockquote>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528095532.png" srcset="/img/loading.gif" alt="image-20200528095528025"></p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528095758.png" srcset="/img/loading.gif" alt="image-20200528095753595"></p>
<p><strong>HTTP/3相较于HTTP/2的改进</strong></p>
<blockquote>
<p>HTTP2的主要问题是：<strong>多个 HTTP 请求在复用一个 TCP 连接</strong>，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p>
<ul>
<li><p>HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</p>
</li>
<li><p>HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</p>
<p>这都是基于 TCP 传输层的问题，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p>
<p>UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。</p>
<p>UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p>
<p>QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP/2 的多路复用的协议。</p>
<p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以 HTTP/3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</p>
<ul>
<li>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，<strong>其他流不会受到影响</strong>。</li>
<li>TL3 升级成了最新的 <code>1.3</code> 版本，头部压缩算法也升级成了 <code>QPack</code>。</li>
<li>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 <code>TLS/1.3</code> 的三次握手。QUIC 直接把以往的 TCP 和 <code>TLS/1.3</code> 的 6 次交互<strong>合并成了 3 次，减少了交互次数</strong>。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528100604.png" srcset="/img/loading.gif" alt="image-20200528100559981"></p>
<h4 id="1-2-传输层"><a href="#1-2-传输层" class="headerlink" title="1.2 传输层"></a>1.2 传输层</h4><h5 id="1-2-1-TCP"><a href="#1-2-1-TCP" class="headerlink" title="1.2.1 TCP"></a>1.2.1 TCP</h5><p>Transmission Control Protocol：传输控制协议。</p>
<p>TCP是面向链接的，提供可靠交付的，有流量控制，拥塞控制，提供全双工通信，面向字节流的协议。</p>
<h6 id="1-2-1-1-首部格式"><a href="#1-2-1-1-首部格式" class="headerlink" title="1.2.1.1 首部格式"></a>1.2.1.1 首部格式</h6><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200621094156" srcset="/img/loading.gif" alt="img"></p>
<blockquote>
<p>源端口和目的端口：顾名思义，发送数据时的端口号和接受数据的端口号</p>
<p>序号seq：用于对字节流进行编号，例如序号为500，表示第一个字节的编号为500，如果携带的数据长度为100，那么下一个报文段的序号应该是600</p>
<p>确认号ack：期望收到的下一个报文段的序号，比如服务端收到客服端发来的一个报文段，序号为500，携带的长度为300，那么服务端期望收到的下一个报文段的序号为800，服务端发送给客户端的确认报文段中的确认号就是800</p>
<p><strong>数据偏移</strong> 占4位：它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指<strong>出TCP报文段的首部长度</strong>。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的</p>
<p>控制位：从左到右分别是：CWR,ECE,URG,ACK,PSH,RST,SYN,FIN。</p>
<p>​    <strong>CWR</strong>：CWR与ECE都用于IP首部的ECN字段，ECE标志为1时，通知对方已将拥塞窗口缩小。</p>
<p>​    <strong>ECE</strong>：若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1</p>
<p>​    <strong>URG：</strong>该位设为 1，表示包中有需要紧急处理的数据，它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送</p>
<p>​    <strong>ACK：</strong>占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。</p>
<p>​    <strong>PSH：</strong>该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；</p>
<p>​    <strong>RST：</strong>该位设为 1，表示 TCP 连接出现异常必须强制断开连接；</p>
<p>​    <strong>SYN：</strong>用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；</p>
<p>​    当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1，因此SYN置为1就表示这是一个连接请求或连接接受报文。</p>
<p>​    <strong>FIN：</strong>该位设为 1，表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段</p>
<p>每个主机又对对方的 FIN 包进行确认应答之后可以断开连接。不过，主机收到 FIN 设置为 1 的 TCP 段之后不必马上回复一个 FIN 包，而是可以等到缓冲区中的所有数据都因为已成功发送而被自动删除之后再发 FIN 包；</p>
<p><strong>窗口：</strong>窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。</p>
<p>​    <strong>窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化</strong>。</p>
<p><strong>检验和</strong>    占2字节。检验和字段检验的范围包括首部和数据这两部分，和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部</p>
<p>紧急指针  占2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可以发送紧急数据。</p>
<p><strong>选项</strong>：长度可变，最长可达4字节。当没有使用“选项”时，TCP的首部长度是20字节。</p>
<p>​    TCP最初只规定了一种选项，即最大报文段长度MSS（Maximum Segment Szie）。注意MSS这个名词含义。MSS是每一个TCP报文段中的<strong>数据字段的最大长度</strong>。数据字段加上TCP首部才等于整个的TCP报文段。所以MSS并不是整个TCP报文段的最大长度，而是“TCP报文段长度减去TCP首部长度”。</p>
<p>为什么要规定一个最大报文长度MSS呢？这并不是考虑接受方的接收缓存可能存放不下TCP报文段中的数据。实际上，MSS与接收窗口值没有关系。我们知道，TCP报文段的数据部分，<strong>至少要加上40字节的首部</strong>（TCP首部20字节和IP首部20字节，这里还没有考虑首部中的可选部分）<strong>才能组装成一个IP数据报</strong>。若选择较小的MSS长度，网络的利用率就降低。设想在极端情况下，当TCP报文段只含有1字节的数据时，在IP层传输的数据报的开销至少有40字节（包括TCP报文段的首部和IP数据报的首部）。这样，对网络的利用率就不会超过1/41。到了数据链路层还要加上一些开销。但反过来，若TCP报文段非常长，那么在IP层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片组成成原来的TCP报文段，当传输出错时还要进行重传，这些也都会使开销增大。</p>
<p>​    <strong>因此，MSS应尽可能大些</strong></p>
</blockquote>
<h6 id="1-2-1-2-三次握手"><a href="#1-2-1-2-三次握手" class="headerlink" title="1.2.1.2 三次握手"></a>1.2.1.2 三次握手</h6><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528113912.png" srcset="/img/loading.gif" alt="image-20200528113908791"></p>
<blockquote>
<p>假设 A 为客户端，B 为服务器端。</p>
<p>最初客户端和服务端都处于 CLOSED(关闭) 状态。本例中 A（Client） 主动打开连接，B（Server） 被动打开连接。</p>
<p>第一次握手：A 的 TCP 客户端进程也是首先创建传输控制块 TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位 SYN=1，同时选择一个初始序号 seq = x。TCP 规定，SYN 报文段（即 SYN = 1 的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。</p>
<p>第二次握手：B 收到连接请求报文后，如果同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务端进程进入 SYN-RCVD（同步收到）状态。</p>
<p>第三次握手：TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y + 1，而自己的序号 seq = x + 1。这时 ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。</p>
<p>SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>ack=x+1，这个1是因为SYN占据了一个序列号空间。SYN和FIN虽然不携带数据，但是都要消耗掉一个序号，所以要加1</p>
</blockquote>
<p>这里有两个ack，一个是大写的ACK，一个是小写的ack。</p>
<p>大写的是控制位中的ACK，小写的是确认号。</p>
<p>大写的ACK：TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1</p>
<p>小写的ack：接收到的上一次远端主机传来的seq然后+1，再发送给远端主机。提示远端主机已经成功接收上一次所有数据。</p>
<p><strong>三次握手的目的</strong></p>
<blockquote>
<p>是让客户端和服务端确认对方和自己的发送接受能力都正常</p>
<p>指定自己的初始化序列号，为后面的可靠传送做准备</p>
<p>如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到</p>
</blockquote>
<p>确认双方的接受能力、发送能力是否正常</p>
<blockquote>
<p>第一次握手成功</p>
<p>​    服务端知道：</p>
<p>​        客户端的发送能力正常</p>
<p>​        服务端的接受能力正常</p>
<p>第二次握手成功</p>
<p>​    客户端知道：</p>
<p>​        服务端的发送能力正常，接受能力正常</p>
<p>​        客户端的发送能力正常，接受能力正常</p>
<p>第三次握手成功，说明</p>
<p>​    服务端知道：</p>
<p>​        客户端的接受能力正常</p>
<p>​        服务端的发送能力正常</p>
</blockquote>
<p><strong>两次握手不可以吗？</strong></p>
<blockquote>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接</p>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
</blockquote>
<p><strong>什么是半连接队列？</strong></p>
<blockquote>
<p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p>
</blockquote>
<p><strong>全连接队列</strong></p>
<blockquote>
<p>就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
</blockquote>
<p><strong>ISN是固定的吗？</strong></p>
<blockquote>
<p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p>
<p>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p>
</blockquote>
<p><strong>半连接队列</strong></p>
<blockquote>
<p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<p>这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ….</p>
</blockquote>
<p><strong>三次握手过程可以携带数据吗?</strong></p>
<blockquote>
<p>第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p>
<p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。</p>
</blockquote>
<p><strong>传了SYN，为什么还要传ACK</strong></p>
<blockquote>
<p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
</blockquote>
<h6 id="1-2-1-3-四次挥手"><a href="#1-2-1-3-四次挥手" class="headerlink" title="1.2.1.3 四次挥手"></a>1.2.1.3 四次挥手</h6><p>传输结束后，通信的双方都可以释放连接。现在 A 和 B 都处于 ESTABLISHED 状态</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528133640.png" srcset="/img/loading.gif" alt="image-20200528133637323"></p>
<blockquote>
<p>第一次挥手：A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq = u（等于前面已传送过的数据的最后一个字节的序号加 1），这时 A 进入 FIN-WAIT-1（终止等待1）状态，等待 B 的确认。请注意：TCP 规定，FIN 报文段即使不携带数据，也将消耗掉一个序号。</p>
<p>第二次挥手：B 收到连接释放报文段后立即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v（等于 B 前面已经传送过的数据的最后一个字节的序号加1），然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务端进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。A 收到来自 B 的确认后，就进入 FIN-WAIT-2(终止等待2)状态，等待 B 发出的连接释放报文段。</p>
<p>第三次挥手：若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。假定 B 的序号为 w（在半关闭状态，B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK(最后确认)状态，等待 A 的确认。</p>
<p>第四次挥手：A 在收到 B 的连接释放报文后，必须对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack = w + 1，而自己的序号 seq = u + 1（前面发送的 FIN 报文段要消耗一个序号）。然后进入 TIME-WAIT(时间等待) 状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL（MSL：最长报文段寿命）后，A 才能进入到 CLOSED 状态，然后撤销传输控制块，结束这次 TCP 连接。当然如果 B 一收到 A 的确认就进入 CLOSED 状态，然后撤销传输控制块。所以在释放连接时，B 结束 TCP 连接的时间要早于 A。</p>
</blockquote>
<p><strong>2MSL等待状态</strong></p>
<blockquote>
<p>MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。</p>
<p><strong>2MSL就是一个发送和一个回复所需的最大时间</strong></p>
<p>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p>
<p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP<strong>再次发送最后</strong>的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p>
</blockquote>
<p><strong>为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？</strong></p>
<blockquote>
<p>1 为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，B 就无法按照正常步骤进入 CLOSED 状态。</p>
<p>2 防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</p>
</blockquote>
<p><strong>为什么建立连接是三次握手，而关闭连接是四次挥手？</strong></p>
<blockquote>
<p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了</p>
<p>当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。</p>
<p>但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p>
</blockquote>
<h6 id="1-2-1-4-滑动窗口"><a href="#1-2-1-4-滑动窗口" class="headerlink" title="1.2.1.4  滑动窗口"></a>1.2.1.4  滑动窗口</h6><p>TCP 利用滑动窗口实现流量控制的机制。滑动窗口（Sliding window）是一种流量控制技术</p>
<p>滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报</p>
<h6 id="1-2-1-5-TCP如何保证可靠传输"><a href="#1-2-1-5-TCP如何保证可靠传输" class="headerlink" title="1.2.1.5 TCP如何保证可靠传输"></a>1.2.1.5 TCP如何保证可靠传输</h6><p>数据包校验</p>
<blockquote>
<p>目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；</p>
</blockquote>
<p>对失序数据包重排序</p>
<blockquote>
<p>既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；</p>
</blockquote>
<p>丢弃重复数据</p>
<blockquote>
<p>对于重复数据，能够丢弃重复数据；</p>
</blockquote>
<p>超时重发</p>
<blockquote>
<p>当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p>
</blockquote>
<p>流量控制</p>
<blockquote>
<p>TCP 使用的流量控制协议是可变大小的滑动窗口协议。</p>
<p>流量控制是为了控制发送方发送速率，保证接收方来得及接收</p>
<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p>TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制</p>
</blockquote>
<h6 id="1-2-1-6-拥塞控制"><a href="#1-2-1-6-拥塞控制" class="headerlink" title="1.2.1.6 拥塞控制"></a>1.2.1.6 拥塞控制</h6><p>CP 拥塞控制的目标是最大化利用网络上瓶颈链路的带宽。</p>
<p>拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。</p>
<p><strong>拥塞控制就是为了防止过多的数据注入到网络中</strong>，这样就可以使网络中的路由器或链路不致于过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p><strong>常见的 TCP 拥塞控制算法</strong>：Linux 内核默认的 Reno 算法</p>
<p>Reno 被许多教材（例如：《计算机网络——自顶向下的方法》）所介绍，适用于低延时、低带宽的网络，它将拥塞控制的过程分为四个阶段：<strong>慢启动、拥塞避免、快重传和快恢复</strong></p>
<blockquote>
<p>慢启动阶段思路是不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小，在没有出现丢包时每收到一个 ACK 就将拥塞窗口大小加一（单位是 MSS，最大单个报文段长度），每轮次发送窗口增加一倍，呈指数增长，若出现丢包，则将拥塞窗口减半，进入拥塞避免阶段；</p>
<p>当窗口达到慢启动阈值或出现丢包时，进入拥塞避免阶段，窗口每轮次加一，呈线性增长；当收到对一个报文的三个重复的 ACK 时，认为这个报文的下一个报文丢失了，进入快重传阶段，要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认；</p>
<p>快重传完成后进入快恢复阶段，将慢启动阈值修改为当前拥塞窗口值的一半，同时拥塞窗口值等于慢启动阈值，然后进入拥塞避免阶段，重复上述过程。</p>
</blockquote>
<p>慢开始</p>
<blockquote>
<p>cwnd：拥塞窗口</p>
<p>慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</p>
<p><strong>ssthresh (Slow Start Threshold)，</strong>慢启动的峰值线，一旦超过该峰值线，则进入拥塞避免。</p>
<p>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：<br>  当cwnd &lt; ssthresh时，使用慢开始算法。<br>  当cwnd &gt; ssthresh时，改用拥塞避免算法。<br>  当cwnd = ssthresh时，慢开始与拥塞避免算法任意。</p>
</blockquote>
<p>拥塞避免</p>
<blockquote>
<p>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1</p>
<p>当网络发生拥塞，把ssthresh值更新为此时CWND值的一半如下图24的一半，cwnd重新设置为1。重新执行慢开始算法</p>
</blockquote>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528145400.png" srcset="/img/loading.gif" alt="image-20200528145357482"></p>
<p>快重传和快恢复</p>
<blockquote>
<p>在 TCP/IP 中，快速重传和快恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。</p>
<p>没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。</p>
<p>有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。</p>
<p>有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和快恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p>
<p><strong>FRR：冗余 ACK</strong>来处理的。我们都知道，数据包是有序号的，如果A给B发送M1, M2, M3, M4, M5…N个数据包，如果B收到了M1, M2, M4….却始终没有收到M3，这个时候就会重复确认M2，意在告诉A,M3还没收到，可能是丢失。当A连续收到了三个确认M2的ACK，且M3超时事件还没发生。A就知道M3可能丢失了，这个时候A就不必等待M3设置的计时器到期了，而是快速重传M3。并且把ssthresh设置为MAX（此时的cwnd值）的一半，即ssthresh = MAX/2，但是这个时候并非把控制窗口N设置为1，而是让N = ssthresh，N在一个一个增长。</p>
</blockquote>
<h6 id="1-2-1-7-对应的应用层协议"><a href="#1-2-1-7-对应的应用层协议" class="headerlink" title="1.2.1.7 对应的应用层协议"></a>1.2.1.7 对应的应用层协议</h6><blockquote>
<p>FTP：文件传输协议，使用 21 端口</p>
<p>SMTP：简单邮件传送协议， 25 号端口</p>
<p>POP3：POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口</p>
<p>HTTP：从 Web 服务器传输超文本到本地浏览器的传送协议</p>
<p>Telnet：它是一种用于远程登陆的端口，23端口</p>
</blockquote>
<h6 id="1-2-1-8-粘包"><a href="#1-2-1-8-粘包" class="headerlink" title="1.2.1.8 粘包"></a>1.2.1.8 粘包</h6><blockquote>
<p>客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。</p>
<p>TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；</p>
<p>从 TCP 的帧结构也可以看出，在 <strong>TCP 的首部没有表示数据长度的字段。</strong></p>
<p>基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。</p>
<p>接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。</p>
</blockquote>
<p>粘包产生的原因</p>
<p>发送方</p>
<blockquote>
<p>采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 <strong>Nagle 算法</strong>，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个<strong>合并过程就是在发送缓冲区中进行的</strong>，也就是说<strong>数据发送出来它已经是粘包的状态了</strong>。</p>
</blockquote>
<p>接收方</p>
<blockquote>
<p>接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置<strong>接收缓冲区</strong>，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的<strong>读取数据函数不能及时的把缓冲区中的数据拿出来</strong>，而下一个数据又到来<strong>并有一部分放入的缓冲区末尾</strong>，等我们<strong>读取数据时就是一个粘包</strong>。（放数据的速度 &gt; 应用层拿数据速度）</p>
</blockquote>
<p>解决方法</p>
<blockquote>
<p>分包机制一般有两个通用的解决方法：</p>
<p>特殊字符控制；</p>
<p>在包头首都添加数据包的长度。</p>
<p>注意：UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。</p>
</blockquote>
<h5 id="1-2-2-UDP"><a href="#1-2-2-UDP" class="headerlink" title="1.2.2 UDP"></a>1.2.2 UDP</h5><h6 id="1-2-2-1-首部格式："><a href="#1-2-2-1-首部格式：" class="headerlink" title="1.2.2.1 首部格式："></a>1.2.2.1 首部格式：</h6><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528150014.png" srcset="/img/loading.gif" alt="image-20200528150012159"></p>
<blockquote>
<p>源端口：发送端端口</p>
<p>目标端口：接收端端口</p>
<p>包长度：UDP首部长度跟数据长度之和</p>
<p>校验和：目的是提供可靠的UDP首部和数据</p>
</blockquote>
<h6 id="1-2-2-2-特点"><a href="#1-2-2-2-特点" class="headerlink" title="1.2.2.2 特点"></a>1.2.2.2 特点</h6><blockquote>
<p>UDP 是无连接的；</p>
<p>UDP 尽最大努力交付，即不保证可靠交付</p>
<p>UDP 是面向报文的</p>
<p>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；</p>
<p>UDP 支持一对一、一对多、多对一和多对多的交互通信；</p>
<p>UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</p>
</blockquote>
<h5 id="1-2-2-3-对应的应用层协议"><a href="#1-2-2-3-对应的应用层协议" class="headerlink" title="1.2.2.3 对应的应用层协议"></a>1.2.2.3 对应的应用层协议</h5><blockquote>
<p>DNS：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。</p>
<p>SNMP：简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>
<p>TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在端口 69 上使用 UDP 服务。</p>
</blockquote>
<h3 id="2-七层网络模型"><a href="#2-七层网络模型" class="headerlink" title="2 七层网络模型"></a>2 七层网络模型</h3><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200527221554.png" srcset="/img/loading.gif" alt="image-20200527221549514"></p>
<h3 id="3-TCP-IP四层协议"><a href="#3-TCP-IP四层协议" class="headerlink" title="3  TCP/IP四层协议"></a>3  TCP/IP四层协议</h3><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200527223114.png" srcset="/img/loading.gif" alt=""></p>
<h3 id="4-常见面试题"><a href="#4-常见面试题" class="headerlink" title="4 常见面试题"></a>4 常见面试题</h3><h4 id="4-1-在浏览器中输入-URL-地址到显示主页的过程？"><a href="#4-1-在浏览器中输入-URL-地址到显示主页的过程？" class="headerlink" title="4.1 在浏览器中输入 URL 地址到显示主页的过程？"></a>4.1 在浏览器中输入 URL 地址到显示主页的过程？</h4><p>步骤</p>
<blockquote>
<ol>
<li>URL 解析</li>
<li>DNS 查询</li>
<li>TCP 连接</li>
<li>发送请求</li>
<li>处理请求并返回HTTP报文</li>
<li>渲染页面</li>
</ol>
</blockquote>
<h5 id="4-1-1-URL解析"><a href="#4-1-1-URL解析" class="headerlink" title="4.1.1 URL解析"></a>4.1.1 URL解析</h5><p>URL：Universal Resource Locator 统一资源定位符，俗称网页地址或者网址。</p>
<p>URL组成</p>
<blockquote>
<p>传输协议、服务器、域名、端口、虚拟目录、文件名、参数、锚</p>
<p>http             www       baidu.com 80</p>
</blockquote>
<p>当我们在浏览器输入URL后，浏览器首先对拿到的URL进行识别，抽取出域名字段</p>
<h5 id="4-1-2-DNS查询"><a href="#4-1-2-DNS查询" class="headerlink" title="4.1.2 DNS查询"></a>4.1.2 DNS查询</h5><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528154631.png" srcset="/img/loading.gif" alt="image-20200528154628623"></p>
<p>第一步：浏览器缓存</p>
<blockquote>
<p>浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询</p>
</blockquote>
<p>第二步：操作系统缓存</p>
<blockquote>
<p>操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p>
</blockquote>
<p>第三步：路由器缓存</p>
<blockquote>
<p>路由器也有自己的缓存。</p>
</blockquote>
<p>第四步 ISP DNS 缓存</p>
<blockquote>
<p>ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p>
</blockquote>
<p>第五步 根域名服务器查询</p>
<blockquote>
<p>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：</p>
<p>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地DNS服务器的过程）</p>
</blockquote>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528154927.png" srcset="/img/loading.gif" alt="image-20200528154924741"></p>
<h5 id="4-1-3-TCP连接"><a href="#4-1-3-TCP连接" class="headerlink" title="4.1.3 TCP连接"></a>4.1.3 TCP连接</h5><p>主机浏览器通过DNS解析得到了目标服务器的IP地址后，与服务器建立TCP连接。</p>
<p>连接成功后，客户端向服务端发送请求。</p>
<h5 id="4-1-4-浏览器通过http协议发送请求"><a href="#4-1-4-浏览器通过http协议发送请求" class="headerlink" title="4.1.4 浏览器通过http协议发送请求"></a>4.1.4 <strong>浏览器通过http协议发送请求</strong></h5><p>TCP/IP分为五层，发送数据时，每层都要对数据进行封装，物理层传输bit。</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528155151.png" srcset="/img/loading.gif" alt="image-20200528155148409"></p>
<h6 id="4-1-4-1-应用层：发送HTTP请求"><a href="#4-1-4-1-应用层：发送HTTP请求" class="headerlink" title="4.1.4.1 应用层：发送HTTP请求"></a>4.1.4.1 应用层：发送HTTP请求</h6><p>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p>
<ul>
<li>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等</li>
<li>请求主体（其他参数）</li>
</ul>
<p>其中需要注意的点：</p>
<ul>
<li>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</li>
</ul>
<h6 id="4-1-4-2-传输层：TCP传输报文"><a href="#4-1-4-2-传输层：TCP传输报文" class="headerlink" title="4.1.4.2 传输层：TCP传输报文"></a>4.1.4.2 传输层：TCP传输报文</h6><p>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。</p>
<p>在建立连接前，会先进行 TCP 三次握手。</p>
<h6 id="4-1-4-3-网络层：IP协议查询Mac地址"><a href="#4-1-4-3-网络层：IP协议查询Mac地址" class="headerlink" title="4.1.4.3 网络层：IP协议查询Mac地址"></a>4.1.4.3 <strong>网络层：IP协议查询Mac地址</strong></h6><p>将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。</p>
<p>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p>
<blockquote>
<p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p>
</blockquote>
<h6 id="4-1-4-4-链路层：以太网协议"><a href="#4-1-4-4-链路层：以太网协议" class="headerlink" title="4.1.4.4 链路层：以太网协议"></a>4.1.4.4 <strong>链路层：以太网协议</strong></h6><p><strong>以太网协议</strong></p>
<p>根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：</p>
<ul>
<li>标头：数据包的发送者、接受者、数据类型</li>
<li>数据：数据包具体内容</li>
</ul>
<p><strong>Mac 地址</strong></p>
<p>以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p>
<p><strong>广播</strong></p>
<p>发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。</p>
<h6 id="4-1-5-服务器接收请求并返回HTTP报文"><a href="#4-1-5-服务器接收请求并返回HTTP报文" class="headerlink" title="4.1.5 服务器接收请求并返回HTTP报文"></a>4.1.5 服务器接收请求并返回HTTP报文</h6><p>服务器端经过物理层<strong>→</strong>数据链路层<strong>→</strong>网络层<strong>→</strong>传输层<strong>→</strong>应用层，解析请求报文，发送HTTP响应报文。</p>
<h5 id="4-1-6-渲染页面"><a href="#4-1-6-渲染页面" class="headerlink" title="4.1.6 渲染页面"></a>4.1.6 渲染页面</h5><p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528162245.png" srcset="/img/loading.gif" alt="image-20200528162242378"></p>
<h4 id="4-2-对称加密和非对称加密是什么？"><a href="#4-2-对称加密和非对称加密是什么？" class="headerlink" title="4.2 对称加密和非对称加密是什么？"></a>4.2 对称加密和非对称加密是什么？</h4><p>信息的保密性我们可以使用对称加密和非对称加密来完成，使用对称加密来完成，速度相对非对称加密很快，但是存在一个安全问题，<strong>密钥如何传递？</strong>由此通用的方法是使用<strong>非对称加密+对称加密来完成</strong>。客户端使用公钥对对称加密的密钥进行加密，然后传递给服务端，服务端使用私钥进行解密确认密钥，开始传输数据。</p>
<p>在加密算法之外，面临一个问题，那就是：秘钥的分发。就是说，解密方如何获得加密方的秘钥呢？ 从而出现了：对称加密和非对称加密。</p>
<h5 id="4-2-1-对称加密"><a href="#4-2-1-对称加密" class="headerlink" title="4.2.1 对称加密"></a>4.2.1 对称加密</h5><p>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。</p>
<p>对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6</p>
<h5 id="4-2-2-非对称加密"><a href="#4-2-2-非对称加密" class="headerlink" title="4.2.2 非对称加密"></a>4.2.2 非对称加密</h5><p>非对称加密。比如RSA</p>
<p>公开密钥与私有密钥是一对，如果<strong>用公开密钥对数据进行加密，只有用对应的私有密钥才能解密</strong>；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>
<p>甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。</p>
<p>非对称加密指使用一对非对称密钥，即：公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</p>
<p>比如：A和B通信，A把自己的公钥K1发给B，B收到K1后，自己先生成一个秘钥K2，然后用接收到的K1对K2进行加密，把加密后的秘钥发送给A。A用自己的<strong>非对称加密的私钥</strong>，解开了公钥K1的加密，获得了K2。</p>
<p>中间人攻击：AB通信，中间人C截获了A的公钥后，自己另外成一对公钥私钥，把自己的公钥K3，发给B，B收到K3以为是A发过来的，然后B用K3对K2加密，把加密后的秘钥发给A，这个过程中再次被中间人截获，然后中间人用自己的私钥解密，然后再用A发来的公钥K1对K2加密，把加密后的秘钥发给A。这样一来，两个人后续的通信尽管用Key2做了对称加密，但是中间人已经掌握了Key2，所以可以轻松进行解密。</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528183147.png" srcset="/img/loading.gif" alt=""></p>
<p>解决方法：引入第三方</p>
<h5 id="4-2-3-证书颁发机构CA"><a href="#4-2-3-证书颁发机构CA" class="headerlink" title="4.2.3 证书颁发机构CA"></a>4.2.3 证书颁发机构CA</h5><p>数字证书是由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了持有人的相关信息，服务器的公钥，签署者签名信息（数字签名）等，<strong>最重要的是公钥在数字证书中，从而保证发送方的公钥是真的</strong>。</p>
<p>数字证书上由持有人的相关信息，通过这点可以确定其不是一个中间人；但是证书也是可以伪造的，如何保证证书为真呢？<strong>各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥</strong>。所以只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200528183355.png" srcset="/img/loading.gif" alt="image-20200528183353566"></p>
<blockquote>
<p>有一种算法，叫做hash算法。是单向加密。就是只能从明文得到密文，却无法从密文得到明文。这种算法有一个好处，就是明文哪怕只有一位不一样，加密后得到的密文也不一样。所以常用来进行比较明文是否被篡改过。</p>
</blockquote>
<p>数字证书生成过程：</p>
<blockquote>
<p>首先，有一个权威的证书签发机构，称为CA——全球就那么几个公司比较权威啦，这个机构，先用RSA产生一对公私钥。<br>私钥自己留着藏起来，你要是能偷到手就厉害了。<br>然后用自己的私钥对自己的公钥进行签名，生成所谓的数字证书。<br>这个过程大概是这样的：<br>先生成一个文件，文件内容大概是这样的：<br><strong>公钥内容</strong><br>签发者ID—-谁签发的证书<br>Subject—-也就是这个证书签发给谁。这里subject和签发者ID相同。<br>有效期<br>其他信息</p>
<p>以上内容都是明文。我们称为<strong>内容P</strong>。</p>
<p>然后使用hash算法，对内容P进行hash计算，得到一个hash值H。</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200621121421.png" srcset="/img/loading.gif" alt="image-20200621121417956"></p>
<p>然后使用签发机构的私钥对H进行RSA加密，得到<strong>签名信息S</strong>。这个步骤称为<strong>签名</strong>，<strong>就是用私钥对某公开内容的hash值进行加密。</strong><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200621121438.png" srcset="/img/loading.gif" alt="image-20200621121434764"></p>
<p>然后将P，S连成一个文件，这个文件就是所谓的<strong>数字证书</strong>了。所以数字证书里，包括证书持有者的身份信息，证书信息，证书持有人的公钥，以及签名信息。</p>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200621121459.png" srcset="/img/loading.gif" alt="image-20200621121451392"></p>
<p>现在假设某人得到了这个证书，如何<strong>确认这个证书属于谁的呢</strong>？<br>我们看数字证书里有些什么？可以得到P，可以得到S。<br>我们用<strong>同样的hash算法对P进行hash计算，得到一个hash值H1.</strong><br>P里有公钥，签发者ID，Subject，有效期，及其他信息。我们用公钥解密S，得到了一个值H’。<br>这个H‘，正常情况，或者说期望正常的话，应该就是制作数字证书的时候，用私钥对S加密的H。是否真如期望一样呢？比较一番就知道了。<br>现在对比H’和H1是否相等，如果相等，那么就证明这个证书是有签发者签发给subject的证书，就是符合期望了，也就是正常情况。否则就说明：1.内容P被篡改过，或者2.证书不是由CA签发的。<br>这个是对自签发证书的验证过程。需要说明的是，这种自签发证书的验证不常使用，但如何验证证书的原理类似。</p>
<p>既然自己可以给自己签发证书，那黑客宣称自己是某著名CA，然后给自己签发一个证书。那验证者如何来验证这个证书是黑客自己的呢还是那个著名的CA呢？<br>如果仅仅按照上文所说的自签发证书验证过程来看，是无法确认身份的。<br>啥？那搞毛啊？<br>不要急，这个问题，就是CA存在的意义了。</p>
<p>所谓<strong>全球权威的CA</strong>，就那么几个公司，这几个公司的证书，被各软件厂商设置成“<strong>可信任的根证书</strong>”了。所谓的根证书，是<strong>指这个证书是受信任的起始点，随后可以用这个证书来证明其他的证书</strong>。就好像你爸爸绝对相信你是好人，然后你再证明你的朋友A是好人，于是你爸爸相信A也是好人一样。所谓其他的证书，自然就是由CA签发的证书了，这些证书无法享受CA可信任的根证书待遇。</p>
<p>至于这些CA是怎么把自己的数字证书交给软件厂商而且让他们信任自己，我也不知道。如果你知道了，你就可以自己给自己签发一个证书，交给微软的IE，或者firefox等，让他们把你的证书嵌入到软件里去。这样一来，你就成了全球权威的CA之一了！</p>
<p>现在知道了，自签发的数字证书，要被各软件信任，是不容易的。一旦CA的根证书存在用户的系统了，就可以用这个根证书来验证其他证书了。并用被验证过的证书来认证身份</p>
</blockquote>
<p>当客户端发起请求时，服务器<strong>将该数字证书发送给客户端</strong>，客户端通过<strong>CA机构提供的公钥对加密密文进行解密获得散列值（数字签名）</strong>，同时将证书内容使用相同的散列算法进行Hash得到另一个散列值，比对两个散列值，如果两者相等则说明证书没问题。</p>
<p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性。但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p>
<h5 id="4-3-Cookie-和-Session的区别"><a href="#4-3-Cookie-和-Session的区别" class="headerlink" title="4.3 Cookie 和 Session的区别"></a>4.3 Cookie 和 Session的区别</h5><p>cookie保存在客户端，session保存在服务器端，<br>        cookie目的是跟踪会话，保存用户喜好或者保存用户名密码<br>        session用来跟踪会话，通过服务端记录用户的状态</p>
<h4 id="有哪些协议是基于-TCP-的，哪些是基于-UDP"><a href="#有哪些协议是基于-TCP-的，哪些是基于-UDP" class="headerlink" title="有哪些协议是基于 TCP 的，哪些是基于 UDP"></a>有哪些协议是基于 TCP 的，哪些是基于 UDP</h4><p>基于TCP的有FTP、Telnet、SMTP、HTTP、POP3与DNS<br>基于UDP的有TFTP、SNMP、DHCP与DNS<br>其中DNS既可以基于TCP，也可以基于UDP</p>
<p> QQ默认用的是UDP和腾讯自己的QICQ协议，但是QQ登录时选择TCP选项，也用到了TCP协议。微信主要是TCP协议。</p>
<p> IP地址</p>
<h4 id="请简述TCP-UDP的区别"><a href="#请简述TCP-UDP的区别" class="headerlink" title="请简述TCP\UDP的区别"></a>请简述TCP\UDP的区别</h4><blockquote>
<p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p>
<p>两者的区别大致如下：</p>
<ul>
<li>TCP面向连接，UDP面向非连接即发送数据前不需要建立链接</li>
<li>TCP提供可靠的服务（数据传输），UDP无法保证</li>
<li>TCP面向字节流，UDP面向报文</li>
<li>TCP数据传输慢，UDP数据传输快</li>
</ul>
</blockquote>
<h4 id="请简单说一下你了解的端口及对应的服务？"><a href="#请简单说一下你了解的端口及对应的服务？" class="headerlink" title="请简单说一下你了解的端口及对应的服务？"></a>请简单说一下你了解的端口及对应的服务？</h4><blockquote>
<p>80:http</p>
<p>443:https</p>
<p>3306:tomcat</p>
<p>6379:redis</p>
<p>22:SSH</p>
<p>8080:8080端口同80端口，是被用于WWW代理服务的，可以实现网页</p>
</blockquote>
<h4 id="IP地址有哪几类"><a href="#IP地址有哪几类" class="headerlink" title="IP地址有哪几类"></a>IP地址有哪几类</h4><blockquote>
<p>P 地址编址方案将 IP 地址空间划分为 A、B、C、D、E 五类，其中 A、B、C 是基本类，D、E 类作为多播和保留使用，为特殊地址。</p>
<p>判断IP地址类别，就看四组数中的第一组数</p>
<p>A 类地址：以 0 开头，第一个字节范围：0~127；</p>
<p>B 类地址：以 10 开头，第一个字节范围：128~191；</p>
<p>C 类地址：以 110 开头，第一个字节范围：192~223；</p>
<p>D 类地址：以 1110 开头，第一个字节范围为 224~239；</p>
<p>E 类地址：以 1111 开头，保留地址</p>
</blockquote>
<p><img src="https://gitee.com/monkey_stu/image/raw/master/img/20200621122216.png" srcset="/img/loading.gif" alt="img"></p>
<h4 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a><strong>TCP/IP四层模型</strong></h4><blockquote>
<p>自底而上分别是数据链路层、网络层、传输层和应用层</p>
<p><strong>数据链路层实现了网卡接口的网络驱动程序，以处理数据在物理媒介（比如以太网、令牌环等）上的传输。</strong></p>
<p>​    数据链路层两个常用的协议是ARP协议（Address Resolve Protocol，地址解析协议）和RARP协议</p>
<p><strong>网络层实现数据包的选路和转发。</strong></p>
<p><strong>传输层为两台主机上的应用程序提供端到端（end to end）的通信。与网络层使用的逐跳通信方式不同，传输层只关心通信的起始端和目的端，而不在乎数据包的中转过程。</strong></p>
<p><strong>应用层负责处理应用程序的逻辑。</strong></p>
</blockquote>
<h4 id="HTTP-协议包括哪些请求？"><a href="#HTTP-协议包括哪些请求？" class="headerlink" title="HTTP 协议包括哪些请求？"></a>HTTP 协议包括哪些请求？</h4><blockquote>
<ul>
<li>GET：对服务器资源的简单请求</li>
<li>POST：用于发送包含用户提交数据的请求</li>
</ul>
<p>简述HTTP中GET和POST的区别</p>
<p>从原理性看：</p>
<ul>
<li>根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的</li>
<li>根据HTTP规范，POST请求表示可能修改服务器上资源的请求</li>
</ul>
<p>从表面上看：</p>
<ul>
<li>GET请求的数据会附在URL后面，POST的数据放在HTTP包体</li>
<li>POST安全性比GET安全性高</li>
</ul>
</blockquote>
<h4 id="ARP-协议的工作原理？"><a href="#ARP-协议的工作原理？" class="headerlink" title="ARP 协议的工作原理？"></a>ARP 协议的工作原理？</h4><p>MAC地址是硬件地址，Ip只是逻辑地址</p>
<blockquote>
<p>网络层的 ARP 协议完成了 <strong>IP 地址与物理地址的映射</strong>。首先，每台主机都会在自己的 ARP 缓冲区中建立一个 <strong>ARP 列表</strong>，以<strong>表示 IP 地址和 MAC 地址的对应关系</strong>。当<strong>源主机需要将一个数据包要发送到目的主机时</strong>，会首<strong>先检查自己 ARP 列表</strong>中是否存在该 IP 地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向<strong>本地网段发起一个 ARP 请求的广播包</strong>，查询此目的主机对应的 MAC 地址。</p>
<p>此 ARP 请求数据包里包括<strong>源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址</strong>。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机<strong>首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中</strong>，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后<strong>给源主机发送一个 ARP 响应数据包</strong>，告诉对方<strong>自己是它需要查找的 MAC 地址</strong>；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址<strong>添加到自己的 ARP 列表中</strong>，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</p>
</blockquote>
<h4 id="谈谈你对-ARQ-协议的理解？"><a href="#谈谈你对-ARQ-协议的理解？" class="headerlink" title="谈谈你对 ARQ 协议的理解？"></a>谈谈你对 ARQ 协议的理解？</h4><blockquote>
<ul>
<li><strong>自动重传请求 ARQ 协议</strong></li>
</ul>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。</p>
<ul>
<li><strong>连续 ARQ 协议</strong></li>
</ul>
<p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
</blockquote>
<h4 id="DNS-的解析过程？"><a href="#DNS-的解析过程？" class="headerlink" title="DNS 的解析过程？"></a>DNS 的解析过程？</h4><blockquote>
<p>1 浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址，如果有，解析结束。</p>
<p>2 如果<strong>浏览器缓存</strong>中没有（专业点叫还没命中），浏览器会检查<strong>操作系统</strong>缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在windows中可通过c盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的ip地址，那浏览器会首先使用这个ip地址。</p>
<p>3 如果至此还没有命中域名，才会真正的请求<strong>本地域名服务器</strong>（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。</p>
<p>4 如果LDNS仍然没有命中，就直接跳到<strong>Root Server</strong> 域名服务器请求解析</p>
<p>5 根域名服务器返回给LDNS一个查询域的<strong>主域名服务器</strong>（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址</p>
<p>6 本地域名解析服务器向gTLD服务器发起请求。</p>
<p>7 gTLD服务器接收请求并返回<strong>Name Server服务器</strong></p>
<p>​    gTLD服务器接收本地域名服务器发起的请求，并根据需要解析的域名，找到该域名对应的<code>Name Server</code>域名服务器，通常情况下，这个<code>Name Server</code>服务器就是你注册的域名服务器，那么你注册的域名的服务商的服务器将承担起域名解析的任务。</p>
<p>8 Name Server服务器返回IP地址<strong>给本地服务器</strong></p>
<p>9 <strong>本地域名服务器缓存解析结果</strong></p>
<p>10 返回解析结果给用户</p>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>HTTP：<a href="https://mp.weixin.qq.com/s/4epUWMCLpwCBxxQgEbL8gA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/4epUWMCLpwCBxxQgEbL8gA</a></p>
<p>GET和POST的区别：<a href="https://zhuanlan.zhihu.com/p/57361216" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57361216</a></p>
<p>TCP和UDP：</p>
<p>​    <a href="https://zhuanlan.zhihu.com/p/86426969" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/86426969</a></p>
<p>​    <a href="https://blog.csdn.net/qq_38950316/article/details/81087809" target="_blank" rel="noopener">https://blog.csdn.net/qq_38950316/article/details/81087809</a></p>
<p>​    <a href="https://zhuanlan.zhihu.com/p/108822858" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/108822858</a></p>
<p>​    <a href="https://www.nowcoder.com/discuss/409281?channel=1000&amp;source_id=discuss_terminal_discuss_sim" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/409281?channel=1000&amp;source_id=discuss_terminal_discuss_sim</a></p>
<p>​    <a href="https://www.cnblogs.com/weilingfeng/archive/2019/05/10/10845882.html" target="_blank" rel="noopener">https://www.cnblogs.com/weilingfeng/archive/2019/05/10/10845882.html</a></p>
<p>​    <a href="https://zhuanlan.zhihu.com/p/84316213" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/84316213</a></p>
<p>两次握手：<a href="https://blog.csdn.net/ljq140421/article/details/77864208" target="_blank" rel="noopener">https://blog.csdn.net/ljq140421/article/details/77864208</a></p>
<p>两种ack的区别：<a href="https://blog.csdn.net/baiyan3212/article/details/81302448" target="_blank" rel="noopener">https://blog.csdn.net/baiyan3212/article/details/81302448</a></p>
<p>ack+1的原因：<a href="https://www.cnblogs.com/suyunhong/p/10582962.html" target="_blank" rel="noopener">https://www.cnblogs.com/suyunhong/p/10582962.html</a></p>
<p>在浏览器中输入网址发生了什么： <a href="https://4ark.me/post/b6c7c0a2.html" target="_blank" rel="noopener">https://4ark.me/post/b6c7c0a2.html</a></p>
<p>对称加密和非对称加密： <a href="https://www.jianshu.com/p/29e0ba31fb8d" target="_blank" rel="noopener">https://www.jianshu.com/p/29e0ba31fb8d</a></p>
<p>​                                            <a href="https://www.zhihu.com/question/24294477/answer/74783418" target="_blank" rel="noopener">https://www.zhihu.com/question/24294477/answer/74783418</a></p>
<p>TCP首部格式：<a href="https://blog.csdn.net/qq_32998153/article/details/79680704" target="_blank" rel="noopener">https://blog.csdn.net/qq_32998153/article/details/79680704</a></p>
<p><strong>计算机网络之面试常考</strong>： <a href="https://www.nowcoder.com/discuss/1937" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/1937</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%A4%8D%E4%B9%A0%E5%A4%A7%E7%BA%B2/">复习大纲</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%A4%8D%E4%B9%A0/">复习</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "计算机网络&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
